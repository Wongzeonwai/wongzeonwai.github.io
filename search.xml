<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker学习笔记</title>
    <url>/2024/09/12/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、Docker安装"><a href="#一、Docker安装" class="headerlink" title="一、Docker安装"></a>一、Docker安装</h1><h2 id="1、Centos安装过程"><a href="#1、Centos安装过程" class="headerlink" title="1、Centos安装过程"></a>1、Centos安装过程</h2><h3 id="（1）卸载旧版本的Docker"><a href="#（1）卸载旧版本的Docker" class="headerlink" title="（1）卸载旧版本的Docker"></a>（1）卸载旧版本的Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure>

<h3 id="（2）更新yum源"><a href="#（2）更新yum源" class="headerlink" title="（2）更新yum源"></a>（2）更新yum源</h3><p>更新前先备份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure>

<p>下载新的<code>CentOS-Base.repo</code>到<code>/etc/yum.repos.d/</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure>

<p>生成缓存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<h3 id="（3）安装docker"><a href="#（3）安装docker" class="headerlink" title="（3）安装docker"></a>（3）安装docker</h3><p>Docker 的安装需要一些依赖包，包括<code>yum-utils</code>、<code>device-mapper-persistent-data</code>和<code>lvm2</code>等。可以使用命令<code>yum install -y yum-utils device-mapper-persistent-data lvm2</code>来安装这些依赖包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure>

<p>配置<code>Docker</code>的<code>yum</code>源。可以使用命令<code>yum-config-manager --add-repo</code>来添加<code>Docker</code>的官方源或国内镜像源（如阿里云镜像源）。添加后，使用命令<code>yum makecache fast</code>来更新 yum 缓存。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>

<p>安装<code>Docker</code>社区版</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure>

<p>启动Docker。先关闭并禁用防火墙随机启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<p>启动后查看docker状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<h3 id="（4）安装docker-compose"><a href="#（4）安装docker-compose" class="headerlink" title="（4）安装docker-compose"></a>（4）安装docker-compose</h3><p>通过curl命令下载，并指定保存到 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/v2.32.1/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>增加文件执行权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>查看版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose version // Docker Compose version v2.32.1</span><br></pre></td></tr></table></figure>

<p>国内镜像站配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://docker.m.daocloud.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.1panel.live&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://hub.rat.dev&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.ccs.tencentyun.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirrors.aliyun.com&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="二、Docker基本命令"><a href="#二、Docker基本命令" class="headerlink" title="二、Docker基本命令"></a>二、Docker基本命令</h1><p><img src="/2024/09/12/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/docker.png" alt="docker"></p>
<h2 id="1、镜像"><a href="#1、镜像" class="headerlink" title="1、镜像"></a>1、镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull 镜像库/作者/镜像名:版本</span><br><span class="line">docker pull docker.io/library/nginx:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--platform=系统架构</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看下载的镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除镜像</span></span><br><span class="line">docker rmi 镜像ID/镜像名</span><br></pre></td></tr></table></figure>

<h2 id="2、容器"><a href="#2、容器" class="headerlink" title="2、容器"></a>2、容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建并启动容器</span></span><br><span class="line">docker run 镜像名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 在后台运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 宿主机端口:容器端口 端口映射</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v 宿主机文件存放地址、挂载卷:容器文件存放地址 数据卷映射</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e 配置环境变量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name 容器自定义名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--<span class="built_in">rm</span> 停止容器后自动删除</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-it 启动容器后可以进入容器内部，如 Linux 容器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--restart 容器停止后自动重启，always 总是生效，unless-stopper 手动停止容器后不生效</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-c 替换 dockerfile 中的 CMD 命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--network 子网名 加入子网，host 下容器可以直接使用宿主机网络，不需要指定端口号</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-a 查看所有容器</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除容器</span></span><br><span class="line">docker rm 容器名/容器ID</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f 强制删除正在运行的容器</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop 容器名/容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器</span></span><br><span class="line">docker start 容器名/容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器配置</span></span><br><span class="line">docker inspect 容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建容器，后面可选参数与 run 命令相同</span></span><br><span class="line">docker create 镜像名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">docker logs 容器名/容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行 Linux 命令</span></span><br><span class="line">docker exec 容器名/容器ID Linux命令</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器并开启一个 Linux 命令行</span></span><br><span class="line">docker exec -it 容器名/容器ID /bin/sh</span><br></pre></td></tr></table></figure>

<h2 id="3、挂载卷"><a href="#3、挂载卷" class="headerlink" title="3、挂载卷"></a>3、挂载卷</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建挂载卷名</span></span><br><span class="line">docker volume create 挂载卷名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看挂载卷地址</span></span><br><span class="line">docker volume inspect 挂载卷名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有挂载卷</span></span><br><span class="line">docker volume list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除挂载卷</span></span><br><span class="line">docker volume rm 挂载卷名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有没有容器使用的挂载卷</span></span><br><span class="line">docker volume prune -a</span><br></pre></td></tr></table></figure>

<h2 id="4、网络"><a href="#4、网络" class="headerlink" title="4、网络"></a>4、网络</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个子网，同一个子网下的容器可以相互访问，在 Linux 使用 ping 容器名 可以查看子网IP</span></span><br><span class="line">docker network create 子网名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有网络</span></span><br><span class="line">docker network list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除自定义子网</span></span><br><span class="line">docker network rm 子网名/子网ID</span><br></pre></td></tr></table></figure>

<h2 id="5、compose"><a href="#5、compose" class="headerlink" title="5、compose"></a>5、compose</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行 compose 文件</span></span><br><span class="line">docker compose up</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 在后台执行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f 指定文件名</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止并删除 compose 下的容器</span></span><br><span class="line">docker compose down</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker compose stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器</span></span><br><span class="line">docker compose start</span><br></pre></td></tr></table></figure>

<h1 id="三、Dockerfile"><a href="#三、Dockerfile" class="headerlink" title="三、Dockerfile"></a>三、Dockerfile</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> 镜像名</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> 工作目录</span></span><br><span class="line"><span class="comment"># 复制工程下的所有文件到，第一个点表示当前工程文件夹，第二个点表示工作目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> 执行命令</span></span><br><span class="line"><span class="comment"># 只能存在一个 CMD</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [容器运行时默认执行的命令]</span></span><br><span class="line"><span class="comment"># 同 CMD</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> []</span></span><br><span class="line"><span class="comment"># 环境变量，一个 ENV 下可以设置多个环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> key=value</span><br><span class="line"><span class="comment"># 监听端口，实际不发布，只是作为开发之间的约束，不指定协议默认为 tcp</span></span><br><span class="line"><span class="keyword">EXPOSE</span> port/protocol</span><br><span class="line"><span class="keyword">MAINTAINER</span> 镜像维护者</span><br><span class="line"><span class="comment"># 设置容器下的用户，默认为 root</span></span><br><span class="line"><span class="keyword">USER</span> 用户名</span><br></pre></td></tr></table></figure>

<h1 id="四、docker-compose-yaml"><a href="#四、docker-compose-yaml" class="headerlink" title="四、docker-compose.yaml"></a>四、docker-compose.yaml</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">版本号</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="string">容器名:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">使用的镜像</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="string">环境变量</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">本地数据存放地址:容器数据存放地址</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">本机端口:容器端口</span></span><br><span class="line">    <span class="attr">depends-on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">依赖于哪个容器（判断执行顺序）</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">重启策略</span></span><br><span class="line"></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line">	<span class="string">自定义子网名:</span></span><br><span class="line">	</span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">	<span class="string">自定义数据卷名:</span></span><br></pre></td></tr></table></figure>

<p>同一个 <strong>yaml</strong> 文件下的子网地址是相同的。</p>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>GVM安装笔记</title>
    <url>/2024/10/17/GVM%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、GVM介绍"><a href="#一、GVM介绍" class="headerlink" title="一、GVM介绍"></a>一、GVM介绍</h1><p><strong>GVM（Go Version Manager）</strong>，一款<code>Go</code>语言版本管理工具，类似于<code>nodejs</code>版本管理工具<code>nvm</code>。</p>
<h1 id="二、Windows安装方式"><a href="#二、Windows安装方式" class="headerlink" title="二、Windows安装方式"></a>二、Windows安装方式</h1><p>在<a href="https://github.com/voidint/g/blob/master/README_CN.md">g&#x2F;README_CN.md at master · voidint&#x2F;g (github.com)</a>下找到安装包进行安装。</p>
<p><img src="/2024/10/17/GVM%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/install.png" alt="install"></p>
<p>打开系统环境变量，增加如下变量：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 配置golang下载镜像，不用翻墙。</span><br><span class="line">G_MIRROR=https://golang.google.cn/dl/</span><br><span class="line"># 开启实验特性，用于使修改go存放目录生效。</span><br><span class="line">G_EXPERIMENTAL=true</span><br><span class="line"># 更改go存放目录</span><br><span class="line">G_HOME=自定义地址</span><br><span class="line">GOROOT=%G_HOME%\go</span><br><span class="line"># 配置PATH变量</span><br><span class="line">%GOROOT%\bin</span><br></pre></td></tr></table></figure>

<p>设置完成后，打开<code>powershell</code>或者<code>cmd</code>测试一下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：</span></span><br><span class="line">g</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">NAME:</span><br><span class="line">  g - Golang Version Manager</span><br><span class="line"></span><br><span class="line"> USAGE:</span><br><span class="line">  g  command [<span class="type">arguments...</span>]</span><br><span class="line"></span><br><span class="line"> VERSION:</span><br><span class="line">  <span class="number">1.7</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"> AUTHOR:</span><br><span class="line">  voidint &lt;voidint@<span class="number">126</span>.com&gt;</span><br><span class="line"></span><br><span class="line"> COMMANDS:</span><br><span class="line">    <span class="built_in">ls</span>, l               List installed versions</span><br><span class="line">    <span class="built_in">ls</span><span class="literal">-remote</span>, lr, lsr  List remote versions available <span class="keyword">for</span> install</span><br><span class="line">    use                 <span class="keyword">Switch</span> to specified version</span><br><span class="line">    install, i          Download and install a version</span><br><span class="line">    uninstall           Uninstall a version</span><br><span class="line">    clean               Remove files from the package download directory</span><br><span class="line">    env                 Show env variables of g</span><br><span class="line">    self                Modify g itself</span><br><span class="line">    help, <span class="built_in">h</span>             Shows a list of commands or help <span class="keyword">for</span> one command</span><br><span class="line"></span><br><span class="line"> GLOBAL OPTIONS:</span><br><span class="line">  <span class="literal">--help</span>, <span class="literal">-h</span>     show help</span><br><span class="line">  <span class="literal">--version</span>, <span class="literal">-v</span>  print the version</span><br><span class="line"></span><br><span class="line"> COPYRIGHT:</span><br><span class="line">  Copyright (c) <span class="number">2019</span><span class="literal">-2024</span>, voidint. All rights reserved.</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 更新g本身：</span></span><br><span class="line">  g self update</span><br><span class="line">  <span class="comment"># 卸载g：</span></span><br><span class="line">  g self uninstall</span><br></pre></td></tr></table></figure>

<p>有关<strong>Linux</strong>系统下安装或其他信息可以参考文档：<a href="https://github.com/voidint/g/blob/master/README_CN.md">g&#x2F;README_CN.md at master · voidint&#x2F;g (github.com)</a>。</p>
<p><strong>Linux</strong>系统下也可以之间通过命令行方式安装。</p>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin学习笔记</title>
    <url>/2024/08/16/Gin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、Gin简介"><a href="#一、Gin简介" class="headerlink" title="一、Gin简介"></a>一、Gin简介</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><ul>
<li><code>Golang</code>编写的一个轻量级<code>HTTP Web</code>框架，运行速度快。</li>
<li>擅长处理<code>API</code>接口的高并发。</li>
<li>官网地址：<a href="https://gin-gonic.com/zh-cn">https://gin-gonic.com/zh-cn</a></li>
<li><code>github</code>地址：<a href="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a></li>
</ul>
<h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><ul>
<li><p>快速：基于<code>Radix</code>树的路由，小内存占用。没有反射。可预测的<code>API</code>性能。</p>
</li>
<li><p>支持中间件：传入的<code>HTTP</code>请求可以由一系列中间件和最终操作来处理。 例如：<code>Logger</code>，<code>Authorization</code>，<code>GZIP</code>，最终操作<code>DB</code>。</p>
</li>
<li><p><code>Crash</code>处理：<code>Gin</code>可以<code>catch</code>一个发生在<code>HTTP</code>请求中的<code>panic</code>并<code>recover</code>它。这样，你的服务器将始终可用。例如，你可以向<code>Sentry</code>报告这个<code>panic</code>！</p>
</li>
<li><p><code>JSON</code>验证：<code>Gin</code>可以解析并验证请求的<code>JSON</code>，例如检查所需值的存在。</p>
</li>
<li><p>路由组：更好地组织路由。是否需要授权，不同的<code>API</code>版本…… 此外，这些组可以无限制地嵌套而不会降低性能。</p>
</li>
<li><p>错误管理：<code>Gin</code>提供了一种方便的方法来收集<code>HTTP</code>请求期间发生的所有错误。最终，中间件可以将它们写入日志文件，数据库并通过网络发送。</p>
</li>
<li><p>内置渲染：<code>Gin</code>为<code>JSON</code>，<code>XML</code>和<code>HTML</code>渲染提供了易于使用的<code>API</code>。</p>
</li>
<li><p>可扩展性：新建一个中间件非常简单，</p>
</li>
</ul>
<h2 id="2、安装使用"><a href="#2、安装使用" class="headerlink" title="2、安装使用"></a>2、安装使用</h2><ol>
<li><p>下载并安装 gin：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>
</li>
<li><p>将 gin 引入到代码中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>（可选）如果使用诸如 <code>http.StatusOK</code> 之类的常量，则需要引入 <code>net/http</code> 包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建main.go配置路由</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1.创建路由</span></span><br><span class="line">  r := gin.Default()</span><br><span class="line">  <span class="comment">// 2.绑定路由规则，执行的函数</span></span><br><span class="line">  <span class="comment">// gin.Context，封装了request和response</span></span><br><span class="line">  r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.String(http.StatusOK, <span class="string">&quot;hello World!&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 3.监听端口，默认在8080</span></span><br><span class="line">  <span class="comment">// Run(&quot;里面不指定端口号默认为8080&quot;) </span></span><br><span class="line">  r.Run(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开<code>http://localhost:8000/</code></p>
<p><img src="/2024/08/16/Gin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/helloworld.png" alt="helloworld"></p>
</li>
</ol>
<h2 id="2、响应参数"><a href="#2、响应参数" class="headerlink" title="2、响应参数"></a>2、响应参数</h2><h3 id="（1）JSON数据"><a href="#（1）JSON数据" class="headerlink" title="（1）JSON数据"></a>（1）JSON数据</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c.JSON(code, json)</span><br></pre></td></tr></table></figure>

<h3 id="（2）JSONP数据"><a href="#（2）JSONP数据" class="headerlink" title="（2）JSONP数据"></a>（2）JSONP数据</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://localhost:8000/jsonp?callback=xxxx</span></span><br><span class="line"><span class="comment">// xxx(json)</span></span><br><span class="line">r.GET(<span class="string">&quot;/jsonp&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  c.JSONP(code, json)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）XML数据"><a href="#（3）XML数据" class="headerlink" title="（3）XML数据"></a>（3）XML数据</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c.XML(code, gin.H&#123;</span><br><span class="line">  <span class="string">&quot;success&quot;</span>: <span class="literal">true</span></span><br><span class="line">  <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;这是XML数据&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;map&gt;</span></span><br><span class="line"><span class="comment">	&lt;success&gt;true&lt;/success&gt;</span></span><br><span class="line"><span class="comment">	&lt;msg&gt;这是XML数据&lt;msg&gt;</span></span><br><span class="line"><span class="comment">&lt;/map&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）HTML模板"><a href="#（4）HTML模板" class="headerlink" title="（4）HTML模板"></a>（4）HTML模板</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.LoadHTMLGlob(<span class="string">&quot;templates/*&quot;</span>)</span><br><span class="line">c.HTML(code, <span class="string">&quot;HTML文件名&quot;</span>, gin.H&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;这是title&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;.title&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>templates目录下有多级目录</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-templates</span></span><br><span class="line"><span class="comment">	-admin</span></span><br><span class="line"><span class="comment">		-index.html</span></span><br><span class="line"><span class="comment">  -shop</span></span><br><span class="line"><span class="comment">		-index.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">r.LoadHTMLGlob(<span class="string">&quot;templates/**/*&quot;</span>)</span><br><span class="line">c.HTML(code, <span class="string">&quot;default/index.html&quot;</span>, gin.H&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;这是title&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用define定义文件名 --&gt;</span></span><br><span class="line">&#123;&#123; define: &quot;default/index.html&quot; &#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;.title&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）静态文件"><a href="#（5）静态文件" class="headerlink" title="（5）静态文件"></a>（5）静态文件</h3><p>HTML引入了静态文件的，需要配置静态web服务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.Status(<span class="string">&quot;静态文件路由&quot;</span>, <span class="string">&quot;静态文件地址&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3、请求参数"><a href="#3、请求参数" class="headerlink" title="3、请求参数"></a>3、请求参数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">  UserName <span class="type">string</span> <span class="string">`json:&quot;username&quot; form:&quot;username&quot; xml:&quot;username&quot;`</span></span><br><span class="line">  Age <span class="type">string</span> <span class="string">`json:&quot;username&quot; form:&quot;username&quot; xml:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（1）get"><a href="#（1）get" class="headerlink" title="（1）get"></a>（1）get</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://xxx/getInfo?username=admin&amp;age=18</span></span><br><span class="line">r.GET(<span class="string">&quot;/getInfo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  username := c.Query(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">  age := c.Query(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">  page := c.DefaultQuery(<span class="string">&quot;page&quot;</span>, <span class="string">&quot;1&quot;</span>) <span class="comment">// 默认传参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数绑定到结构体</span></span><br><span class="line">r.GET(<span class="string">&quot;/getInfo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  user := &amp;UserInfo&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> err := c.ShouldBind(&amp;user); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    c.JSON(code, user)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c.JSON(code, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;err&quot;</span>: err.Error(),</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）post"><a href="#（2）post" class="headerlink" title="（2）post"></a>（2）post</h3><h4 id="获取表单数据"><a href="#获取表单数据" class="headerlink" title="获取表单数据"></a>获取表单数据</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/getInfo&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">  年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.Post(<span class="string">&quot;/getInfo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  username := c.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">  age := c.PostForm(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">  page := c.DefaultPostForm(<span class="string">&quot;page&quot;</span>, <span class="string">&quot;1&quot;</span>) <span class="comment">// 默认传参，没有传这个参数就会使用默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数绑定到结构体</span></span><br><span class="line">r.Post(<span class="string">&quot;/getInfo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  user := &amp;UserInfo&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> err := c.Bind(&amp;user); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    c.JSON(code, user)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c.JSON(code, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;err&quot;</span>: err.Error(),</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取XML数据"><a href="#获取XML数据" class="headerlink" title="获取XML数据"></a>获取XML数据</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?XML version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">username</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">age</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>&gt;</span>18<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.Post(<span class="string">&quot;/xml&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  xmlSlice, err := c.GetRawData()</span><br><span class="line">  user := &amp;UserInfo&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err1 := xml.Unmarshal(xmlSlice, &amp;user); <span class="type">error</span> == <span class="literal">nil</span> &#123;</span><br><span class="line">      c.JSON(code, user)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      c.JSON(code, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;err&quot;</span>: err1.Error(),</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c.JSON(code, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;err&quot;</span>: err.Error(),</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）动态路由"><a href="#（3）动态路由" class="headerlink" title="（3）动态路由"></a>（3）动态路由</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/user/:uid&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  uid := c.Param(<span class="string">&quot;uid&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、路由组"><a href="#4、路由组" class="headerlink" title="4、路由组"></a>4、路由组</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  router := gin.Default()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 简单的路由组: v1</span></span><br><span class="line">  v1 := router.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    v1.POST(<span class="string">&quot;/login&quot;</span>, loginEndpoint)</span><br><span class="line">    v1.POST(<span class="string">&quot;/submit&quot;</span>, submitEndpoint)</span><br><span class="line">    v1.POST(<span class="string">&quot;/read&quot;</span>, readEndpoint)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 简单的路由组: v2</span></span><br><span class="line">  v2 := router.Group(<span class="string">&quot;/v2&quot;</span>, 中间件<span class="number">1</span>, 中间件<span class="number">2</span> ...)</span><br><span class="line">  <span class="comment">// v2.use(中间件1, 中间件2 ...)</span></span><br><span class="line">  &#123;</span><br><span class="line">    v2.POST(<span class="string">&quot;/login&quot;</span>, loginEndpoint)</span><br><span class="line">    v2.POST(<span class="string">&quot;/submit&quot;</span>, submitEndpoint)</span><br><span class="line">    v2.POST(<span class="string">&quot;/read&quot;</span>, readEndpoint)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、中间件"><a href="#5、中间件" class="headerlink" title="5、中间件"></a>5、中间件</h2><p>中间件：匹配路由前和匹配路由完成后执行的一系列操作。</p>
<h3 id="（1）局部中间件"><a href="#（1）局部中间件" class="headerlink" title="（1）局部中间件"></a>（1）局部中间件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在最后一个函数前的所有函数都代表中间件。</span></span><br><span class="line">r.GET(<span class="string">&quot;/xml&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;... <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;&#125;</span><br><span class="line">r.POST(<span class="string">&quot;/xml&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;... <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）Next"><a href="#（2）Next" class="headerlink" title="（2）Next"></a>（2）Next</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/xml&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 中间件开始执行的操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 执行当前中间件的下一个函数</span></span><br><span class="line">  c.Next()</span><br><span class="line">  <span class="comment">// 中间件执行完成后续操作</span></span><br><span class="line">  ...</span><br><span class="line">&#125;... <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个中间件</span></span><br><span class="line">r.GET(<span class="string">&quot;/xml&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;这是第一个中间件开始&quot;</span>)</span><br><span class="line">  c.Next()</span><br><span class="line">  fmt.Println(<span class="string">&quot;这是第一个中间件结束&quot;</span>)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;这是第二个中间件开始&quot;</span>)</span><br><span class="line">  c.Next()</span><br><span class="line">  fmt.Println(<span class="string">&quot;这是第二个中间件结束&quot;</span>)</span><br><span class="line">&#125;... <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;路由操作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是第一个中间件开始</span></span><br><span class="line"><span class="comment">这是第二个中间件开始</span></span><br><span class="line"><span class="comment">路由操作</span></span><br><span class="line"><span class="comment">这是第二个中间件结束</span></span><br><span class="line"><span class="comment">这是第一个中间件结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）全局中间件"><a href="#（3）全局中间件" class="headerlink" title="（3）全局中间件"></a>（3）全局中间件</h3><p>所有路由函数都会执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.use(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="（4）数据共享"><a href="#（4）数据共享" class="headerlink" title="（4）数据共享"></a>（4）数据共享</h3><p>中间件与中间件、控制器之间的数据传递。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c.Set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;go&quot;</span>)</span><br><span class="line">username, err := c.Get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">v, ok := username(.<span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（5）Logger和Recovery"><a href="#（5）Logger和Recovery" class="headerlink" title="（5）Logger和Recovery"></a>（5）Logger和Recovery</h3><p>使用<code>gin.Default</code>创建路由默认带有<code>Logger</code>和<code>Recovery</code>中间件：</p>
<ul>
<li><code>Logger</code>：将日志写入<code>gin.DefaultWriter</code>。</li>
<li><code>Recovery</code>：<code>recover</code>任何<code>panic</code>，如果有<code>panic</code>的话，就会写入<code>500</code>响应码。</li>
</ul>
<p>如果不想使用这两个中间件，可以使用<code>gin.New</code>创建路由。</p>
<h3 id="（6）中间件使用goroutine"><a href="#（6）中间件使用goroutine" class="headerlink" title="（6）中间件使用goroutine"></a>（6）中间件使用goroutine</h3><p>当在中间件或<code>handler</code>中启动新的<code>Goroutine</code>时，<strong>不能</strong>使用原始的上下文，必须使用只读副本。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;/long_async&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 创建在 goroutine 中使用的副本</span></span><br><span class="line">		cCp := c.Copy()</span><br><span class="line">    <span class="comment">// 不需要使用wg.Done()结束任务，因为主程序一直开启。</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 用 time.Sleep() 模拟一个长任务。</span></span><br><span class="line">			time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 请注意您使用的是复制的上下文 &quot;cCp&quot;，这一点很重要</span></span><br><span class="line">			log.Println(<span class="string">&quot;Done! in path &quot;</span> + cCp.Request.URL.Path)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;/long_sync&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 用 time.Sleep() 模拟一个长任务。</span></span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 因为没有使用 goroutine，不需要拷贝上下文</span></span><br><span class="line">		log.Println(<span class="string">&quot;Done! in path &quot;</span> + c.Request.URL.Path)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（7）重定向"><a href="#（7）重定向" class="headerlink" title="（7）重定向"></a>（7）重定向</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Redirect</span></span><br><span class="line">r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  c.Redirect(code, <span class="string">&quot;重定向地址&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// HandleContext</span></span><br><span class="line">r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.Request.URL.Path = <span class="string">&quot;重定向地址&quot;</span></span><br><span class="line">    r.HandleContext(c)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="6、文件上传"><a href="#6、文件上传" class="headerlink" title="6、文件上传"></a>6、文件上传</h2><h3 id="（1）单文件上传"><a href="#（1）单文件上传" class="headerlink" title="（1）单文件上传"></a>（1）单文件上传</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  r := gin.Default()</span><br><span class="line">  <span class="comment">//限制上传最大尺寸</span></span><br><span class="line">  r.MaxMultipartMemory = <span class="number">8</span> &lt;&lt; <span class="number">20</span></span><br><span class="line">  r.POST(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// file：input文件输入框的name</span></span><br><span class="line">    file, err := c.FormFile(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      c.String(<span class="number">500</span>, <span class="string">&quot;上传图片出错&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存上传的文件至指定文件地址</span></span><br><span class="line">    dst := <span class="string">&quot;./&quot;</span> + file.Filename</span><br><span class="line">    c.SaveUploadedFile(file, dst)</span><br><span class="line">    c.String(http.StatusOK, file.Filename)</span><br><span class="line">  &#125;)</span><br><span class="line">  r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）多文件上传"><a href="#（2）多文件上传" class="headerlink" title="（2）多文件上传"></a>（2）多文件上传</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	<span class="comment">// 为 multipart forms 设置较低的内存限制 (默认是 32 MiB)</span></span><br><span class="line">	r.MaxMultipartMemory = <span class="number">8</span> &lt;&lt; <span class="number">20</span>  <span class="comment">// 8 MiB</span></span><br><span class="line">	r.POST(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// Multipart form</span></span><br><span class="line">		form, _ := c.MultipartForm()</span><br><span class="line">    <span class="comment">// upload[]：input文件输入框的name</span></span><br><span class="line">		files := form.File[<span class="string">&quot;upload[]&quot;</span>]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">			log.Println(file.Filename)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 上传文件至指定目录</span></span><br><span class="line">			dst := <span class="string">&quot;./&quot;</span> + file.Filename</span><br><span class="line">			c.SaveUploadedFile(file, dst)</span><br><span class="line">		&#125;</span><br><span class="line">		c.String(http.StatusOK, fmt.Sprintf(<span class="string">&quot;%d files uploaded!&quot;</span>, <span class="built_in">len</span>(files)))</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、Cookie"><a href="#7、Cookie" class="headerlink" title="7、Cookie"></a>7、Cookie</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1.创建路由</span></span><br><span class="line">  <span class="comment">// 默认使用了2个中间件Logger(), Recovery()</span></span><br><span class="line">  r := gin.Default()</span><br><span class="line">  <span class="comment">// 服务端要给客户端cookie</span></span><br><span class="line">  r.GET(<span class="string">&quot;cookie&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取客户端是否携带cookie</span></span><br><span class="line">    cookie, err := c.Cookie(<span class="string">&quot;key_cookie&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      cookie = <span class="string">&quot;NotSet&quot;</span></span><br><span class="line">      <span class="comment">// 给客户端设置cookie：</span></span><br><span class="line">      <span class="comment">// name：cookie名称</span></span><br><span class="line">      <span class="comment">// value string：cookie的值</span></span><br><span class="line">      <span class="comment">// maxAge int：过期时间，单位为秒，-1表示删除cookie</span></span><br><span class="line">      <span class="comment">// path：cookie所在目录</span></span><br><span class="line">      <span class="comment">// domain string：域名，&quot;.wongzeonwai&quot;前面加.表示二级域名也设置cookie</span></span><br><span class="line">      <span class="comment">// secure bool：是否只能通过https访问</span></span><br><span class="line">      <span class="comment">// httpOnly bool：是否允许别人通过客户端获取自己的cookie</span></span><br><span class="line">      c.SetCookie(<span class="string">&quot;key_cookie&quot;</span>, <span class="string">&quot;value_cookie&quot;</span>, <span class="number">60</span>, <span class="string">&quot;/&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;localhost&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;cookie的值是： %s\n&quot;</span>, cookie)</span><br><span class="line">  &#125;)</span><br><span class="line">  r.Run(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、Session"><a href="#8、Session" class="headerlink" title="8、Session"></a>8、Session</h2><p>gorilla&#x2F;sessions为自定义session后端提供cookie和文件系统session以及基础结构。</p>
<p>主要功能是：</p>
<ul>
<li>简单的API：将其用作设置签名（以及可选的加密）cookie的简便方法。</li>
<li>内置的后端可将session存储在cookie或文件系统中。</li>
<li>Flash消息：一直持续读取的session值。</li>
<li>切换session持久性（又称“记住我”）和设置其他属性的便捷方法。</li>
<li>旋转身份验证和加密密钥的机制。</li>
<li>每个请求有多个session，即使使用不同的后端也是如此。</li>
<li>自定义session后端的接口和基础结构：可以使用通用API检索并批量保存来自不同商店的session。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gorilla/sessions&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个cookie存储对象</span></span><br><span class="line"><span class="comment">// something-very-secret应该是一个你自己的密匙，只要不被别人知道就行</span></span><br><span class="line"><span class="keyword">var</span> store = sessions.NewCookieStore([]<span class="type">byte</span>(<span class="string">&quot;something-very-secret&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/save&quot;</span>, SaveSession)</span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/get&quot;</span>, GetSession)</span><br><span class="line">  err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;HTTP server failed,err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveSession</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Get a session. We&#x27;re ignoring the error resulted from decoding an</span></span><br><span class="line">  <span class="comment">// existing session: Get() always returns a session, even if empty.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//　获取一个session对象，session-name是session的名字</span></span><br><span class="line">  session, err := store.Get(r, <span class="string">&quot;session-name&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在session中存储值</span></span><br><span class="line">  session.Values[<span class="string">&quot;foo&quot;</span>] = <span class="string">&quot;bar&quot;</span></span><br><span class="line">  session.Values[<span class="number">42</span>] = <span class="number">43</span></span><br><span class="line">  <span class="comment">// 保存更改</span></span><br><span class="line">  session.Save(r, w)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSession</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  session, err := store.Get(r, <span class="string">&quot;session-name&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  foo := session.Values[<span class="string">&quot;foo&quot;</span>]</span><br><span class="line">  fmt.Println(foo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、go-ini"><a href="#9、go-ini" class="headerlink" title="9、go-ini"></a>9、go-ini</h2><p>使用<code>go-ini</code>操作<code>ini</code>文件。</p>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解GMP模型</title>
    <url>/2025/06/09/Golang%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="一、Go-V1-3-标记清除法"><a href="#一、Go-V1-3-标记清除法" class="headerlink" title="一、Go V1.3 标记清除法"></a>一、Go V1.3 标记清除法</h1><p>Go 在 V1.3 之前使用的是标记清除法：</p>
<p><img src="/2025/06/09/Golang%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/marksweep.png" alt="标记清除法"></p>
<ol>
<li>暂停程序业务逻辑，分类出可达和不可达的对象，然后做上标记。</li>
<li>开始标记，程序找出它所有可达的对象，并做上标记。</li>
<li>标记完了之后，然后开始清除未标记的对象。</li>
<li>停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</li>
</ol>
<p>标记清除法有非常严重的问题：</p>
<ul>
<li>STW（stop the world），让程序暂停，程序出现卡顿。</li>
<li>标记需要扫描整个 heap。</li>
<li>清除数据会产生 heap 碎片。</li>
</ul>
<p>STW 整个过程经过“暂停程序 -&gt; 标记 -&gt; 清除 -&gt; 重新启动程序”，Go 在 GC 回收中优化了 STW 过程，将清除放到 STW 之外，减少了程序暂停时间，但是仍会造成程序卡顿。</p>
<h1 id="二、Go-V1-5-三色标记法"><a href="#二、Go-V1-5-三色标记法" class="headerlink" title="二、Go V1.5 三色标记法"></a>二、Go V1.5 三色标记法</h1><p>为了解决 STW 带来的问题，Go 在 V1.5 之后引入了三色标记法。</p>
<ol>
<li>每次创建新的对象，都会将对象标记为**<span style="color: #C0C4CC;">白色</span>**。</li>
<li>GC 开始时，从根节点开始遍历，将根节点对象标记为**<span style="color: gray;">灰色</span>**。</li>
<li>遍历**<span style="color: gray;">灰色</span><strong>节点，将</strong><span style="color: gray;">灰色</span><strong>节点引用的对象标记为</strong><span style="color: gray;">灰色</span><strong>，原来的</strong><span style="color: gray;">灰色</span><strong>节点标记为</strong>黑色**。</li>
<li>重复步骤 3，直到没有**<span style="color: gray;">灰色</span>**节点。</li>
<li>回收所有**<span style="color: #C0C4CC;">白色</span>**节点。</li>
</ol>
<p>根对象：</p>
<ul>
<li>栈上的对象：Goroutine 栈上的变量（局部变量、参数等）。</li>
<li>全局变量：程序中的全局变量（存储在静态数据区）。</li>
<li>寄存器中的对象：当前执行代码可能通过寄存器引用对象。</li>
<li>运行时数据结构：例如 <code>runtime</code> 包中的特殊对象。</li>
</ul>
<h2 id="标记出错"><a href="#标记出错" class="headerlink" title="标记出错"></a>标记出错</h2><p>但是由于 V1.5 的垃圾回收机制是跟程序并发执行的，所以在一些特定条件下，三色标记法可能会出现错误。</p>
<h3 id="（1）对象漏标"><a href="#（1）对象漏标" class="headerlink" title="（1）对象漏标"></a>（1）对象漏标</h3><ul>
<li>对象 A 在 GC 开始时被标记为<strong>黑色</strong>，对象 B 是与另一个<strong>黑色</strong>对象的引用对象，因此会被标记为**<span style="color: gray;">灰色</span>**，对象 C 是对象 B 的引用对象。</li>
<li>在 GC 进行过程中，对象 B 删除了对对象 C 的引用，而对象 A 建立与对象 C 的引用。</li>
<li>对象 C 因为没有被标记成**<span style="color: gray;">灰色</span>**被错误扫描从而在 GC 结束后被回收。</li>
</ul>
<h3 id="（2）对象多标"><a href="#（2）对象多标" class="headerlink" title="（2）对象多标"></a>（2）对象多标</h3><ul>
<li>对象 A 在 GC 开始时被标记为<strong>黑色</strong>，对象 B 是对象 A 的引用，因此会被标记为**<span style="color: gray;">灰色</span>**。</li>
<li>在 GC 进行过程中，对象 A 删除了对对象 B 的引用。</li>
<li>因为对象 B 是**<span style="color: gray;">灰色</span><strong>，因此在下一轮扫描中仍然会被标记为</strong>黑色**，因此对象 B 没有被正确回收。这种对象成为“浮动垃圾”，但是由于对象 B 在下一次 GC 还是会被回收，我们可以容忍这种错误。</li>
</ul>
<p>在两种条件同时存在的情况下，对象漏标就会发生：</p>
<ol>
<li>一个白色对象被<strong>黑色</strong>对象引用。</li>
<li>**<span style="color: gray;">灰色</span><strong>对象与它之间的可达关系的</strong><span style="color: #C0C4CC;">白色</span>**对象遭到破坏。</li>
</ol>
<h2 id="强弱三色不变式"><a href="#强弱三色不变式" class="headerlink" title="强弱三色不变式"></a>强弱三色不变式</h2><p>为了解决这种问题，Go 提出了<strong>“强弱三色不变式”</strong>：</p>
<ul>
<li>强三色不变式：**<span style="color: #C0C4CC;">白色</span><strong>对象不能被</strong>黑色**对象直接引用（直接破坏条件 1）。</li>
<li>弱三色不变式：**<span style="color: #C0C4CC;">白色</span><strong>对象可以被</strong>黑色<strong>对象引用，但在白色对象的引用链上必须存在</strong><span style="color: gray;">灰色</span>**对象（破坏条件 2）。</li>
</ul>
<h2 id="屏障机制"><a href="#屏障机制" class="headerlink" title="屏障机制"></a>屏障机制</h2><p>遵循这两种方法，GC 算法引入了屏障机制。即在执行某种特定行动前，必须完成屏障的条件：</p>
<h3 id="（1）插入写屏障"><a href="#（1）插入写屏障" class="headerlink" title="（1）插入写屏障"></a>（1）插入写屏障</h3><p>当一个<strong>黑色</strong>对象指向一个**<span style="color: #C0C4CC;">白色</span><strong>对象前，会先触发屏障将</strong><span style="color: #C0C4CC;">白色</span><strong>对象置为</strong><span style="color: gray;">灰色</span>**，再建立引用。</p>
<h3 id="（2）删除写屏障"><a href="#（2）删除写屏障" class="headerlink" title="（2）删除写屏障"></a>（2）删除写屏障</h3><p>当一个**<span style="color: #C0C4CC;">白色</span><strong>对象即将被上游删除引用前，会触发屏障将其置为</strong><span style="color: gray;">灰色</span>**，之后再删除上游指向其的引用。</p>
<p>屏障机制依旧存在缺陷，不能对栈对象生效，因此在 GC 最后依旧需要 STW 最后进行一次栈的扫描。</p>
<h1 id="三、Go-V1-8混合写屏障"><a href="#三、Go-V1-8混合写屏障" class="headerlink" title="三、Go V1.8混合写屏障"></a>三、Go V1.8混合写屏障</h1><p>为了消除最后一次 STW 的成本，Go V1.8 开始使用混合写屏障 + 三色标记法模式：</p>
<ol>
<li>在 GC 开始前，将栈上所有可达对象置<strong>黑</strong>。</li>
<li>GC 期间，栈上新创建的对象都会被置<strong>黑</strong>。</li>
<li>堆对象正常使用插入、删除写屏障。</li>
</ol>
<p>在 V1.8 中，GC 只在开始和结束使用 STW，告知程序启用和关闭屏障。</p>
<h1 id="四、GC触发时机"><a href="#四、GC触发时机" class="headerlink" title="四、GC触发时机"></a>四、GC触发时机</h1><ul>
<li>自动触发：当堆当中存活的对象大小达到上一次 GC 结束后对内存的比例时触发，默认由环境变量 <code>GOGC</code> 控制（默认值为 <em><strong>100</strong></em>，即当堆内存增长 <em><strong>100%</strong></em> 时触发。</li>
<li>手动触发：使用 <code>runtime.GC()</code> 强制触发一次 GC，通常用于性能测试或者内存泄漏测试。</li>
<li>系统监控强制触发：系统一般会在距离上一次 GC 两分钟后强制触发一次 GC。</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>GO学习笔记</title>
    <url>/2024/08/07/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、Go-基础"><a href="#一、Go-基础" class="headerlink" title="一、Go 基础"></a>一、Go 基础</h1><h2 id="1、Go-的-25-个关键字"><a href="#1、Go-的-25-个关键字" class="headerlink" title="1、Go 的 25 个关键字"></a>1、Go 的 25 个关键字</h2><table>
     <tr>
        <td>break</td>
        <td>default</td>
        <td>func</td>
        <td>interface</td>
        <td>select</td>
    </tr>
     <tr>
        <td>case</td>
        <td>defer</td>
        <td>go</td>
        <td>map</td>
        <td>struct</td>
    </tr>
     <tr>
        <td>chan</td>
        <td>else</td>
        <td>goto</td>
        <td>package</td>
        <td>switch</td>
    </tr>
     <tr>
        <td>const</td>
        <td>fallthrough</td>
        <td>if</td>
        <td>range</td>
        <td>type</td>
    </tr>
     <tr>
        <td>continue</td>
        <td>for</td>
        <td>import</td>
        <td>return</td>
        <td>var</td>
    </tr>
</table>

<h2 id="2、Go-的-36-个预定义标识符："><a href="#2、Go-的-36-个预定义标识符：" class="headerlink" title="2、Go 的 36 个预定义标识符："></a>2、Go 的 36 个预定义标识符：</h2><table>
    <tr>
        <td>append</td>
        <td>bool</td>
        <td>byte</td>
        <td>cap</td>
        <td>close</td>
        <td>complex</td>
        <td>complex64</td>
        <td>complex128</td>
        <td>uint16</td>
    </tr>
    <tr>
        <td>copy</td>
        <td>false</td>
        <td>float32</td>
        <td>float64</td>
        <td>imag</td>
        <td>int</td>
        <td>int8</td>
        <td>int16</td>
        <td>uint32</td>
    </tr>
    <tr>
        <td>int32</td>
        <td>int64</td>
        <td>iota</td>
        <td>len</td>
        <td>make</td>
        <td>new</td>
        <td>nil</td>
        <td>panic</td>
        <td>uint64</td>
    </tr>
    <tr>
        <td>print</td>
        <td>println</td>
        <td>real</td>
        <td>recover</td>
        <td>string</td>
        <td>true</td>
        <td>uint</td>
        <td>uint8</td>
        <td>uintptr</td>
    </tr>
</table>



<h2 id="3、Go-的基本数据类型"><a href="#3、Go-的基本数据类型" class="headerlink" title="3、Go 的基本数据类型"></a>3、Go 的基本数据类型</h2><h3 id="（1）布尔类型"><a href="#（1）布尔类型" class="headerlink" title="（1）布尔类型"></a>（1）布尔类型</h3><p>使用 <strong>boolean</strong> 声明的类型，只有 <strong>true（真）和 false（假）</strong>两种值。默认值为 <code>false</code>。</p>
<h3 id="（2）数字类型"><a href="#（2）数字类型" class="headerlink" title="（2）数字类型"></a>（2）数字类型</h3><p>包括整型和浮点型以及其他数据类型。</p>
<h4 id="整型（默认值为-0）："><a href="#整型（默认值为-0）：" class="headerlink" title="整型（默认值为 0）："></a>整型（默认值为 0）：</h4><table>
<thead>
<tr>
<th>类型</th>
<th>长度（字节）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>4</td>
<td>有符号 32 位整型</td>
</tr>
<tr>
<td>int8</td>
<td>1</td>
<td>有符号 8 位整型（-128 ~ 128）</td>
</tr>
<tr>
<td>int16</td>
<td>2</td>
<td>有符号 16 位整型（-32768 ~ 32767）</td>
</tr>
<tr>
<td>int32</td>
<td>4</td>
<td>有符号 32 位整型（-2147483648 ~ 2147483647）</td>
</tr>
<tr>
<td>int64</td>
<td>8</td>
<td>有符号 64 位整型（-9223372036854775808 ~ 9223372036854775807）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度（字节）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>uint</td>
<td>4</td>
<td>无符号 32 位整型</td>
</tr>
<tr>
<td>uint8</td>
<td>1</td>
<td>无符号 8 位整型（0 ~ 255）</td>
</tr>
<tr>
<td>uint16</td>
<td>2</td>
<td>无符号 16 位整型（0 ~ 65535）</td>
</tr>
<tr>
<td>uint32</td>
<td>4</td>
<td>无符号 32 位整型（0 ~ 4294967295）</td>
</tr>
<tr>
<td>uint64</td>
<td>8</td>
<td>无符号 64 位整型（0 ~ 18446744073709551615）</td>
</tr>
</tbody></table>
<h4 id="浮点型："><a href="#浮点型：" class="headerlink" title="浮点型："></a>浮点型：</h4><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>float32</td>
<td>32 位浮点型数，默认值为 0</td>
</tr>
<tr>
<td>float64</td>
<td>64 位浮点型数，默认值为 0</td>
</tr>
<tr>
<td>complex64</td>
<td>32 位实数和虚数</td>
</tr>
<tr>
<td>complex128</td>
<td>64 位实数和虚数</td>
</tr>
</tbody></table>
<h4 id="其他数字类型："><a href="#其他数字类型：" class="headerlink" title="其他数字类型："></a>其他数字类型：</h4><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>uint8，默认值为 0</td>
</tr>
<tr>
<td>rune</td>
<td>Unicode Code Point, int32，默认值为 0</td>
</tr>
<tr>
<td>uintptr</td>
<td>以存储指针的 uint32 或 uint64 整数</td>
</tr>
</tbody></table>
<h3 id="（3）字符串类型："><a href="#（3）字符串类型：" class="headerlink" title="（3）字符串类型："></a>（3）字符串类型：</h3><p>使用 string 声明的 UTF-8 字符串。默认值为<code>&quot;&quot;</code>。</p>
<h4 id="字符串转义符："><a href="#字符串转义符：" class="headerlink" title="字符串转义符："></a>字符串转义符：</h4><table>
<thead>
<tr>
<th>转义</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\r</td>
<td>回车符（返回行首）</td>
</tr>
<tr>
<td>\n</td>
<td>换行符（直接跳到下一行的同列位置）</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>&#39;</td>
<td>单引号</td>
</tr>
<tr>
<td>&quot;</td>
<td>双引号</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
</tr>
</tbody></table>
<p>Go 语言中要定义一个多行字符串时，就必须使用反引号字符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">    第二行</span></span><br><span class="line"><span class="string">    第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一行</span></span><br><span class="line"><span class="comment">                第二行</span></span><br><span class="line"><span class="comment">                第三\&#x27;行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>但是在多行字符串中转义字符无法生效。</p>
<h4 id="字符串常用方法："><a href="#字符串常用方法：" class="headerlink" title="字符串常用方法："></a>字符串常用方法：</h4><table>
<thead>
<tr>
<th>方法</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>len(str)</td>
<td>求长度</td>
</tr>
<tr>
<td>+或fmt.Sprintf</td>
<td>拼接字符串</td>
</tr>
<tr>
<td>strings.Split</td>
<td>分割字符串为切片</td>
</tr>
<tr>
<td>strings.Contains</td>
<td>判断是否包含</td>
</tr>
<tr>
<td>strings.HasPrefix,strings.HasSuffix</td>
<td>前缀&#x2F;后缀判断</td>
</tr>
<tr>
<td>strings.Index(),strings.LastIndex()</td>
<td>子串出现的位置</td>
</tr>
<tr>
<td>strings.Join(a[]string, sep string)</td>
<td>切片连接成字符串</td>
</tr>
</tbody></table>
<h3 id="（4）其他类型："><a href="#（4）其他类型：" class="headerlink" title="（4）其他类型："></a>（4）其他类型：</h3><ul>
<li>指针类型（Pointer）：默认值为 <code>nil</code></li>
<li>数组类型（array）</li>
<li>结构化类型（struct）</li>
<li>Channel 类型（channel）：默认值为 <code>nil</code></li>
<li>函数类型（function）：默认值为 <code>nil</code></li>
<li>切片类型（slice）：默认值为 <code>nil</code></li>
<li>接口类型（interface）：默认值为 <code>nil</code></li>
<li>Map 类型（map）：默认值为 <code>nil</code></li>
</ul>
<h2 id="4、运算符"><a href="#4、运算符" class="headerlink" title="4、运算符"></a>4、运算符</h2><h3 id="（1）算术运算符"><a href="#（1）算术运算符" class="headerlink" title="（1）算术运算符"></a>（1）算术运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>相加</td>
</tr>
<tr>
<td>-</td>
<td>相减</td>
</tr>
<tr>
<td>*</td>
<td>相乘</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>相除</td>
</tr>
<tr>
<td>%</td>
<td>求余</td>
</tr>
</tbody></table>
<h3 id="（2）关系运算符"><a href="#（2）关系运算符" class="headerlink" title="（2）关系运算符"></a>（2）关系运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>检查两个值是否相等，如果相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td>&gt;</td>
<td>检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td>&lt;</td>
<td>检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
</tbody></table>
<h3 id="（3）逻辑运算符"><a href="#（3）逻辑运算符" class="headerlink" title="（3）逻辑运算符"></a>（3）逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td>ll</td>
<td>逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td>!</td>
<td>逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td>
</tr>
</tbody></table>
<h3 id="（4）位运算符"><a href="#（4）位运算符" class="headerlink" title="（4）位运算符"></a>（4）位运算符</h3><p>位运算符对整数在内存中的二进制位进行操作。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>参与运算的两数各对应的二进位相与。（两位均为 1 才为 1 ）</td>
</tr>
<tr>
<td>l</td>
<td>参与运算的两数各对应的二进位相或。（两位有一个为 1 就为 1 ）</td>
</tr>
<tr>
<td>^</td>
<td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为 1。（两位不一样则为 1）</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移 n 位就是乘以 2 的 n 次方。“a&lt;&lt;b”是把 a 的各二进位全部左移 b 位，高位丢弃，低位补 0。</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移 n 位就是除以 2 的 n 次方。“a&gt;&gt;b”是把 a 的各二进位全部右移 b 位。</td>
</tr>
</tbody></table>
<h3 id="（5）赋值运算符"><a href="#（5）赋值运算符" class="headerlink" title="（5）赋值运算符"></a>（5）赋值运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>简单的赋值运算符，将一个表达式的值赋给一个左值</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>相加后再赋值</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>相减后再赋值</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>相乘后再赋值</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>相除后再赋值</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>求余后再赋值</td>
</tr>
<tr>
<td>&lt;&lt;&#x3D;</td>
<td>左移后赋值</td>
</tr>
<tr>
<td>&gt;&gt;&#x3D;</td>
<td>右移后赋值</td>
</tr>
<tr>
<td>&amp;&#x3D;</td>
<td>按位与后赋值</td>
</tr>
<tr>
<td>l&#x3D;</td>
<td>按位或后赋值</td>
</tr>
<tr>
<td>^&#x3D;</td>
<td>按位异或后赋值</td>
</tr>
</tbody></table>
<h2 id="5、常用标准库"><a href="#5、常用标准库" class="headerlink" title="5、常用标准库"></a>5、常用标准库</h2><h3 id="（1）fmt"><a href="#（1）fmt" class="headerlink" title="（1）fmt"></a>（1）fmt</h3><h4 id="Print、Printf、Println"><a href="#Print、Printf、Println" class="headerlink" title="Print、Printf、Println"></a>Print、Printf、Println</h4><p>Print系列函数会将内容输出到系统的标准输出，区别在于 Print 函数直接输出内容，Printf 函数支持格式化输出字符串，Println 函数会在输出内容的结尾添加一个换行符。</p>
<h5 id="通用占位符"><a href="#通用占位符" class="headerlink" title="通用占位符"></a>通用占位符</h5><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%v</td>
<td>值的默认格式表示</td>
</tr>
<tr>
<td>%+v</td>
<td>类似 %v，但输出结构体时会添加字段名</td>
</tr>
<tr>
<td>%#v</td>
<td>值的 Go 语法表示</td>
</tr>
<tr>
<td>%T</td>
<td>打印值的类型</td>
</tr>
<tr>
<td>%%</td>
<td>百分号</td>
</tr>
</tbody></table>
<h5 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h5><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%t</td>
<td>true 或 false</td>
</tr>
</tbody></table>
<h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%b</td>
<td>表示为二进制</td>
</tr>
<tr>
<td>%c</td>
<td>该值对应的 unicode 码值</td>
</tr>
<tr>
<td>%d</td>
<td>表示为十进制</td>
</tr>
<tr>
<td>%o</td>
<td>表示为八进制</td>
</tr>
<tr>
<td>%x</td>
<td>表示为十六进制，使用 a-f</td>
</tr>
<tr>
<td>%X</td>
<td>表示为十六进制，使用 A-F</td>
</tr>
<tr>
<td>%U</td>
<td>表示为 Unicode 格式：U+1234，等价于 ”U+%04X”</td>
</tr>
<tr>
<td>%q</td>
<td>该值对应的单引号括起来的 go 语法字符字面值，必要时会采用安全的转义表示</td>
</tr>
</tbody></table>
<h5 id="浮点数与复数"><a href="#浮点数与复数" class="headerlink" title="浮点数与复数"></a>浮点数与复数</h5><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%b</td>
<td>无小数部分、二进制指数的科学计数法，如 -123456p-78</td>
</tr>
<tr>
<td>%e</td>
<td>科学计数法，如 -1234.456e+78</td>
</tr>
<tr>
<td>%E</td>
<td>科学计数法，如 -1234.456E+78</td>
</tr>
<tr>
<td>%f</td>
<td>有小数部分但无指数部分，如 123.456</td>
</tr>
<tr>
<td>%F</td>
<td>等价于 %f</td>
</tr>
<tr>
<td>%g</td>
<td>根据实际情况采用 %e 或 %f 格式（以获得更简洁、准确的输出）</td>
</tr>
<tr>
<td>%G</td>
<td>根据实际情况采用 %E 或 %F 格式（以获得更简洁、准确的输出）</td>
</tr>
</tbody></table>
<h5 id="字符串和-byte"><a href="#字符串和-byte" class="headerlink" title="字符串和[]byte"></a>字符串和[]byte</h5><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>直接输出字符串或者 []byte</td>
</tr>
<tr>
<td>%q</td>
<td>该值对应的双引号括起来的 go 语法字符串字面值，必要时会采用安全的转义表示</td>
</tr>
<tr>
<td>%x</td>
<td>每个字节用两字符十六进制数表示（使用 a-f）</td>
</tr>
<tr>
<td>%X</td>
<td>每个字节用两字符十六进制数表示（使用 A-F）</td>
</tr>
</tbody></table>
<h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%p</td>
<td>表示为十六进制，并加上前导的 0x</td>
</tr>
</tbody></table>
<h5 id="宽度标识符"><a href="#宽度标识符" class="headerlink" title="宽度标识符"></a>宽度标识符</h5><p>宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为 0。举例如下</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%f</td>
<td>默认宽度，默认精度</td>
</tr>
<tr>
<td>%9f</td>
<td>宽度 9，默认精度</td>
</tr>
<tr>
<td>%.2f</td>
<td>默认宽度，精度 2</td>
</tr>
<tr>
<td>%9.2f</td>
<td>宽度 9，精度 2</td>
</tr>
<tr>
<td>%9.f</td>
<td>宽度 9，精度 0</td>
</tr>
</tbody></table>
<h3 id="（2）time"><a href="#（2）time" class="headerlink" title="（2）time"></a>（2）time</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  now := time.Now() <span class="comment">//获取当前时间</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;current time:%v\n&quot;</span>, now)</span><br><span class="line"></span><br><span class="line">  year := now.Year()     <span class="comment">//年</span></span><br><span class="line">  month := now.Month()   <span class="comment">//月</span></span><br><span class="line">  day := now.Day()       <span class="comment">//日</span></span><br><span class="line">  hour := now.Hour()     <span class="comment">//小时</span></span><br><span class="line">  minute := now.Minute() <span class="comment">//分钟</span></span><br><span class="line">  second := now.Second() <span class="comment">//秒</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year, month, day, hour, minute, second)</span><br><span class="line"></span><br><span class="line">  timestamp1 := now.Unix()     <span class="comment">//时间戳</span></span><br><span class="line">  timestamp2 := now.UnixNano() <span class="comment">//纳秒时间戳</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;current timestamp1:%v\n&quot;</span>, timestamp1)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;current timestamp2:%v\n&quot;</span>, timestamp2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间戳转换日期"><a href="#时间戳转换日期" class="headerlink" title="时间戳转换日期"></a>时间戳转换日期</h4><p>使用 Unix 函数将时间戳转换为时间格式，第一个参数为毫秒时间戳，第二个参数为纳秒时间戳。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timestampDemo2</span><span class="params">(timestamp <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    timeObj := time.Unix(timestamp, <span class="number">0</span>) <span class="comment">//将时间戳转为时间格式</span></span><br><span class="line">    fmt.Println(timeObj)</span><br><span class="line">    year := timeObj.Year()     <span class="comment">//年</span></span><br><span class="line">    month := timeObj.Month()   <span class="comment">//月</span></span><br><span class="line">    day := timeObj.Day()       <span class="comment">//日</span></span><br><span class="line">    hour := timeObj.Hour()     <span class="comment">//小时</span></span><br><span class="line">    minute := timeObj.Minute() <span class="comment">//分钟</span></span><br><span class="line">    second := timeObj.Second() <span class="comment">//秒</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year, month, day, hour, minute, second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间常量"><a href="#时间常量" class="headerlink" title="时间常量"></a>时间常量</h4><p>time.Duration 是 time 包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。time.Duration 表示一段时间间隔，可表示的最长时间段大约 290 年。</p>
<p>time包中定义的时间间隔类型的常量如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">  Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">  Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">  Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">  Minute               = <span class="number">60</span> * Second</span><br><span class="line">  Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>例如：time.Duration 表示 1 纳秒，time.Second 表示 1 秒。</p>
<h4 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Add(d Duration) Time</span><br></pre></td></tr></table></figure>

<p>求一个小时之后的时间：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    now := time.Now()</span><br><span class="line">    later := now.Add(time.Hour) <span class="comment">// 当前时间加1小时后的时间</span></span><br><span class="line">    fmt.Println(later)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Sub"><a href="#Sub" class="headerlink" title="Sub"></a>Sub</h4><p>求两个时间之间的差值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Sub(u Time) Duration</span><br></pre></td></tr></table></figure>

<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>使用 time.Tick（时间间隔）来设置定时器，定时器的本质上是一个通道（channel）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tickDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ticker := time.NewTicker(time.Second) <span class="comment">//定义一个1秒间隔的定时器</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">    fmt.Println(i)<span class="comment">//每秒都会执行的任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h4><p>使用 Format 函数传入格式化模板（2006 1 2 3 4 Mon Jan），如果想格式化为 12 小时方式，需指定 PM。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  now := time.Now()</span><br><span class="line">  <span class="comment">// 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan</span></span><br><span class="line">  <span class="comment">// 24小时制</span></span><br><span class="line">  fmt.Println(now.Format(<span class="string">&quot;2006-01-02 15:04:05.000 Mon Jan&quot;</span>))</span><br><span class="line">  <span class="comment">// 12小时制</span></span><br><span class="line">  fmt.Println(now.Format(<span class="string">&quot;2006-01-02 03:04:05.000 PM Mon Jan&quot;</span>))</span><br><span class="line">  fmt.Println(now.Format(<span class="string">&quot;2006/01/02 15:04&quot;</span>))</span><br><span class="line">  fmt.Println(now.Format(<span class="string">&quot;15:04 2006/01/02&quot;</span>))</span><br><span class="line">  fmt.Println(now.Format(<span class="string">&quot;2006/01/02&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）reflect"><a href="#（3）reflect" class="headerlink" title="（3）reflect"></a>（3）reflect</h3><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ul>
<li>反射是指在程序运行期对程序本身进行访问和修改的能力。</li>
<li><code>reflect </code> 包封装了反射相关的方法。</li>
<li>获取类型信息：<code>reflect.TypeOf</code>，是静态的。</li>
<li>获取值信息：<code>reflect.ValueOf</code>，是动态的。</li>
<li>获取类型名称：<code>reflect.Name</code></li>
<li>获取类型种类：<code>reflect.Kind</code>，底层的具体类型。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectFn</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  v := reflect.TypeOf(x)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;类型：%v，类型名称：%v，类型种类：%v&quot;</span>, v, v.Name(), v.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := <span class="number">10</span></span><br><span class="line">  b := <span class="number">23.4</span></span><br><span class="line">  c := <span class="literal">true</span></span><br><span class="line">  d := <span class="string">&quot;test&quot;</span></span><br><span class="line">  <span class="keyword">var</span> e myInt = <span class="number">12</span></span><br><span class="line">  <span class="keyword">var</span> f = Person&#123;</span><br><span class="line">    Name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    Age: <span class="number">12</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  i := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">  j := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">  reflectFn(a) <span class="comment">// 类型：int，类型名称：int，类型种类：int</span></span><br><span class="line">  reflectFn(b) <span class="comment">// 类型：float64，类型名称：float64，类型种类：float64</span></span><br><span class="line">  reflectFn(c) <span class="comment">// 类型：bool，类型名称：bool，类型种类：bool</span></span><br><span class="line">  reflectFn(d) <span class="comment">// 类型：string，类型名称：string，类型种类：string</span></span><br><span class="line">  reflectFn(e) <span class="comment">// 类型：main.myInt，类型名称：myInt，类型种类：int</span></span><br><span class="line">  reflectFn(f) <span class="comment">// 类型：main.Person，类型名称：Person，类型种类：struct</span></span><br><span class="line">  reflectFn(&amp;a) <span class="comment">// 类型：*int，类型名称：，类型种类：ptr</span></span><br><span class="line">  reflectFn(i) <span class="comment">// 类型：[3]int，类型名称：，类型种类：array</span></span><br><span class="line">  reflectFn(j) <span class="comment">// 类型：[]int，类型名称：，类型种类：slice</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取原始值"><a href="#获取原始值" class="headerlink" title="获取原始值"></a>获取原始值</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectFn</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  v := reflect.ValueOf(x)</span><br><span class="line">  kind := v.Kind()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">switch</span> kind &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Int64:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;原始值是：&quot;</span>, v.Int())</span><br><span class="line">    <span class="keyword">case</span> reflect.Float32:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;原始值是：&quot;</span>, v.Float())</span><br><span class="line">    <span class="keyword">case</span> reflect.Float64:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;原始值是：&quot;</span>, v.Float())</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;原始值是：&quot;</span>, v.String())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改值信息"><a href="#修改值信息" class="headerlink" title="修改值信息"></a>修改值信息</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射修改值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_set_value</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  v := reflect.ValueOf(a)</span><br><span class="line">  k := v.Kind()</span><br><span class="line">  <span class="keyword">switch</span> k &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Float64:</span><br><span class="line">    <span class="comment">// 反射修改值</span></span><br><span class="line">    v.SetFloat(<span class="number">6.9</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a is &quot;</span>, v.Float())</span><br><span class="line">    <span class="keyword">case</span> reflect.Ptr:</span><br><span class="line">    <span class="comment">// Elem()获取地址指向的值</span></span><br><span class="line">    v.Elem().SetFloat(<span class="number">7.9</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;case:&quot;</span>, v.Elem().Float())</span><br><span class="line">    <span class="comment">// 地址</span></span><br><span class="line">    fmt.Println(v.Pointer())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">  <span class="comment">// 反射认为下面是指针类型，不是float类型</span></span><br><span class="line">  reflect_set_value(&amp;x)</span><br><span class="line">  fmt.Println(<span class="string">&quot;main:&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反射与结构体"><a href="#反射与结构体" class="headerlink" title="反射与结构体"></a>反射与结构体</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span> <span class="string">`json:&quot;name&quot; form:&quot;username&quot;`</span></span><br><span class="line">  Age <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span></span> GetInfo() <span class="type">string</span> &#123;</span><br><span class="line">  str := fmt.Sprintf(<span class="string">&quot;姓名：%v 年龄：%v&quot;</span>, s.Name, s.Age)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> SetInfo(name <span class="type">string</span>, age <span class="type">int</span>) &#123;</span><br><span class="line">  s.Name = name</span><br><span class="line">  s.Age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintStructField</span><span class="params">(s <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  t := reflect.TypeOf(s)</span><br><span class="line">  v := reflect.ValueOf(s)</span><br><span class="line">  <span class="keyword">if</span> t.Kind() != reflect.Struct &amp;&amp; t.Elem().Kind() != reflect.Struct &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;传参不是结构体&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用Field方法可以通过结构体字段下标获取结构体中的字段</span></span><br><span class="line">  field0 := t.Field(<span class="number">0</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%#v&quot;</span>, field0) <span class="comment">// reflect.StructField&#123;Name:&quot;Name&quot;, PkgPath:&quot;&quot;, Type:(*reflect.rtype)(0x1003d80), Tag:&quot;json:\&quot;name\&quot; form:\&quot;username\&quot;&quot;, Offset:0x0, Index:[]int&#123;0&#125;, Anonymous:false&#125;</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;字段名称：&quot;</span>, field0.Name)</span><br><span class="line">  fmt.Println(<span class="string">&quot;字段类型：&quot;</span>, field0.Type)</span><br><span class="line">  fmt.Println(<span class="string">&quot;字段标签：&quot;</span>, field0.Tag)</span><br><span class="line">  fmt.Println(<span class="string">&quot;字段标签：&quot;</span>, field0.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用FieldByName方法可以通过结构体字段名获取结构体字段</span></span><br><span class="line">  field1, ok := t.FieldByName(<span class="string">&quot;Age&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v&quot;</span>, field01) <span class="comment">// reflect.StructField&#123;Name:&quot;Age&quot;, PkgPath:&quot;&quot;, Type:(*reflect.rtype)(0xdc51c0), Tag:&quot;json:\&quot;age\&quot;&quot;, Offset:0x10, Index:[]int&#123;1&#125;, Anonymous:false&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过NumField获取结构体字段个数</span></span><br><span class="line">  fieldCount := t.NumField()</span><br><span class="line">  fmt.Println(<span class="string">&quot;结构体有&quot;</span>, fieldCount, <span class="string">&quot;个字段&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过值信息获取结构体属性对应的值</span></span><br><span class="line">  fmt.Println(v.FieldByName(<span class="string">&quot;Name&quot;</span>))</span><br><span class="line">  fmt.Println(v.Field(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结构体方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintStructMethod</span><span class="params">(s <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  t := reflect.TypeOf(s)</span><br><span class="line">  v := reflect.ValueOf(s)</span><br><span class="line">  </span><br><span class="line">  method0 := t.Method(<span class="number">0</span>) <span class="comment">// 下标根据方法名的ASCII码排列，和编写顺序无关</span></span><br><span class="line">  fmt.Println(method0) <span class="comment">// &#123;GetInfo  func(main.Student) string &lt;func(main.Student) string Value&gt; 0&#125;</span></span><br><span class="line">  method1, ok := t.MethodByName(<span class="string">&quot;GetInfo&quot;</span>)</span><br><span class="line">  fmt.Println(method0) <span class="comment">// &#123;GetInfo  func(main.Student) string &lt;func(main.Student) string Value&gt; 0&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 执行方法</span></span><br><span class="line">  info := v.MethodByName(<span class="string">&quot;GetInfo&quot;</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">  fmt.Println(info) <span class="comment">// [姓名：test 年龄：12]</span></span><br><span class="line">  </span><br><span class="line">  params := []reflect.Value&#123;</span><br><span class="line">		reflect.ValueOf(<span class="string">&quot;李四&quot;</span>),</span><br><span class="line">		reflect.ValueOf(<span class="number">12</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	v.MethodByName(<span class="string">&quot;SetInfo&quot;</span>).Call(params)</span><br><span class="line"></span><br><span class="line">	info1 := v.MethodByName(<span class="string">&quot;GetInfo&quot;</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(info1) <span class="comment">// [姓名：李四 年龄：12]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取方法数量</span></span><br><span class="line">  fmt.Println(t.NumMethod())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  s := Student&#123;</span><br><span class="line">		Name: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">		Age:  <span class="number">12</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	PrintStructField(&amp;s) <span class="comment">// 修改参数必须传入地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）IO操作"><a href="#（4）IO操作" class="headerlink" title="（4）IO操作"></a>（4）IO操作</h3><h4 id="os包文件操作"><a href="#os包文件操作" class="headerlink" title="os包文件操作"></a>os包文件操作</h4><h5 id="文件打开方式："><a href="#文件打开方式：" class="headerlink" title="文件打开方式："></a>文件打开方式：</h5><table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>os.O_WRONLY</td>
<td>只写</td>
</tr>
<tr>
<td>os.O_CREATE</td>
<td>创建文件</td>
</tr>
<tr>
<td>os.O_RDONLY</td>
<td>只读</td>
</tr>
<tr>
<td>os.O_RDWR</td>
<td>读写</td>
</tr>
<tr>
<td>os.O_TRUNC</td>
<td>清空</td>
</tr>
<tr>
<td>os.O_APPEND</td>
<td>追加</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以只读方式打开文件</span></span><br><span class="line">file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close() <span class="comment">// 必须关闭文件流</span></span><br><span class="line"></span><br><span class="line">fmt.Println(file) <span class="comment">// 返回文件地址 &amp;&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件内容</span></span><br><span class="line"><span class="keyword">var</span> strSlice []<span class="type">byte</span></span><br><span class="line">tempSlice := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  n, err := file.Read(tempSlice)</span><br><span class="line">  <span class="comment">// 读到文件末尾会返回io.EOF错误</span></span><br><span class="line">  <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;读取完毕&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;读取完毕&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;读取到%v个字节&quot;</span>, n) <span class="comment">// 128</span></span><br><span class="line">  strSlice = <span class="built_in">append</span>(strSlice, tempSlice[:n]...)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(strSlice)) <span class="comment">// 完整的文件内容</span></span><br></pre></td></tr></table></figure>

<h5 id="perm："><a href="#perm：" class="headerlink" title="perm："></a>perm：</h5><p>文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。默认为 0666，所有人有所有权限。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读写文件</span></span><br><span class="line">file, err := os.OpenFile(<span class="string">&quot;./main.go&quot;</span>, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  file.WriteString(<span class="string">&quot;ab\n&quot;</span>)</span><br><span class="line">  file.Write([]<span class="type">byte</span>(<span class="string">&quot;cd\n&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := os.Mkdir(<span class="string">&quot;./abc&quot;</span>, <span class="number">0666</span>)</span><br><span class="line">err := os.Mkdir(<span class="string">&quot;./dir1/dir2/dir3&quot;</span>, <span class="number">0666</span>) <span class="comment">// 创建多级目录</span></span><br></pre></td></tr></table></figure>

<h5 id="删除文件夹或文件"><a href="#删除文件夹或文件" class="headerlink" title="删除文件夹或文件"></a>删除文件夹或文件</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := os.Remove(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">err := os.Remove(<span class="string">&quot;./dir&quot;</span>)</span><br><span class="line">err := os.RemoveAll(<span class="string">&quot;./dir&quot;</span>) <span class="comment">// 删除文件夹下所有文件</span></span><br></pre></td></tr></table></figure>

<h5 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := os.Rename(文件<span class="number">1</span>, 文件<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="通过bufio包读写文件"><a href="#通过bufio包读写文件" class="headerlink" title="通过bufio包读写文件"></a>通过bufio包读写文件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">reader := bufio.NewReader(file) <span class="comment">// 创建reader对象</span></span><br><span class="line">line, err := reader.ReadString(<span class="string">&quot;\n&quot;</span>) <span class="comment">// 每次读取一行</span></span><br><span class="line"><span class="comment">// 读取到末尾也会返回io.EOF，但是还会返回最后一行数据</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">  strSlice += line</span><br><span class="line">  fmt.Println(<span class="string">&quot;读取完毕&quot;</span>)</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">file, err := os.OpenFile(<span class="string">&quot;./main.go&quot;</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">writer := bufio.NewWriter(file) <span class="comment">// 创建writer对象</span></span><br><span class="line">writer.WriteString(<span class="string">&quot;ab\n&quot;</span>) <span class="comment">// 将数据写入缓存</span></span><br><span class="line">writer.Flush() <span class="comment">// 将缓存数据写入文件</span></span><br></pre></td></tr></table></figure>

<h4 id="通过ioutil包读写文件"><a href="#通过ioutil包读写文件" class="headerlink" title="通过ioutil包读写文件"></a>通过ioutil包读写文件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">byteStr, err := ioutil.ReadFile(<span class="string">&quot;./main.go&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">&quot;ab\n&quot;</span></span><br><span class="line">err := ioutil.WriteFile(<span class="string">&quot;./main.go&quot;</span>, []<span class="type">byte</span>(str), <span class="number">0666</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复制文件</span></span><br><span class="line">byteStr, err := ioutil.ReadFile(<span class="string">&quot;C:/main.go&quot;</span>)</span><br><span class="line">err := ioutil.WriteFile(<span class="string">&quot;D:/main.go&quot;</span>, byteStr, <span class="number">0666</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6、下划线"><a href="#6、下划线" class="headerlink" title="6、下划线"></a>6、下划线</h2><h3 id="（1）下划线在-import-中"><a href="#（1）下划线在-import-中" class="headerlink" title="（1）下划线在 import 中"></a>（1）下划线在 import 中</h3><p>​	import 下划线的作用：当导入一个包时，该包下的文件里所有 init() 函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行 init() 函数而已。这个时候就可以使用 import* 引用该包。即使用【import _ 包路径】只是引用该包，仅仅是为了调用 init() 函数，所以无法通过包名来调用包中的其他函数。 示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;./hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// hello.Print() </span></span><br><span class="line">  <span class="comment">//编译报错：./main.go:6:5: undefined: hello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：imp-init() come here.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;imp-init() come here.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）下划线在代码中"><a href="#（2）下划线在代码中" class="headerlink" title="（2）下划线在代码中"></a>（2）下划线在代码中</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">  f, _ := os.Open(<span class="string">&quot;/Users/***/Desktop/text.txt&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    n, _ := f.Read(buf)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    os.Stdout.Write(buf[:n])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表一个占位符，open方法返回两个结果，*os.File和error，但只需要第一个，忽略error，不会因不使用error而报错。</span></span><br></pre></td></tr></table></figure>

<h2 id="7、变量"><a href="#7、变量" class="headerlink" title="7、变量"></a>7、变量</h2><h3 id="（1）变量声明"><a href="#（1）变量声明" class="headerlink" title="（1）变量声明"></a>（1）变量声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure>

<h4 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a <span class="type">string</span></span><br><span class="line">  b <span class="type">int</span></span><br><span class="line">  c <span class="type">bool</span></span><br><span class="line">  d <span class="type">float32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure>

<h4 id="批量初始化变量"><a href="#批量初始化变量" class="headerlink" title="批量初始化变量"></a>批量初始化变量</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name, sex = <span class="string">&quot;pprof.cn&quot;</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line"><span class="keyword">var</span> sex = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h4 id="匿名变量（用下划线表示）"><a href="#匿名变量（用下划线表示）" class="headerlink" title="匿名变量（用下划线表示）"></a>匿名变量（用下划线表示）</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span>, <span class="string">&quot;Q1mi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x, _ := foo()</span><br><span class="line">  _, y := foo()</span><br><span class="line">  fmt.Println(<span class="string">&quot;x=&quot;</span>, x)</span><br><span class="line">  fmt.Println(<span class="string">&quot;y=&quot;</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）常量声明"><a href="#（2）常量声明" class="headerlink" title="（2）常量声明"></a>（2）常量声明</h3><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把 <code>var</code> 换成了 <code>const</code>，常量在定义的时候必须赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br></pre></td></tr></table></figure>

<h4 id="多个常量声明"><a href="#多个常量声明" class="headerlink" title="多个常量声明"></a>多个常量声明</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	pi = <span class="number">3.1415</span></span><br><span class="line">	e = <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>const</code> 同时声明多个常量时，如果省略了值则表示和上面一行的值相同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	n1 = <span class="number">100</span></span><br><span class="line">	n2</span><br><span class="line">	n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><p><code>iota</code> 是 <code>go</code> 语言的常量计数器，只能在常量的表达式中使用。 <code>iota</code> 在 <code>const</code> 关键字出现时将被重置为 <code>0</code>。<code>const</code> 中每新增一行常量声明将使 <code>iota</code> 计数一次(<code>iota</code> 可理解为 <code>const</code> 语句块中的行索引)。 使用 <code>iota</code> 能简化定义，在定义枚举时很有用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	n1 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">	n2        <span class="comment">// 1</span></span><br><span class="line">	n3        <span class="comment">// 2</span></span><br><span class="line">	n4        <span class="comment">// 3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>使用_跳过某些值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	n1 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">	n2        <span class="comment">// 1</span></span><br><span class="line">	_</span><br><span class="line">	n4        <span class="comment">// 3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>iota</code> 声明中间插队</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	n1 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">	n2 = <span class="number">100</span>  <span class="comment">// 100</span></span><br><span class="line">	n3 = <span class="literal">iota</span> <span class="comment">// 2</span></span><br><span class="line">	n4        <span class="comment">// 3</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>定义数量级 （这里的 <code>&lt;&lt;</code> 表示左移操作，<code>1&lt;&lt;10</code> 表示将 <code>1</code> 的二进制表示向左移 <code>10</code> 位，也就是由 <code>1</code> 变成了<code>10000000000</code>，也就是十进制的 <code>1024</code>。同理 <code>2&lt;&lt;2</code> 表示将 <code>2 </code> 的二进制表示向左移 <code>2</code> 位，也就是由 <code>10</code> 变成了 <code>1000</code>，也就是十进制的 <code>8</code>）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	_  = <span class="literal">iota</span></span><br><span class="line">	KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>多个 <code>iota </code> 定义在一行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">// 1, 2</span></span><br><span class="line">  c, d                      <span class="comment">// 2, 3</span></span><br><span class="line">  e, f                      <span class="comment">// 3, 4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="8、数组"><a href="#8、数组" class="headerlink" title="8、数组"></a>8、数组</h2><h3 id="（1）数组声明"><a href="#（1）数组声明" class="headerlink" title="（1）数组声明"></a>（1）数组声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 [数组长度]数据类型</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">3</span>]<span class="type">int</span> <span class="comment">// [0 0 0] 不赋值自动填充默认值</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// [0 1 2]</span></span><br><span class="line">arr3 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// [0 1 2]</span></span><br><span class="line"><span class="keyword">var</span> arr4 = [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// [0 1 2]，使用...自行推断数组长度</span></span><br><span class="line">arr5 = [...]<span class="type">int</span>&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">5</span>: <span class="number">10</span>&#125; <span class="comment">// [1 2 0 0 0 10]</span></span><br></pre></td></tr></table></figure>

<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 [元素数量][元素数量]T</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有第一层可以使用 ... 推导长度</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">  &#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;, <span class="comment">// 最后一行也要加逗号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、切片"><a href="#9、切片" class="headerlink" title="9、切片"></a>9、切片</h2><p>与数组不同，数组属于值类型，修改原变量不会改变副本值。而切片属于引用类型，修改原变量会改变副本值。</p>
<h3 id="（1）切片声明"><a href="#（1）切片声明" class="headerlink" title="（1）切片声明"></a>（1）切片声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 []T</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 []<span class="type">int</span> <span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> arr2 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// [1 2 3]</span></span><br><span class="line"><span class="keyword">var</span> arr3 = []<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">10</span>, <span class="number">5</span>: <span class="number">20</span>&#125; <span class="comment">// [0 2 10 0 0 20]</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）基于数组定义切片"><a href="#（2）基于数组定义切片" class="headerlink" title="（2）基于数组定义切片"></a>（2）基于数组定义切片</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice0 []<span class="type">int</span> = arr[start:end] <span class="comment">// 包含start不包含end</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="type">int</span> = arr[:end]</span><br><span class="line"><span class="keyword">var</span> slice2 []<span class="type">int</span> = arr[start:]</span><br><span class="line"><span class="keyword">var</span> slice3 []<span class="type">int</span> = arr[:] <span class="comment">// 获取所有值</span></span><br><span class="line"><span class="keyword">var</span> slice4 = arr[:<span class="built_in">len</span>(arr)<span class="number">-1</span>]      <span class="comment">//去掉切片的最后一个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）基于切片定义切片"><a href="#（3）基于切片定义切片" class="headerlink" title="（3）基于切片定义切片"></a>（3）基于切片定义切片</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice0 []<span class="type">int</span> = arr[start:end] <span class="comment">// 包含start不包含end</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="type">int</span> = arr[:end]</span><br><span class="line"><span class="keyword">var</span> slice2 []<span class="type">int</span> = arr[start:]</span><br><span class="line"><span class="keyword">var</span> slice3 []<span class="type">int</span> = arr[:] <span class="comment">// 获取所有值</span></span><br><span class="line"><span class="keyword">var</span> slice4 = arr[:<span class="built_in">len</span>(arr)<span class="number">-1</span>]      <span class="comment">//去掉切片的最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用len()和cap()获取切片的长度和容量</span></span><br><span class="line"><span class="comment">// 切片的长度：切片包含元素的个数</span></span><br><span class="line"><span class="comment">// 切片的容量：切片从第一个元素开始，到其底层数组或切片元素下标的个数</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;长度%d 容量%d\n&quot;</span>, <span class="built_in">len</span>(slice3), <span class="built_in">cap</span>(slice3)) <span class="comment">// 长度5 容量5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice0 []<span class="type">int</span> = arr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Printf(<span class="string">&quot;长度%d 容量%d\n&quot;</span>, <span class="built_in">len</span>(slice0), <span class="built_in">cap</span>(slice0)) <span class="comment">// 长度2 容量4</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）使用-make-声明切片"><a href="#（4）使用-make-声明切片" class="headerlink" title="（4）使用 make 声明切片"></a>（4）使用 make 声明切片</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> T：数据类型</span></span><br><span class="line"><span class="comment"> size：切片元素个数</span></span><br><span class="line"><span class="comment"> cap：切片容量</span></span><br><span class="line"><span class="comment"> 没有cap默认cap=size</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">make</span>([]T, size, <span class="built_in">cap</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">4</span>, <span class="number">8</span>) <span class="comment">// [0 0 0 0]</span></span><br></pre></td></tr></table></figure>

<h2 id="10、Map"><a href="#10、Map" class="headerlink" title="10、Map"></a>10、Map</h2><h3 id="（1）Map-的声明"><a href="#（1）Map-的声明" class="headerlink" title="（1）Map 的声明"></a>（1）Map 的声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// KeyType：key的类型</span></span><br><span class="line"><span class="comment">// ValueType：value的类型</span></span><br><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userinfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">userinfo[<span class="string">&quot;username&quot;</span>] = <span class="string">&quot;张三&quot;</span></span><br><span class="line">userinfo[<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;20&quot;</span></span><br><span class="line">fmt.Println(userinfo) <span class="comment">// map[username:张三 age:20]</span></span><br><span class="line">fmt.Println(userinfo[<span class="string">&quot;sex&quot;</span>]) <span class="comment">// &quot;&quot;，key不存在value返回零值</span></span><br><span class="line"></span><br><span class="line">userinfo := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">  <span class="string">&quot;username&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）判断某个键值对是否存在"><a href="#（2）判断某个键值对是否存在" class="headerlink" title="（2）判断某个键值对是否存在"></a>（2）判断某个键值对是否存在</h3><p>map使用ok判断键值是否存在</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := userinfo[<span class="string">&quot;username&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">  fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）删除键值对"><a href="#（3）删除键值对" class="headerlink" title="（3）删除键值对"></a>（3）删除键值对</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>对象, key)</span><br></pre></td></tr></table></figure>

<h2 id="11、指针"><a href="#11、指针" class="headerlink" title="11、指针"></a>11、指针</h2><h3 id="（1）指针地址和指针类型"><a href="#（1）指针地址和指针类型" class="headerlink" title="（1）指针地址和指针类型"></a>（1）指针地址和指针类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v:代表被取地址的变量，类型为T</span></span><br><span class="line"><span class="comment">// ptr:用于接收地址的变量，ptr的类型就为*T，称做T的指针类型。*代表指针。</span></span><br><span class="line">ptr := &amp;v    <span class="comment">// v的类型为T</span></span><br><span class="line"><span class="comment">// 空指针</span></span><br><span class="line"><span class="keyword">var</span> ptr *T <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := <span class="number">10</span></span><br><span class="line">  b := &amp;a</span><br><span class="line">  fmt.Printf(<span class="string">&quot;a:%d ptr:%p\n&quot;</span>, a, &amp;a) <span class="comment">// a:10 ptr:0xc00001a078</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;b:%p type:%T\n&quot;</span>, b, b) <span class="comment">// b:0xc00001a078 type:*int</span></span><br><span class="line">  fmt.Println(&amp;b)                    <span class="comment">// 0xc00000e018</span></span><br><span class="line">  fmt.Println(*b)										 <span class="comment">// 10</span></span><br><span class="line">  *b = <span class="number">30</span></span><br><span class="line">  fmt.Println(a)										 <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）new-函数"><a href="#（2）new-函数" class="headerlink" title="（2）new 函数"></a>（2）new 函数</h3><p>创建一个类型的指针，并且该指针对应的值为该类型的零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">  b := <span class="built_in">new</span>(<span class="type">bool</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, a) <span class="comment">// *int</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, b) <span class="comment">// *bool</span></span><br><span class="line">  fmt.Println(*a)       <span class="comment">// 0</span></span><br><span class="line">  fmt.Println(*b)       <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）new-和-make-的区别"><a href="#（3）new-和-make-的区别" class="headerlink" title="（3）new 和 make 的区别"></a>（3）new 和 make 的区别</h3><ol>
<li><strong>make</strong> 返回的是引用类型本身，而 <strong>new</strong> 返回的是指向类型的指针。</li>
<li><strong>make</strong> 只能初始化类型为 <em>slice、map、channel</em>，而 <strong>new</strong> 可以初始化任意数据类型。</li>
<li>对于引用类型，<strong>new</strong> 只会为其分配内存空间，内部字段还需进一步初始化，<strong>make</strong> 则会对内部数据类型也进行初始化。</li>
</ol>
<h2 id="12、结构体"><a href="#12、结构体" class="headerlink" title="12、结构体"></a>12、结构体</h2><h3 id="（1）自定义类型别名"><a href="#（1）自定义类型别名" class="headerlink" title="（1）自定义类型别名"></a>（1）自定义类型别名</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> name T</span><br><span class="line"><span class="keyword">type</span> name = T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区别</span></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a NewInt</span><br><span class="line">  <span class="keyword">var</span> b MyInt</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">// type of a:main.NewInt</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;type of b:%T\n&quot;</span>, b) <span class="comment">// type of b:int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）结构体声明"><a href="#（2）结构体声明" class="headerlink" title="（2）结构体声明"></a>（2）结构体声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体名 <span class="keyword">struct</span> &#123;</span><br><span class="line">  字段名 字段类型</span><br><span class="line">  字段名 字段类型</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结构体名首字母大写表示公有，在其他包中可以使用，小写表示私有。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">  sex <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体实例化</span></span><br><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line">p1.name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">p1.age = <span class="number">20</span></span><br><span class="line">p1.sex = <span class="string">&quot;男&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指针类型结构体</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)     <span class="comment">// *main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">// p2=&amp;main.person&#123;name:&quot;&quot;, sex:&quot;&quot;, age:0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Go语言中支持对结构体指针直接使用.来访问结构体的成员</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">&quot;李四&quot;</span></span><br><span class="line">p2.age = <span class="number">18</span></span><br><span class="line">p2.sex = <span class="string">&quot;男&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">// p2=&amp;main.person&#123;name:&quot;李四&quot;, sex:&quot;男&quot;, age:18&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取结构体地址实例化</span></span><br><span class="line"><span class="keyword">var</span> p3 = &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3)     <span class="comment">// *main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">// p3=&amp;main.person&#123;name:&quot;&quot;, sex:&quot;&quot;, age:0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用键值对初始化结构体</span></span><br><span class="line">p4 := person&#123;</span><br><span class="line">  name: <span class="string">&quot;王五&quot;</span>,</span><br><span class="line">  sex: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p5 := &amp;person&#123;</span><br><span class="line">  name: <span class="string">&quot;王五&quot;</span>,</span><br><span class="line">  sex: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略键初始化结构体，顺序必须与结构体相对应</span></span><br><span class="line">p6 := person&#123;</span><br><span class="line">  <span class="string">&quot;哈哈&quot;</span>,</span><br><span class="line">  <span class="number">20</span>,</span><br><span class="line">  <span class="string">&quot;女&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p7 := &amp;person&#123;</span><br><span class="line">  <span class="string">&quot;哈哈&quot;</span>,</span><br><span class="line">  <span class="number">20</span>,</span><br><span class="line">  <span class="string">&quot;女&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）结构体方法和接收者"><a href="#（3）结构体方法和接收者" class="headerlink" title="（3）结构体方法和接收者"></a>（3）结构体方法和接收者</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *Person &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Dream() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := NewPerson(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetAge(newAge <span class="type">int8</span>) &#123;</span><br><span class="line">  p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p1 := NewPerson(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">  fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">  p1.SetAge(<span class="number">30</span>)</span><br><span class="line">  fmt.Println(p1.age) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetAge2 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> SetAge2(newAge <span class="type">int8</span>) &#123;</span><br><span class="line">  p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p1 := NewPerson(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">  p1.Dream()</span><br><span class="line">  fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">  p1.SetAge2(<span class="number">30</span>) <span class="comment">// (*p1).SetAge2(30)</span></span><br><span class="line">  fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">什么时候使用不同类型接收者：</span></span><br><span class="line"><span class="comment">	1.需要修改接收者中的值</span></span><br><span class="line"><span class="comment">	2.接收者是拷贝代价比较大的大对象</span></span><br><span class="line"><span class="comment">	3.保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）结构体的匿名字段"><a href="#（4）结构体的匿名字段" class="headerlink" title="（4）结构体的匿名字段"></a>（4）结构体的匿名字段</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</span></span><br><span class="line"><span class="comment">// Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">string</span></span><br><span class="line">  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p1 := Person&#123;</span><br><span class="line">    <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">    <span class="number">18</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1)        <span class="comment">// main.Person&#123;string:&quot;pprof.cn&quot;, int:18&#125;</span></span><br><span class="line">  fmt.Println(p1.<span class="type">string</span>, p1.<span class="type">int</span>) <span class="comment">// pprof.cn 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）嵌套结构体"><a href="#（5）嵌套结构体" class="headerlink" title="（5）嵌套结构体"></a>（5）嵌套结构体</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">  Province <span class="type">string</span></span><br><span class="line">  City     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name    <span class="type">string</span></span><br><span class="line">  Gender  <span class="type">string</span></span><br><span class="line">  Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  user1 := User&#123;</span><br><span class="line">    Name:   <span class="string">&quot;pprof&quot;</span>,</span><br><span class="line">    Gender: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">    Address: Address&#123;</span><br><span class="line">      Province: <span class="string">&quot;黑龙江&quot;</span>,</span><br><span class="line">      City:     <span class="string">&quot;哈尔滨&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)<span class="comment">//user1=main.User&#123;Name:&quot;pprof&quot;, Gender:&quot;女&quot;, Address:main.Address&#123;Province:&quot;黑龙江&quot;, City:&quot;哈尔滨&quot;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问结构体成员时会先从当前结构体查找，找不到再去上层结构体中查找。</span></span><br><span class="line">  user1.City = <span class="string">&quot;北京&quot;</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)<span class="comment">//user1=main.User&#123;Name:&quot;pprof&quot;, Gender:&quot;女&quot;, Address:main.Address&#123;Province:&quot;黑龙江&quot;, City:&quot;北京&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（6）结构体字段名冲突"><a href="#（6）结构体字段名冲突" class="headerlink" title="（6）结构体字段名冲突"></a>（6）结构体字段名冲突</h3><p>父结构体与子结构体存在字段名冲突，会优先查找父结构体字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name   <span class="type">string</span></span><br><span class="line">  Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> user3 User</span><br><span class="line">  user3.Name = <span class="string">&quot;user3&quot;</span>   <span class="comment">// main.User&#123;Name: &quot;user3&quot;, Address: main.Address&#123;Name: &quot;&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">  Province   <span class="type">string</span></span><br><span class="line">  City       <span class="type">string</span></span><br><span class="line">  CreateTime <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">  Account    <span class="type">string</span></span><br><span class="line">  CreateTime <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name   <span class="type">string</span></span><br><span class="line">  Gender <span class="type">string</span></span><br><span class="line">  Address</span><br><span class="line">  Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> user3 User</span><br><span class="line">  user3.Name = <span class="string">&quot;pprof&quot;</span></span><br><span class="line">  user3.Gender = <span class="string">&quot;女&quot;</span></span><br><span class="line">  <span class="comment">// user3.CreateTime = &quot;2019&quot; // ambiguous selector user3.CreateTime</span></span><br><span class="line">  user3.Address.CreateTime = <span class="string">&quot;2000&quot;</span> <span class="comment">// 指定Address结构体中的CreateTime</span></span><br><span class="line">  user3.Email.CreateTime = <span class="string">&quot;2000&quot;</span>   <span class="comment">// 指定Email结构体中的CreateTime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（7）结构体继承"><a href="#（7）结构体继承" class="headerlink" title="（7）结构体继承"></a>（7）结构体继承</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> move() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">  Feet    <span class="type">int8</span></span><br><span class="line">  *Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d1 := &amp;Dog&#123;</span><br><span class="line">    Feet: <span class="number">4</span>,</span><br><span class="line">    Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">      name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">  d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（8）结构体与JSON相互转换"><a href="#（8）结构体与JSON相互转换" class="headerlink" title="（8）结构体与JSON相互转换"></a>（8）结构体与JSON相互转换</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用encoding/json包将结构体序列化</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span>,</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须公有，否则无法被json包访问</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  s1 := Student&#123;</span><br><span class="line">    ID: <span class="number">1</span>,</span><br><span class="line">    Name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 结构体转JSON</span></span><br><span class="line">  jsonByte, err := json.Marshal(s1) <span class="comment">// 返回一个byte切片（[]byte）和err</span></span><br><span class="line">  jsonStr := <span class="type">string</span>(jsonByte) <span class="comment">// &#123;&quot;ID&quot;: 1, &quot;Name&quot;: &quot;张三&quot;&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// JSON转结构体</span></span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">`&#123;&quot;ID&quot;: 1, &quot;Name&quot;: &quot;张三&quot;&#125;`</span></span><br><span class="line">  <span class="keyword">var</span> s2 Student</span><br><span class="line">  err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;s2) <span class="comment">// 返回err</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体标签</span></span><br><span class="line"><span class="comment">// 表示JSON序列化后转换的键名</span></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID <span class="type">int</span> <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125; <span class="comment">// &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;张三&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="13、函数"><a href="#13、函数" class="headerlink" title="13、函数"></a>13、函数</h2><h3 id="（1）函数参数"><a href="#（1）函数参数" class="headerlink" title="（1）函数参数"></a>（1）函数参数</h3><p>参数类型相同时可以只声明一个类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）不定参数"><a href="#（2）不定参数" class="headerlink" title="（2）不定参数"></a>（2）不定参数</h3><p>不定参数本质上是切片，指参数个数未知，参数类型相同</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(x ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [1 2 3]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(x <span class="type">int</span>, y ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 1 [2 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）返回值"><a href="#（3）返回值" class="headerlink" title="（3）返回值"></a>（3）返回值</h3><p>Go的返回值可以被命名，当return语句没有返回值时，返回返回值的当前值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x, y <span class="type">int</span>)</span></span> (sum, sub <span class="type">int</span>) &#123;</span><br><span class="line">  sum = x + y</span><br><span class="line">  sub = x - y</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a, b := test(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 30 -10</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）闭包"><a href="#（4）闭包" class="headerlink" title="（4）闭包"></a>（4）闭包</h3><p>常驻内存，不污染全局。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i += y</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = add()</span><br><span class="line">fn(<span class="number">10</span>) <span class="comment">// 20</span></span><br><span class="line">fn(<span class="number">10</span>) <span class="comment">// 30</span></span><br><span class="line">fn(<span class="number">10</span>) <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）defer"><a href="#（5）defer" class="headerlink" title="（5）defer"></a>（5）defer</h3><ol>
<li>关键字 defer 用于注册延迟调用。</li>
<li>这些调用直到 return 前才被执。因此，可以用来做资源清理。</li>
<li>多个defer语句，按先进后出的方式执行。</li>
<li>defer语句中的变量，在defer声明时就决定了。</li>
</ol>
<p><img src="/2024/08/07/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/defer.png" alt="defer"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defer注册要执行延迟执行的函数时该函数所有的参数都需要确定其值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="type">string</span>, a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  ret := a + b</span><br><span class="line">  fmt.Println(index, a, b, ret)</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x := <span class="number">1</span></span><br><span class="line">  y := <span class="number">2</span></span><br><span class="line">  <span class="keyword">defer</span> calc(<span class="string">&quot;AA&quot;</span>, x, calc(<span class="string">&quot;A&quot;</span>, x, y))</span><br><span class="line">  x = <span class="number">10</span></span><br><span class="line">  <span class="keyword">defer</span> calc(<span class="string">&quot;BB&quot;</span>, x, calc(<span class="string">&quot;B&quot;</span>, x, y))</span><br><span class="line">  y = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注册顺序：</span></span><br><span class="line"><span class="comment">defer calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))</span></span><br><span class="line"><span class="comment">defer calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))</span></span><br><span class="line"><span class="comment">执行顺序：</span></span><br><span class="line"><span class="comment">defer calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))</span></span><br><span class="line"><span class="comment">defer calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">calc(&quot;A&quot;, x, y) A 1 2 3</span></span><br><span class="line"><span class="comment">calc(&quot;B&quot;, x, y) B 10 2 12</span></span><br><span class="line"><span class="comment">calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y)) BB 10 12 22</span></span><br><span class="line"><span class="comment">calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y)) AA 1 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（6）panic-recover"><a href="#（6）panic-recover" class="headerlink" title="（6）panic&#x2F;recover"></a>（6）panic&#x2F;recover</h3><p>Golang 没有结构化异常，使用 panic 抛出错误，recover 捕获错误。</p>
<p>异常的使用场景简单描述：Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。</p>
<p>panic：</p>
<ol>
<li>内置函数</li>
<li>假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行</li>
<li>返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行</li>
<li>直到goroutine整个退出，并报告错误</li>
</ol>
<p>recover：</p>
<ol>
<li>内置函数</li>
<li>用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为</li>
<li>一般的调用建议<ul>
<li>在defer函数中，通过recever来终止一个goroutine的panicking过程，从而恢复正常代码的执行</li>
<li>可以获取通过panic传递的error</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(err.(<span class="type">string</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;panic error!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// panic error!</span></span><br></pre></td></tr></table></figure>

<h2 id="14、流程控制"><a href="#14、流程控制" class="headerlink" title="14、流程控制"></a>14、流程控制</h2><h3 id="（1）if…else"><a href="#（1）if…else" class="headerlink" title="（1）if…else"></a>（1）if…else</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）for"><a href="#（2）for" class="headerlink" title="（2）for"></a>（2）for</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> init; condition; post &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br><span class="line">init： 一般为赋值表达式，给控制变量赋初值；</span><br><span class="line">condition： 关系表达式或逻辑表达式，循环控制条件；</span><br><span class="line">post： 一般为赋值表达式，给控制变量增量或减量。</span><br><span class="line"><span class="keyword">for</span>语句执行过程如下：</span><br><span class="line">①先对表达式 init 赋初值；</span><br><span class="line">②判别赋值表达式 init 是否满足给定 condition 条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止<span class="keyword">for</span>循环，执行循环体外语句。</span><br></pre></td></tr></table></figure>

<h3 id="（3）range"><a href="#（3）range" class="headerlink" title="（3）range"></a>（3）range</h3><p>Golang range类似迭代器操作，返回 (索引, 值) 或 (键, 值)。</p>
<p>for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）switch…case"><a href="#（4）switch…case" class="headerlink" title="（4）switch…case"></a>（4）switch…case</h3><p>分支可以用逗号间隔，表示同一个分支。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">  <span class="keyword">case</span> val1:</span><br><span class="line">  	...</span><br><span class="line">  <span class="keyword">case</span> val2:</span><br><span class="line">  	...</span><br><span class="line">  <span class="keyword">case</span> val3, val4:</span><br><span class="line">  	...</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h4><p><code>fallthrough</code>可以强制执行满足<code>case</code>条件的下一个<code>case</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> age := <span class="number">10</span>; age &#123;</span><br><span class="line">  <span class="keyword">case</span> age &lt; <span class="number">20</span>:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">  	<span class="keyword">fallthrough</span></span><br><span class="line">  <span class="keyword">case</span> age &gt;= <span class="number">20</span> &amp;&amp; age &lt; <span class="number">40</span>:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> age &gt;= <span class="number">40</span>:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="省略判断变量"><a href="#省略判断变量" class="headerlink" title="省略判断变量"></a>省略判断变量</h4><p>分支使用表达式时<code>switch</code>后面可以省略判断变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> n &gt; <span class="number">0</span> &amp;&amp; n &lt; <span class="number">10</span>:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;i &gt; 0 and i &lt; 10&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> n &gt; <span class="number">10</span> &amp;&amp; n &lt; <span class="number">20</span>:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;i &gt; 10 and i &lt; 20&quot;</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）break"><a href="#（5）break" class="headerlink" title="（5）break"></a>（5）break</h3><p>跳出当前循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">    <span class="keyword">if</span> j == <span class="number">3</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;i=%v j=%v&#x27;\n&quot;</span>, i, j)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i=0 j=0</span></span><br><span class="line"><span class="comment">i=0 j=1</span></span><br><span class="line"><span class="comment">i=0 j=2</span></span><br><span class="line"><span class="comment">i=1 j=0</span></span><br><span class="line"><span class="comment">i=1 j=1</span></span><br><span class="line"><span class="comment">i=1 j=2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>使用<code>lable</code>标签：，表示结束标签对应的循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">lablename: <span class="comment">// 自定义的lable标签</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> j == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> lablename</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;i=%v j=%v&#x27;\n&quot;</span>, i, j)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i=0 j=0</span></span><br><span class="line"><span class="comment">i=0 j=1</span></span><br><span class="line"><span class="comment">i=0 j=2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（6）continue"><a href="#（6）continue" class="headerlink" title="（6）continue"></a>（6）continue</h3><p>结束当前循环，执行下一次循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">if</span> i == <span class="number">3</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure>

<p>使用<code>lable</code>标签，表示开始标签对应的循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">lablename: <span class="comment">// 自定义的lable标签</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> j == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span> lablename</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;i=%v j=%v&#x27;\n&quot;</span>, i, j)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// i=0 j=0</span></span><br><span class="line"><span class="comment">// i=0 j=1</span></span><br><span class="line"><span class="comment">// i=0 j=2</span></span><br><span class="line"><span class="comment">// i=1 j=0</span></span><br><span class="line"><span class="comment">// i=1 j=1</span></span><br><span class="line"><span class="comment">// i=1 j=2</span></span><br></pre></td></tr></table></figure>

<h3 id="（7）goto"><a href="#（7）goto" class="headerlink" title="（7）goto"></a>（7）goto</h3><p>通过<code>lable</code>跳转到指定位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">age := <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;成年人&quot;</span>)</span><br><span class="line">  <span class="keyword">goto</span> lablename</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">lablename:</span><br><span class="line">	fmt.Println(<span class="string">&quot;333&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;444&quot;</span>)</span><br><span class="line"><span class="comment">// 成年人</span></span><br><span class="line"><span class="comment">// 333</span></span><br><span class="line"><span class="comment">// 444</span></span><br></pre></td></tr></table></figure>

<h2 id="15、接口"><a href="#15、接口" class="headerlink" title="15、接口"></a>15、接口</h2><h3 id="（1）接口的定义"><a href="#（1）接口的定义" class="headerlink" title="（1）接口的定义"></a>（1）接口的定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">接口是一个或多个方法签名的集合。</span><br><span class="line">任何类型的方法集中只要拥有该接口<span class="string">&#x27;对应的全部方法&#x27;</span>签名。</span><br><span class="line">就表示它 <span class="string">&quot;实现&quot;</span> 了该接口，无须在该类型上显式声明实现了哪个接口。</span><br><span class="line">这称为Structural Typing。</span><br><span class="line">所谓对应方法，是指有相同名称、参数列表 (不包括参数名) 以及返回值。</span><br><span class="line">当然，该类型还可以有其他方法。</span><br><span class="line"></span><br><span class="line">接口只有方法声明，没有实现，没有数据字段。</span><br><span class="line">接口可以匿名嵌入其他接口，或嵌入到结构中。</span><br><span class="line">对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针。</span><br><span class="line">只有当接口存储的类型和对象都为<span class="literal">nil</span>时，接口才等于<span class="literal">nil</span>。</span><br><span class="line">接口调用不会做receiver的自动转换。</span><br><span class="line">接口同样支持匿名字段方法。</span><br><span class="line">接口也可实现类似OOP中的多态。</span><br><span class="line">空接口可以作为任何类型数据的容器。</span><br><span class="line">一个类型可实现多个接口。</span><br><span class="line">接口命名习惯以 er 结尾。</span><br></pre></td></tr></table></figure>

<p>每个接口由数个方法组成，接口的定义格式如下：</p>
<ul>
<li><p>接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。</p>
</li>
<li><p>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</p>
</li>
<li><p>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">  方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">  方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">  …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> writer <span class="keyword">interface</span>&#123;</span><br><span class="line">  Write([]<span class="type">byte</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）实现接口的条件"><a href="#（2）实现接口的条件" class="headerlink" title="（2）实现接口的条件"></a>（2）实现接口的条件</h3><p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表。</p>
<p>我们来定义一个Sayer接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">  say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义dog和cat两个结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>因为Sayer接口里只有一个say方法，所以我们只需要给dog和cat 分别实现say方法就可以实现Sayer接口了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dog实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> say() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;汪汪汪&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span></span> say() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;喵喵喵&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，Sayer类型的变量能够存储dog和cat类型的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x Sayer <span class="comment">// 声明一个Sayer类型的变量x</span></span><br><span class="line">  a := cat&#123;&#125;  <span class="comment">// 实例化一个cat</span></span><br><span class="line">  b := dog&#123;&#125;  <span class="comment">// 实例化一个dog</span></span><br><span class="line">  x = a       <span class="comment">// 可以把cat实例直接赋值给x</span></span><br><span class="line">  x.say()     <span class="comment">// 喵喵喵</span></span><br><span class="line">  x = b       <span class="comment">// 可以把dog实例直接赋值给x</span></span><br><span class="line">  x.say()     <span class="comment">// 汪汪汪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）空接口"><a href="#（3）空接口" class="headerlink" title="（3）空接口"></a>（3）空接口</h3><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p>
<p>空接口类型的变量可以存储任意类型的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定义一个空接口x</span></span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  s := <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">  x = s</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">  i := <span class="number">100</span></span><br><span class="line">  x = i</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">  b := <span class="literal">true</span></span><br><span class="line">  x = b</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用空接口实现可以接收任意类型的函数参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空接口作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用空接口实现可以保存任意值的字典。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空接口作为map值</span></span><br><span class="line"><span class="keyword">var</span> studentInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">studentInfo[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;李白&quot;</span></span><br><span class="line">studentInfo[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line">studentInfo[<span class="string">&quot;married&quot;</span>] = <span class="literal">false</span></span><br><span class="line">fmt.Println(studentInfo)</span><br></pre></td></tr></table></figure>

<p>使用空接口实现可以保存任意值的切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">1</span>, <span class="string">&quot;2&quot;</span>, <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）类型断言"><a href="#（4）类型断言" class="headerlink" title="（4）类型断言"></a>（4）类型断言</h3><p>想要判断空接口中的值这个时候就可以使用类型断言，其语法格式<code>x.(T)</code>：</p>
<ul>
<li>x：表示类型为interface{}的变量</li>
<li>T：表示断言x可能是的类型。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  x = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">  v, ok := x.(<span class="type">string</span>)</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;类型断言失败&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>x.(type)</code>配合<code>switch</code>语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">justifyType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;x is a string，value is %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;x is a int is %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;x is a bool is %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;unsupport type！&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）值类型接收者和指针类型接收者实现接口的区别"><a href="#（5）值类型接收者和指针类型接收者实现接口的区别" class="headerlink" title="（5）值类型接收者和指针类型接收者实现接口的区别"></a>（5）值类型接收者和指针类型接收者实现接口的区别</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">  move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> move() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x Mover</span><br><span class="line">  <span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">  x = wangcai         <span class="comment">// x可以接收dog类型</span></span><br><span class="line">  <span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">  x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">  x.move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span></span> move() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x Mover</span><br><span class="line">  <span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">  x = wangcai         <span class="comment">// x不可以接收dog类型</span></span><br><span class="line">  <span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">  x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、并发编程"><a href="#二、并发编程" class="headerlink" title="二、并发编程"></a>二、并发编程</h1><h2 id="1、并发的定义"><a href="#1、并发的定义" class="headerlink" title="1、并发的定义"></a>1、并发的定义</h2><h3 id="（1）进程和线程"><a href="#（1）进程和线程" class="headerlink" title="（1）进程和线程"></a>（1）进程和线程</h3><ul>
<li>进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。</li>
<li>进程至少有五种基本状态：初始态、执行态、等待状态、就绪状态、终止状态。</li>
<li>线程是进程的一个执行实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</li>
<li>一个进程可以创建和撤销多个线程；同一个进程中的多个线程之间可以并发执行。</li>
</ul>
<h3 id="（2）并发和并行"><a href="#（2）并发和并行" class="headerlink" title="（2）并发和并行"></a>（2）并发和并行</h3><ul>
<li>多线程程序在一个核的CPU上运行，就是并发。</li>
<li>多线程程序在多个核的CPU上运行，就是并行。</li>
</ul>
<h3 id="（3）协程和线程"><a href="#（3）协程和线程" class="headerlink" title="（3）协程和线程"></a>（3）协程和线程</h3><p>协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。<br>    线程：一个线程上可以跑多个协程，协程是轻量级的线程。</p>
<h2 id="2、Goroutine"><a href="#2、Goroutine" class="headerlink" title="2、Goroutine"></a>2、Goroutine</h2><p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但<code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将<code>goroutine</code>中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p>
<p>在方法前面加上<code>go</code>关键字，就可以开启<code>goroutine</code>。一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> hello()</span><br><span class="line">  fmt.Println(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main goroutine done! 没有输出Hello Goroutine!</span></span><br></pre></td></tr></table></figure>

<p>但是当<code>main</code>函数执行完成时即时协程未执行完毕也会退出。这时候就需要使用<code>Sync</code>包中的<code>WaitGroup</code>方法等待协程结束。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> wg.Done() <span class="comment">// 协程计数器 - 1</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>) <span class="comment">// 协程计数器 + 1</span></span><br><span class="line">  <span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">  wg.Wait() <span class="comment">// 等待所有协程执行完毕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、runtime包"><a href="#3、runtime包" class="headerlink" title="3、runtime包"></a>3、runtime包</h2><h3 id="（1）NumCPU"><a href="#（1）NumCPU" class="headerlink" title="（1）NumCPU"></a>（1）NumCPU</h3><p>获取当前计算机CPU个数</p>
<h3 id="（2）GOMAXPROCS"><a href="#（2）GOMAXPROCS" class="headerlink" title="（2）GOMAXPROCS"></a>（2）GOMAXPROCS</h3><p>设置当前程序并发时占用的CPU逻辑核心数。</p>
<h2 id="4、channel"><a href="#4、channel" class="headerlink" title="4、channel"></a>4、channel</h2><p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明<code>channel</code>的时候需要为其指定元素类型。</p>
<h3 id="（1）channel声明"><a href="#（1）channel声明" class="headerlink" title="（1）channel声明"></a>（1）channel声明</h3><p>channel是一种引用类型。声明通道类型的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure>

<p>声明的通道后需要使用make函数初始化之后才能使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br><span class="line"></span><br><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>单向管道，表示管道只读或只写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- 元素类型, [缓冲大小]) <span class="comment">// 只写管道，只能写入数据</span></span><br><span class="line"><span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> 元素类型, [缓冲大小]) <span class="comment">// 只读管道，只能读取数据</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）管道的操作"><a href="#（2）管道的操作" class="headerlink" title="（2）管道的操作"></a>（2）管道的操作</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储数据，管道长度大于容量会造成死锁</span></span><br><span class="line">ch4 &lt;- <span class="number">10</span></span><br><span class="line"><span class="comment">// 获取数据，获取不到数据（管道没有数据）会造成死锁</span></span><br><span class="line">i := &lt;- ch4</span><br><span class="line"><span class="comment">// 获取数据但不赋值给变量</span></span><br><span class="line">&lt;- ch4</span><br><span class="line"><span class="comment">// 关闭管道</span></span><br><span class="line"><span class="built_in">close</span>(ch4)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.对一个关闭的通道再发送值就会导致panic。</span></span><br><span class="line"><span class="comment">2.对一个关闭的通道进行接收会一直获取值直到通道为空。</span></span><br><span class="line"><span class="comment">3.对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</span></span><br><span class="line"><span class="comment">4.关闭一个已经关闭的通道会导致panic。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）select"><a href="#（3）select" class="headerlink" title="（3）select"></a>（3）select</h3><p><code>select</code>的使用类似于<code>switch</code>语句，它有一系列<code>case</code>分支和一个默认的分支。每个<code>case</code>会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-chan1:</span><br><span class="line">  <span class="comment">// 如果chan1成功读到数据，则进行该case处理语句</span></span><br><span class="line">  <span class="keyword">case</span> chan2 &lt;- <span class="number">1</span>:</span><br><span class="line">  <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">// 如果上面都没有成功，则进入default处理流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>select</code>可以同时监听一个或多个<code>channel</code>，直到其中一个<code>channel</code>ready。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">  ch &lt;- <span class="string">&quot;test1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">  ch &lt;- <span class="string">&quot;test2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 2个管道</span></span><br><span class="line">  output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">  output2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">  <span class="comment">// 跑2个子协程，写数据</span></span><br><span class="line">  <span class="keyword">go</span> test1(output1)</span><br><span class="line">  <span class="keyword">go</span> test2(output2)</span><br><span class="line">  <span class="comment">// 用select监控</span></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> s1 := &lt;-output1:</span><br><span class="line">    fmt.Println(<span class="string">&quot;s1=&quot;</span>, s1)</span><br><span class="line">    <span class="keyword">case</span> s2 := &lt;-output2:</span><br><span class="line">    fmt.Println(<span class="string">&quot;s2=&quot;</span>, s2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果多个<code>channel</code>同时ready，则随机选择一个执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建2个管道</span></span><br><span class="line">  int_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">  string_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//time.Sleep(2 * time.Second)</span></span><br><span class="line">    int_chan &lt;- <span class="number">1</span></span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    string_chan &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> value := &lt;-int_chan:</span><br><span class="line">    fmt.Println(<span class="string">&quot;int:&quot;</span>, value)</span><br><span class="line">    <span class="keyword">case</span> value := &lt;-string_chan:</span><br><span class="line">    fmt.Println(<span class="string">&quot;string:&quot;</span>, value)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用于判断管道是否存满。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断管道有没有存满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建管道</span></span><br><span class="line">  output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">  <span class="comment">// 子协程写数据</span></span><br><span class="line">  <span class="keyword">go</span> write(output1)</span><br><span class="line">  <span class="comment">// 取数据</span></span><br><span class="line">  <span class="keyword">for</span> s := <span class="keyword">range</span> output1 &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;res:&quot;</span>, s)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="comment">// 写数据</span></span><br><span class="line">      <span class="keyword">case</span> ch &lt;- <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;write hello&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;channel full&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）并发安全和锁"><a href="#（4）并发安全和锁" class="headerlink" title="（4）并发安全和锁"></a>（4）并发安全和锁</h3><p>有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg.Add(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">go</span> add()</span><br><span class="line">  <span class="keyword">go</span> add()</span><br><span class="line">  wg.Wait()</span><br><span class="line">  fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们开启了两个<code>goroutine</code>去累加变量x的值，这两个<code>goroutine</code>在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">    lock.Lock() <span class="comment">// 加锁</span></span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg.Add(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">go</span> add()</span><br><span class="line">  <span class="keyword">go</span> add()</span><br><span class="line">  wg.Wait()</span><br><span class="line">  fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h4><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p>
<p>读写锁分为两种：读锁和写锁。当一个<code>goroutine</code>获取读锁之后，其他的<code>goroutine</code>如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  x      <span class="type">int64</span></span><br><span class="line">  wg     sync.WaitGroup</span><br><span class="line">  lock   sync.Mutex</span><br><span class="line">  rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// lock.Lock()   // 加互斥锁</span></span><br><span class="line">  rwlock.Lock() <span class="comment">// 加写锁</span></span><br><span class="line">  x = x + <span class="number">1</span></span><br><span class="line">  time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="comment">// 假设读操作耗时10毫秒</span></span><br><span class="line">  rwlock.Unlock()                   <span class="comment">// 解写锁</span></span><br><span class="line">  <span class="comment">// lock.Unlock()                     // 解互斥锁</span></span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// lock.Lock()                  // 加互斥锁</span></span><br><span class="line">  rwlock.RLock()               <span class="comment">// 加读锁</span></span><br><span class="line">  time.Sleep(time.Millisecond) <span class="comment">// 假设读操作耗时1毫秒</span></span><br><span class="line">  rwlock.RUnlock()             <span class="comment">// 解读锁</span></span><br><span class="line">  <span class="comment">// lock.Unlock()                // 解互斥锁</span></span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  start := time.Now()</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> write()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> read()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wg.Wait()</span><br><span class="line">  end := time.Now()</span><br><span class="line">  fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript高级程序设计</title>
    <url>/2024/08/06/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h1><h2 id="1、var"><a href="#1、var" class="headerlink" title="1、var"></a>1、var</h2><h3 id="1-1-变量提升"><a href="#1-1-变量提升" class="headerlink" title="1.1 变量提升"></a>1.1 变量提升</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码不会报错，因为使用 <font color="skyblue">var</font> 关键字声明的变量会自动提升到函数作用域顶部。</p>
<h3 id="1-2-函数作用域"><a href="#1-2-函数作用域" class="headerlink" title="1.2 函数作用域"></a>1.2 函数作用域</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// Matt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">//Matt</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-全局声明"><a href="#1-3-全局声明" class="headerlink" title="1.3 全局声明"></a>1.3 全局声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>) <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure>

<p>使用 <font color="skyblue">var</font> 在全局作用域中声明的变量会成为 <font color="red">window</font> 对象的属性。</p>
<h2 id="2、let"><a href="#2、let" class="headerlink" title="2、let"></a>2、let</h2><h3 id="2-1-块级作用域"><a href="#2-1-块级作用域" class="headerlink" title="2.1 块级作用域"></a>2.1 块级作用域</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">26</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// ReferenceError: age没有定义</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-暂时性死区"><a href="#2-2-暂时性死区" class="headerlink" title="2.2 暂时性死区"></a>2.2 暂时性死区</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// ReferenceError: age没有定义</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span></span><br></pre></td></tr></table></figure>

<p>在 <font color="skyblue">let</font> 声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出<font color="red">ReferenceError</font>。</p>
<h3 id="2-3-全局声明"><a href="#2-3-全局声明" class="headerlink" title="2.3 全局声明"></a>2.3 全局声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">26</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">age</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>使用 <font color="skyblue">let</font> 在全局作用域中声明的变量不会成为 <font color="red">window </font> 对象的属性。不过， <font color="skyblue">let</font> 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免 <font color="red">SyntaxError</font> ，必须确保页面不会重复声明同一个变量。</p>
<h2 id="3、const"><a href="#3、const" class="headerlink" title="3、const"></a>3、const</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">26</span></span><br><span class="line">age = <span class="number">36</span> <span class="comment">// TypeError：给常量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 也不允许重复声明</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span> <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 声明的作用域也是块</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure>

<h2 id="4、声明风格"><a href="#4、声明风格" class="headerlink" title="4、声明风格"></a>4、声明风格</h2><h3 id="4-1、不使用-var"><a href="#4-1、不使用-var" class="headerlink" title="4.1、不使用 var"></a>4.1、不使用 <font color="red">var</font></h3><p>只使用 <font color="skyblue">let</font> 和 <font color="skyblue">const</font> 有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p>
<h3 id="4-2、-const-优先，-let-次之"><a href="#4-2、-const-优先，-let-次之" class="headerlink" title="4.2、 const 优先， let 次之"></a>4.2、 <font color="skyblue">const</font> 优先， <font color="skyblue">let</font> 次之</h3><p>使用 <font color="skyblue">const</font> 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作，只在提前知道未来会有修改时，再使用 <font color="skyblue">let</font> 。</p>
<hr>
<h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><h2 id="1、typeof-操作符"><a href="#1、typeof-操作符" class="headerlink" title="1、typeof  操作符"></a>1、typeof  操作符</h2><p>对一个值使用typeof操作符会返回下列字符串之一：</p>
<ul>
<li>“undefined” 表示值<font color="orange"><em>未定义</em></font></li>
<li>“boolean” 表示值为<font color="orange"><em>布尔值</em></font></li>
<li>“string” 表示值为<font color="orange"><em>字符串</em></font></li>
<li>“number” 表示值为<font color="orange"><em>数值</em></font></li>
<li>“object” 表示值为<font color="orange"><em>对象</em></font>或<font color="orange"><em>null</em></font></li>
<li>“function” 表示值为<font color="orange"><em>函数</em></font></li>
<li>“symbol” 表示值为<font color="orange"><em>符号</em></font></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;some string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> message) <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(message)) <span class="comment">// &quot;string&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="2、Undefined-类型"><a href="#2、Undefined-类型" class="headerlink" title="2、Undefined 类型"></a>2、Undefined 类型</h2><p>使用 <font color="red">var</font> 和 <font color="red">let</font> 声明了变量但没有初始化时，就相当于给变量赋予了 <font color="blue">undefined</font> 值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message == <span class="literal">undefined</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="literal">undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message == <span class="literal">undefined</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>包含 <font color="blue">undefined</font> 值的变量跟未定义变量是有区别的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>但调用 <font color="blue">typeof</font> 时，返回的结果都是 <font color="blue">undefined</font> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> message) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> age) <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="3、Null-类型"><a href="#3、Null-类型" class="headerlink" title="3、Null 类型"></a>3、Null 类型</h2><p>Null 类型只有一个值，即特殊值 <font color="blue">null</font> 。逻辑上讲， <font color="blue">null</font> 值表示一个空对象指针，因此调用 typeof 会返回 <font color="red">“object”</font> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> car) <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p> <font color="blue">undefined</font> 值是由 <font color="blue">null</font> 值派生而来的，因此 ECMA-262 将它们定义为表面上相等：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="4、Boolean-类型"><a href="#4、Boolean-类型" class="headerlink" title="4、Boolean 类型"></a>4、Boolean 类型</h2><p>Boolean 类型有两个字面值： <font color="green">true</font> 和 <font color="red">false</font> 。这两个布尔值不同于数值，因此 <font color="green">true</font> 不等于1， <font color="red">false</font> 不等于0。注意布尔值是区分大小写的，因此 <font color="green">True</font> 和 <font color="red">False</font> 是有效的标识符，但不是布尔值。</p>
<p>Boolean() 转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为  <font color="green">true</font> 或 <font color="red">false</font> 的规则取决于数据类型和实际的值。下表总结了不同类型与布尔值之间的转换规则：</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">转换为 <font color="green">true</font> 的值</th>
<th align="center">转换为 <font color="red">false</font> 的值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Boolean</td>
<td align="center"><font color="green">true</font></td>
<td align="center"><font color="red">false</font></td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">非空字符串</td>
<td align="center">“”（空字符串）</td>
</tr>
<tr>
<td align="center">Number</td>
<td align="center">非零数值（包括无穷值）</td>
<td align="center">0、NaN</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="center">任意对象</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">Undefined</td>
<td align="center">N&#x2F;A（不存在）</td>
<td align="center">undefined</td>
</tr>
</tbody></table>
<h2 id="5、Number-类型"><a href="#5、Number-类型" class="headerlink" title="5、Number 类型"></a>5、Number 类型</h2><p>Number 类型使用 <font color="blue">IEEE 754</font> 格式表示整数和浮点数（在某些语言中也叫双精度值）。不同的数值类型相应地也有不用的数值字面量格式。</p>
<p>最基本的数值字面量格式是十进制整数，直接写出来即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intNum = <span class="number">55</span> <span class="comment">// 整数</span></span><br></pre></td></tr></table></figure>

<p>整数也可以用八进制（以 8 位基数）或十六进制（以 16 为基数）字面量表示。对于八进制字面量，第一个数字必须是零（0），然后是相应的八进制数字（数值 0 ~ 7）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> octalNum1 = <span class="number">070</span> <span class="comment">// 八进制的 56</span></span><br><span class="line"><span class="keyword">let</span> octalNum2 = <span class="number">079</span> <span class="comment">// 无效的八进制值，当成 79 处理</span></span><br><span class="line"><span class="keyword">let</span> octalNum3 = <span class="number">08</span> <span class="comment">// 无效的八进制值，当成 8 处理</span></span><br></pre></td></tr></table></figure>

<p>八进制字面量在严格模式下是无效的，会导致 JavaScript引擎抛出语法错误。（严格模式下，如果要表示八进制值，应该使用0o。）</p>
<h3 id="5-1-浮点值"><a href="#5-1-浮点值" class="headerlink" title="5.1 浮点值"></a>5.1 浮点值</h3><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span></span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">0.1</span></span><br><span class="line"><span class="keyword">let</span> floatNum3 = <span class="number">.1</span></span><br></pre></td></tr></table></figure>

<p>存储浮点值使用的内存空间是存储整数值的两倍。所以，在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换成整数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.</span> <span class="comment">// 小数点后面没有数字，当成整数 1 处理</span></span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">10.0</span> <span class="comment">// 小数点后面是零，当成整数 10 处理</span></span><br></pre></td></tr></table></figure>

<p>对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以 10 的给定次幂的数值。ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后面跟一个大写或小写的e，再加上一个要乘的10的多少次幂：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span> <span class="comment">// 等于31250000</span></span><br></pre></td></tr></table></figure>

<p>默认情况下 ECMAscript 会将小数点后至少包含 6 个零的浮点值转换为科学记数法（例如 0.000 000 3 会被转换为 3e - 7 ）。</p>
<p>浮点值的精确度最高可达到 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不是 0.3 ，而是 0.30000000000000004。由于这种微小的摄入错误，导致很难测试特定的浮点值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a + b == <span class="number">0.3</span>) &#123;              <span class="comment">// 别这样做</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;You get 0.3.&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里检测两个数值之和是否等于 0.3。如果两个数值分别是 0.05 和 0.25，或者 0.15 和 0.15，那没问题。但如果是 0.1 和 0.2，测试将失败。</p>
<h3 id="5-2-值的范围"><a href="#5-2-值的范围" class="headerlink" title="5.2 值的范围"></a>5.2 值的范围</h3><p>由于内存限制，ECMAScript 并不支持所有数值。ECMAScript 可以表示的最小数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是5e-324；可以表示的最大数值保存在 Number.MAX_VALUE 中，这个值在多数浏览器中是 1.7976931348623157e+308。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity 值。正数用 Infinity 表示，负数用 -Infinity 表示。如果计算返回 Infinity ，将不能再进一步用于任何计算，这是因为 Infinity 没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以用 <font color="blue">isFinite()</font> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span> + <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isFinite</span>(result)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>使用 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以获取 Infinity。这两个属性包含的值分别就是 -Infinity 和 Infinity。</p>
<h3 id="5-3-NaN"><a href="#5-3-NaN" class="headerlink" title="5.3 NaN"></a>5.3 NaN</h3><p>有一个特殊的数值叫<font color="red"> NaN（Not a Number）</font>，用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任何数值在其他语言中通常都会导致错误，从而种植代码执行。但在 ECMAScript 中，0、+0 或 -0 相除都会返回<font color="red"> NaN</font>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>/<span class="number">0</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span>/+<span class="number">0</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>如果<font color="blue">分子</font>是非 0 值，<font color="green">分母</font>是有符号 0 或无符号 0，则会返回 Infinity 或 -Infinity：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>/<span class="number">0</span>) <span class="comment">// Infinity</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>/-<span class="number">0</span>) <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>

<p><font color="red">NaN</font> 有几个独特的属性。首先，任何涉及 <font color="red">NaN</font> 的操作始终返回 <font color="red">NaN</font>（如 <font color="red">NaN</font>&#x2F;10），在连续多步计算时这可能是个问题。其次，<font color="red">NaN</font> 不包括 <font color="red">NaN</font> 在内的任何值。例如：下面的比较操作会返回 <font color="red">false</font>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> == <span class="title class_">NaN</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>为此，ECMAScript 提供了 <font color="blue">isNaN()</font> 函数。该函数接收一个参数判断是否“不是数值”，会尝试把参数转换为数值。某些非数值的值可以直接转换成数值，如字符串 “10” 或布尔值。不能转换为数值的值都会导致这个函数返回 <font color="green">true</font>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="number">10</span>)) <span class="comment">// false，10是数值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>)) <span class="comment">// false，可以转换为数值10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>)) <span class="comment">// true，不可以转换为数值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="literal">true</span>)) <span class="comment">// false，可以转换为数值1</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4-数值转换"><a href="#5-4-数值转换" class="headerlink" title="5.4 数值转换"></a>5.4 数值转换</h3><p>有 3 个函数可以将非数值转换为数值：<font color="skyblue">Number()</font>、<font color="skyblue">parseInt()</font>、<font color="skyblue">parseFloat()</font>。<font color="skyblue">Number()</font> 是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这 3 个函数执行的操作也不同。</p>
<p><font color="skyblue">Number()</font> 函数基于如下规则执行转换：</p>
<ul>
<li><p>布尔值，<font color="green">true</font> 转换为 1，<font color="red">false</font> 转换为 0。</p>
</li>
<li><p>数值，直接返回。</p>
</li>
<li><p><font color="red">null</font>，返回 0。</p>
</li>
<li><p><font color="red">undefined</font>，返回 <font color="red">NaN</font>。</p>
</li>
<li><p>字符串，应用以下规则：</p>
<ul>
<li>如果字符串包括数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此<font color="skyblue">Number(“1”)</font> 返回 1，<font color="skyblue">Number(“123”)</font> 返回 123，<font color="skyblue">Number(“011”)</font> 返回 11（忽略前面的零）。</li>
<li>如果字符串包含有效的浮点值格式如 “1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。</li>
<li>如果字符串包含有效的十六进制格式如 “0xf”，则会转换为与该十六进制值对应的十进制整数值。</li>
<li>如果是空字符串（不包含字符），则返回 0。</li>
<li>如果字符串包含除上述情况之外的其他字符，则返回 <font color="red">NaN</font>。</li>
</ul>
</li>
<li><p>对象，调用 <font color="blue">valueOf()</font> 方法，并按照上述规则转换返回的值。如果转换结果是 <font color="red">NaN</font>，则调用 <font color="blue">toString()</font> 方法，再按照转换字符串的规则转换。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="title class_">Number</span>(<span class="string">&quot;000011&quot;</span>) <span class="comment">// 11</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Go改变命令行输出颜色</title>
    <url>/2025/03/26/Go%E6%94%B9%E5%8F%98%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<h1 id="faith-color包"><a href="#faith-color包" class="headerlink" title="faith&#x2F;color包"></a>faith&#x2F;color包</h1><p><em><strong>faith&#x2F;color</strong></em>是一个用于美化终端输出的<em><strong>Golang</strong></em>库，可以改变输出文本的颜色。GitHub地址：<a href="https://github.com/faith/color%E3%80%82%E4%B8%8B%E9%9D%A2%E6%98%AF%E5%AE%83%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95%EF%BC%9A">https://github.com/faith/color。下面是它的一些用法：</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/fatih/color</span><br></pre></td></tr></table></figure>

<h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><h3 id="标准颜色"><a href="#标准颜色" class="headerlink" title="标准颜色"></a>标准颜色</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Print with default helper functions</span></span><br><span class="line">color.Cyan(<span class="string">&quot;Prints text in cyan.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// A newline will be appended automatically</span></span><br><span class="line">color.Blue(<span class="string">&quot;Prints %s in blue.&quot;</span>, <span class="string">&quot;text&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// These are using the default foreground colors</span></span><br><span class="line">color.Red(<span class="string">&quot;We have red&quot;</span>)</span><br><span class="line">color.Magenta(<span class="string">&quot;And many others ..&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/03/26/Go%E6%94%B9%E5%8F%98%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2/standard.png" alt="standard"></p>
<h3 id="RGB颜色"><a href="#RGB颜色" class="headerlink" title="RGB颜色"></a>RGB颜色</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">color.RGB(<span class="number">255</span>, <span class="number">128</span>, <span class="number">0</span>).Println(<span class="string">&quot;foreground orange&quot;</span>)</span><br><span class="line">color.RGB(<span class="number">230</span>, <span class="number">42</span>, <span class="number">42</span>).Println(<span class="string">&quot;foreground red&quot;</span>)</span><br><span class="line"></span><br><span class="line">color.BgRGB(<span class="number">255</span>, <span class="number">128</span>, <span class="number">0</span>).Println(<span class="string">&quot;background orange&quot;</span>)</span><br><span class="line">color.BgRGB(<span class="number">230</span>, <span class="number">42</span>, <span class="number">42</span>).Println(<span class="string">&quot;background red&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/03/26/Go%E6%94%B9%E5%8F%98%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2/RGB.png" alt="RGB"></p>
<h3 id="混合颜色"><a href="#混合颜色" class="headerlink" title="混合颜色"></a>混合颜色</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new color object</span></span><br><span class="line">c := color.New(color.FgCyan).Add(color.Underline)</span><br><span class="line">c.Println(<span class="string">&quot;Prints cyan text with an underline.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or just add them to New()</span></span><br><span class="line">d := color.New(color.FgCyan, color.Bold)</span><br><span class="line">d.Printf(<span class="string">&quot;This prints bold cyan %s\n&quot;</span>, <span class="string">&quot;too!.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mix up foreground and background colors, create new mixes!</span></span><br><span class="line">red := color.New(color.FgRed)</span><br><span class="line"></span><br><span class="line">boldRed := red.Add(color.Bold)</span><br><span class="line">boldRed.Println(<span class="string">&quot;This will print text in bold red.&quot;</span>)</span><br><span class="line"></span><br><span class="line">whiteBackground := red.Add(color.BgWhite)</span><br><span class="line">whiteBackground.Println(<span class="string">&quot;Red text with white background.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mix with RGB color codes</span></span><br><span class="line">color.RGB(<span class="number">255</span>, <span class="number">128</span>, <span class="number">0</span>).AddBgRGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).Println(<span class="string">&quot;orange with black background&quot;</span>)</span><br><span class="line"></span><br><span class="line">color.BgRGB(<span class="number">255</span>, <span class="number">128</span>, <span class="number">0</span>).AddRGB(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>).Println(<span class="string">&quot;orange background with white foreground&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/03/26/Go%E6%94%B9%E5%8F%98%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2/mix.png" alt="mix"></p>
<h3 id="配合fmt使用"><a href="#配合fmt使用" class="headerlink" title="配合fmt使用"></a>配合fmt使用</h3><p>在fmt中使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create SprintXxx functions to mix strings with other non-colorized strings:</span></span><br><span class="line">yellow := color.New(color.FgYellow).SprintFunc()</span><br><span class="line">red := color.New(color.FgRed).SprintFunc()</span><br><span class="line">fmt.Printf(<span class="string">&quot;This is a %s and this is %s.\n&quot;</span>, yellow(<span class="string">&quot;warning&quot;</span>), red(<span class="string">&quot;error&quot;</span>))</span><br><span class="line"></span><br><span class="line">info := color.New(color.FgWhite, color.BgGreen).SprintFunc()</span><br><span class="line">fmt.Printf(<span class="string">&quot;This %s rocks!\n&quot;</span>, info(<span class="string">&quot;package&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use helper functions</span></span><br><span class="line">fmt.Println(<span class="string">&quot;This&quot;</span>, color.RedString(<span class="string">&quot;warning&quot;</span>), <span class="string">&quot;should be not neglected.&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %v\n&quot;</span>, color.GreenString(<span class="string">&quot;Info:&quot;</span>), <span class="string">&quot;an important message.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows supported too! Just don&#x27;t forget to change the output to color.Output</span></span><br><span class="line">fmt.Fprintf(color.Output, <span class="string">&quot;Windows support: %s&quot;</span>, color.GreenString(<span class="string">&quot;PASS&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><img src="/2025/03/26/Go%E6%94%B9%E5%8F%98%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2/fmt.png" alt="fmt"></p>
<p>插入fmt打印</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use handy standard colors</span></span><br><span class="line">color.Set(color.FgYellow)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Existing text will now be in yellow&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;This one %s\n&quot;</span>, <span class="string">&quot;too&quot;</span>)</span><br><span class="line"></span><br><span class="line">color.Unset() <span class="comment">// Don&#x27;t forget to unset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can mix up parameters</span></span><br><span class="line">color.Set(color.FgMagenta, color.Bold)</span><br><span class="line"><span class="keyword">defer</span> color.Unset() <span class="comment">// Use it in your function</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;All text will now be bold magenta.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/03/26/Go%E6%94%B9%E5%8F%98%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2/insertfmt.png" alt="insertfmt"></p>
<h2 id="配合Logrus日志库打印出带颜色的日志"><a href="#配合Logrus日志库打印出带颜色的日志" class="headerlink" title="配合Logrus日志库打印出带颜色的日志"></a>配合Logrus日志库打印出带颜色的日志</h2><p>我们需要定义一个继承<strong>logrus.TextFormatter</strong>的结构体<strong>CustomTextFormatter</strong>，并实现<strong>Format</strong>方法来自定义日志的输出格式。还需要将<strong>Logrus</strong>实例的<strong>Formatter</strong>设置为自定义格式化器<strong>CustomTextFormatter</strong>。而不是直接使用<strong>logrus.TextFormatter</strong>。</p>
<p>在<strong>CustomTextFormatter</strong>结构体中，我们添加了<strong>ForceColors</strong>属性以及四个<strong>color.Color</strong>用于不同级别的日志消息。</p>
<p>同时在<strong>CustomTextFormatter</strong>的<strong>Format</strong>方法中根据日志级别选择设置对应的自定义颜色并打印日志消息。如果<strong>ForceColors</strong>为<strong>true</strong>，则使用定义的颜色样式来打印日志；否则，调用父类的<strong>TextFormatter.Format</strong>方法进行默认的格式化操作。</p>
<p><strong>PrintColored</strong>方法用于默认颜色的方式打印日志条目。它将日志级别添加到消息前面，并根据需要添加调用者信息。最后，通过调用**fmt.Fprintln(color.Output, msg)**将带颜色的消息打印到终端。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局的Logger变量</span></span><br><span class="line"><span class="keyword">var</span> Logg *logrus.Logger</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义格式化器，继承自logrus.TextFormatter</span></span><br><span class="line"><span class="keyword">type</span> ColorLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">	logrus.TextFormatter</span><br><span class="line">	ForceColors   <span class="type">bool</span></span><br><span class="line">	ColorInfo     *color.Color</span><br><span class="line">	ColorWarning  *color.Color</span><br><span class="line">	ColorError    *color.Color</span><br><span class="line">	ColorCritical *color.Color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化方法，用于将日志条目格式化为字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ColorLogger)</span></span> Format(entry *logrus.Entry) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> c.ForceColors &#123;</span><br><span class="line">    <span class="comment">// 按日志级别更改日志颜色</span></span><br><span class="line">		<span class="keyword">switch</span> entry.Level &#123;</span><br><span class="line">		<span class="keyword">case</span> logrus.InfoLevel:</span><br><span class="line">			c.ColorInfo.Println(entry.Message)</span><br><span class="line">		<span class="keyword">case</span> logrus.WarnLevel:</span><br><span class="line">			c.ColorWarning.Println(entry.Message)</span><br><span class="line">		<span class="keyword">case</span> logrus.ErrorLevel:</span><br><span class="line">			c.ColorError.Println(entry.Message)</span><br><span class="line">		<span class="keyword">case</span> logrus.FatalLevel, logrus.PanicLevel:</span><br><span class="line">			c.ColorCritical.Println(entry.Message)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			c.PrintColored(entry)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c.TextFormatter.Format(entry)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义方法，用于将日志条目以带颜色的方式打印出来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ColorLogger)</span></span> PrintColored(entry *logrus.Entry) &#123;</span><br><span class="line">	levelColor := color.New(color.FgCyan, color.Bold)             <span class="comment">// 定义蓝色和粗体样式</span></span><br><span class="line">	levelText := levelColor.Sprintf(<span class="string">&quot;%-6s&quot;</span>, entry.Level.String()) <span class="comment">// 格式化日志级别文本</span></span><br><span class="line"></span><br><span class="line">	msg := levelText + <span class="string">&quot; &quot;</span> + entry.Message</span><br><span class="line">	<span class="keyword">if</span> entry.HasCaller() &#123;</span><br><span class="line">		msg += <span class="string">&quot; (&quot;</span> + entry.Caller.File + <span class="string">&quot;:&quot;</span> + strconv.Itoa(entry.Caller.Line) + <span class="string">&quot;)&quot;</span> <span class="comment">// 添加调用者信息</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Fprintln(color.Output, msg) <span class="comment">// 使用有颜色的方式打印消息到终端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Logg = logrus.New()</span><br><span class="line">	Logg.Formatter = &amp;ColorLogger&#123;</span><br><span class="line">		ForceColors:   <span class="literal">true</span>,</span><br><span class="line">		ColorInfo:     color.New(color.FgBlue),</span><br><span class="line">		ColorWarning:  color.New(color.FgYellow),</span><br><span class="line">		ColorError:    color.New(color.FgRed),</span><br><span class="line">		ColorCritical: color.New(color.BgRed, color.FgWhite),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考自：<a href="https://blog.csdn.net/qq_20185737/article/details/133560820">Logrus 日志框架——自定义日志颜色_logrus日志颜色-CSDN博客</a></p>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC学习笔记</title>
    <url>/2025/03/18/RPC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、RPC简介"><a href="#一、RPC简介" class="headerlink" title="一、RPC简介"></a>一、RPC简介</h1><p>RPC：<em><strong>Remote Procedure Call Protocol</strong></em>（远程过程调用）底层是TCP协议。</p>
<h1 id="二、RPC的使用"><a href="#二、RPC的使用" class="headerlink" title="二、RPC的使用"></a>二、RPC的使用</h1><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol>
<li><p>注册RPC服务对象，给对象绑定方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rpc.RegisterName(<span class="string">&quot;服务名&quot;</span>, 回调对象)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建监听器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">listener, err := net.Listen()</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立连接。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn, err := listener.Accept()</span><br></pre></td></tr></table></figure>
</li>
<li><p>将连接绑定RPC服务。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rpc.ServeConn(conn)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> World <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *World)</span></span> HelloWorld(args <span class="type">string</span>, reply *<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	*reply = <span class="string">&quot;Hello &quot;</span> + args</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1、注册rpc服务，绑定对象方法</span></span><br><span class="line">	err := rpc.RegisterName(<span class="string">&quot;hello&quot;</span>, <span class="built_in">new</span>(World))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;服务注册失败！&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2、设置监听</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;连接建立失败！&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listener.Close()</span><br><span class="line">	<span class="comment">// 3、建立连接</span></span><br><span class="line">	conn, err := listener.Accept()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;建立连接失败！&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4、绑定服务</span></span><br><span class="line">	rpc.ServeConn(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol>
<li><p>用RPC连接服务器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn, err := rpc.Dial()</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用远程函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn.Call(<span class="string">&quot;服务名.方法名&quot;</span>, 传入参数, 传出参数)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1、rpc连接服务器</span></span><br><span class="line">	client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;连接rpc服务器失败！&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> client.Close()</span><br><span class="line">	<span class="comment">// 2、调用远程函数</span></span><br><span class="line">	<span class="keyword">var</span> reply <span class="type">string</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;hello.HelloWorld&quot;</span>, <span class="string">&quot;rpc&quot;</span>, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;调用函数失败&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RPC相关函数"><a href="#RPC相关函数" class="headerlink" title="RPC相关函数"></a>RPC相关函数</h2><h3 id="1、注册RPC服务"><a href="#1、注册RPC服务" class="headerlink" title="1、注册RPC服务"></a>1、注册RPC服务</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> RegisterName(name <span class="type">string</span>, rcvr <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	name: 服务名</span></span><br><span class="line"><span class="comment">	rcvr: 对应rpc对象</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2、绑定RPC服务"><a href="#2、绑定RPC服务" class="headerlink" title="2、绑定RPC服务"></a>2、绑定RPC服务</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> ServeConn(conn io.ReadWriteCloser)</span><br></pre></td></tr></table></figure>

<h3 id="3、调用远程函数"><a href="#3、调用远程函数" class="headerlink" title="3、调用远程函数"></a>3、调用远程函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Call(serviceMethod <span class="type">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	serviceMethod: 服务名.方法名</span></span><br><span class="line"><span class="comment">	args: 传入参数</span></span><br><span class="line"><span class="comment">	reply: 传出参数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记</title>
    <url>/2024/09/19/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h1><ul>
<li><p><strong>常用数据类型</strong>：String（字符串）、List（列表）、Hash（哈希）、Set（无序集合）、Sorted Set（有序集合）。</p>
</li>
<li><p><strong>不常用数据类型</strong>：HyperLogLog（一种基数统计算法）、Stream（消息队列）、Geospatial（地理空间）、Bitmap（位图）、Bitfield（位域）、Bloom Filter（布隆过滤器）、Module（模块）</p>
</li>
</ul>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SET key value</td>
<td align="center">设置<code>key-value</code>缓存到<code>redis</code>中，<code>key</code>区分大小写，<code>key</code>已经存在会覆盖原来的<code>value</code></td>
<td align="center">SET name wongzeonwai</td>
</tr>
<tr>
<td align="center">GET key</td>
<td align="center">根据<code>key</code>获取<code>value</code></td>
<td align="center">GET name</td>
</tr>
<tr>
<td align="center">INCR key</td>
<td align="center">将<code>key</code>对应的<code>value</code>的值<code>+1</code>，只能对数字使用</td>
<td align="center">INCR age</td>
</tr>
<tr>
<td align="center">DECR key</td>
<td align="center">将<code>key</code>对应的<code>value</code>的值<code>-1</code>，只能对数字使用</td>
<td align="center">DECR age</td>
</tr>
<tr>
<td align="center">SETEX key seconds value</td>
<td align="center">设置<code>key-value</code>缓存到<code>redis</code>中，并设置缓存时间（秒）</td>
<td align="center">SETEX name 10 wongzeonwai</td>
</tr>
<tr>
<td align="center">TTL key</td>
<td align="center">查看<code>key</code>剩余时间（秒），<code>-1</code>代表时效永久，<code>-2</code>代表已经失效</td>
<td align="center">TTL name</td>
</tr>
<tr>
<td align="center">DEL key</td>
<td align="center">从<code>redis</code>中删除<code>key</code></td>
<td align="center">DEL name</td>
</tr>
<tr>
<td align="center">SETNX key value</td>
<td align="center">如果<code>key</code>已经存在，不做任何操作，如果不存在，执行操作</td>
<td align="center">SETNX name wongzeonwai</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a>不常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">INCRBY key increment</td>
<td align="center">给对应的<code>key</code>添加<code>increment</code>的大小</td>
<td align="center">INCRBY age 10</td>
</tr>
<tr>
<td align="center">MSET key1 value1 key2 value2…</td>
<td align="center">批量添加<code>key-value</code></td>
<td align="center">MSET name wongzeonwai age 26</td>
</tr>
<tr>
<td align="center">MGET key1 key2</td>
<td align="center">批量获取<code>key</code>对应的<code>value</code></td>
<td align="center">MGET name age</td>
</tr>
<tr>
<td align="center">APPEND key value</td>
<td align="center">在<code>key</code>对应的<code>value</code>后拼接<code>value</code></td>
<td align="center">APPEND name ok</td>
</tr>
<tr>
<td align="center">SETRANGE key offset value</td>
<td align="center">从<code>offset</code>对应的索引位置修改<code>key</code>的<code>value</code></td>
<td align="center">SETRANGE age 1 5</td>
</tr>
</tbody></table>
<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HSET key field value</td>
<td align="center">将<code>field</code>存入名为<code>key</code>的<code>hash</code>结构中</td>
<td align="center">HSET user name wongzeonwai</td>
</tr>
<tr>
<td align="center">HGET key field</td>
<td align="center">获取<code>key</code>中<code>field</code>的<code>value</code></td>
<td align="center">HGET user name</td>
</tr>
<tr>
<td align="center">HEXISTS key field</td>
<td align="center">判断<code>key</code>中是否存在<code>field</code>这个哈希键</td>
<td align="center">HEXISTS user name</td>
</tr>
<tr>
<td align="center">HDEL key field</td>
<td align="center">删除<code>key</code>中的<code>field</code>对应的键值对，所有键值对被删除后<code>key</code>也被删除</td>
<td align="center">HDEL user name</td>
</tr>
<tr>
<td align="center">HINCRBY key field increment</td>
<td align="center">给<code>key</code>中<code>field</code>对应的<code>value</code>值加上<code>increment</code>的大小</td>
<td align="center">HINCRBY user age 10</td>
</tr>
<tr>
<td align="center">HLEN key</td>
<td align="center">获取<code>key</code>中键值对的数量</td>
<td align="center">HLEN user</td>
</tr>
<tr>
<td align="center">HKEYS key</td>
<td align="center">获取<code>key</code>中所有的<code>field</code></td>
<td align="center">HKEYS user</td>
</tr>
<tr>
<td align="center">HVALS key</td>
<td align="center">获取<code>key</code>中所有的<code>value</code></td>
<td align="center">HVALS user</td>
</tr>
<tr>
<td align="center">HGETALL key</td>
<td align="center">获取<code>key</code>中所有的键值对</td>
<td align="center">HGETALL user</td>
</tr>
</tbody></table>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LPUSH（RPUSH） key value1 value2…</td>
<td align="center">从左边（右边）添加<code>value</code>，从左边添加按照<code>value</code>的先后顺序，<code>value2</code>会在<code>List</code>的开头</td>
<td align="center">LPUSH（RPUSH）hobby go mysql…</td>
</tr>
<tr>
<td align="center">LRANGE key start stop</td>
<td align="center">从左边开始获取<code>key</code>的数据，<code>start</code>为开始索引，<code>stop</code>为结束索引，负数代表从右边开始计算，<code>-1</code>为最后一个数据</td>
<td align="center">LRANGE key 2 -1</td>
</tr>
<tr>
<td align="center">LPOP（RPOP） key</td>
<td align="center">弹出左边（右边）的第一个数据</td>
<td align="center">LPOP（RPOP） hobby</td>
</tr>
<tr>
<td align="center">LLEN key</td>
<td align="center">获取列表长度</td>
<td align="center">LLEN hobby</td>
</tr>
</tbody></table>
<h2 id="非常用命令"><a href="#非常用命令" class="headerlink" title="非常用命令"></a>非常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LINSERT key before（after） pivot value</td>
<td align="center">在<code>pivot</code>的前面（后面）插入<code>value</code></td>
<td align="center">LINSERT hobby before（after） go redis</td>
</tr>
<tr>
<td align="center">LSET key index value</td>
<td align="center">更新索引为<code>index</code>的值为<code>value</code></td>
<td align="center">LSET hobby 0 html</td>
</tr>
<tr>
<td align="center">LREM key count value</td>
<td align="center">从左边开始删除<code>count</code>个为<code>value</code>的值</td>
<td align="center">LREM hobby 1 html</td>
</tr>
<tr>
<td align="center">LTRIM key start stop</td>
<td align="center">从左边开始截取从索引为<code>start</code>到索引为<code>stop</code>的列表</td>
<td align="center">LTRIM hobby 1 3</td>
</tr>
<tr>
<td align="center">LINDEX key index</td>
<td align="center">从左边开始获取索引为<code>index</code>的值</td>
<td align="center">LINDEX hobby redis</td>
</tr>
</tbody></table>
<h1 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h1><h2 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th>功能</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SADD key member1 member2…</td>
<td>往<code>key</code>集合中添加<code>members</code>元素，不能重复</td>
<td>SADD myset a b c</td>
</tr>
<tr>
<td align="center">SMEMBERS key</td>
<td>遍历<code>key</code>中所有的元素，返回的元素顺序是无序的</td>
<td>SMEMBERS myset</td>
</tr>
<tr>
<td align="center">SREM key member1 member2…</td>
<td>删除<code>key</code>中的<code>member</code>元素</td>
<td>SREM myset a b</td>
</tr>
<tr>
<td align="center">SPOP key count</td>
<td>从<code>key</code>集合随机弹出<code>count</code>个元素</td>
<td>SPOP myset 2</td>
</tr>
</tbody></table>
<h2 id="非常用命令-1"><a href="#非常用命令-1" class="headerlink" title="非常用命令"></a>非常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SDIFF key1 key2</td>
<td align="center">返回<code>key1</code>中特有的元素（差集）</td>
<td align="center">SDIFF set1 set2</td>
</tr>
<tr>
<td align="center">SIDIFFSTORE dest key1 key2</td>
<td align="center">返回<code>key1</code>中特有的元素，并存储到<code>dest</code>集合中</td>
<td align="center">SIDIFFSTORE dest set1 set2</td>
</tr>
<tr>
<td align="center">SINTER key1 key2</td>
<td align="center">返回<code>key1</code>与<code>key2</code>的交集</td>
<td align="center">SINTER set1 set2</td>
</tr>
<tr>
<td align="center">SINTERSTORE dest key1 key2</td>
<td align="center">返回<code>key1</code>与<code>key2</code>的交集，并存储到<code>dest</code>集合中</td>
<td align="center">SINTERSTORE dest set1 set2</td>
</tr>
<tr>
<td align="center">SUNION</td>
<td align="center">返回<code>key1</code>与<code>key2</code>的并集</td>
<td align="center">SUNION set1 set2</td>
</tr>
<tr>
<td align="center">SUNIONSTORE dest key1 key2</td>
<td align="center">返回<code>key1</code>与<code>key2</code>的并集，并存储到<code>dest</code>集合中</td>
<td align="center">SUNIONSTORE dest set1 set2</td>
</tr>
<tr>
<td align="center">SMOVE source dest member</td>
<td align="center">将<code>source</code>中的<code>member</code>元素移动到<code>dest</code>集合中</td>
<td align="center">SMOVE key1 key2 a</td>
</tr>
<tr>
<td align="center">SISMEMBER key member</td>
<td align="center">判断<code>member</code>元素是否存在<code>key</code>集合中</td>
<td align="center">SISMEMBER myset a</td>
</tr>
<tr>
<td align="center">SRANDMEMBER key count</td>
<td align="center">随机获取<code>key</code>集合中的<code>count</code>个元素</td>
<td align="center">SRANDMEMBER myset 2</td>
</tr>
</tbody></table>
<h1 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h1><p>每个元素都需要绑定一个<code>double</code>类型的分数。</p>
<h2 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ZADD key score1 member1 score2 member2…</td>
<td align="center">往<code>key</code>集合中添加<code>member</code>元素，分数为<code>score</code></td>
<td align="center">ZADD results 100 a 200 b</td>
</tr>
<tr>
<td align="center">ZINCRBY key increment member</td>
<td align="center">将<code>member</code>元素的分数<code>+</code>increment</td>
<td align="center">ZADD results 100 a</td>
</tr>
<tr>
<td align="center">ZRANGE key start stop [WITHSCORES]</td>
<td align="center">将元素按分数升序排列【显示分数】</td>
<td align="center">ZRANGE results 0 -1 WITHSCORES</td>
</tr>
<tr>
<td align="center">ZREVRANGE key start stop [WITHSCORES]</td>
<td align="center">将元素按分数降序排列【显示分数】</td>
<td align="center">ZREVRANGE results 0 -1 WITHSCORES</td>
</tr>
<tr>
<td align="center">ZRANK key member</td>
<td align="center">返回<code>member</code>元素在<code>key</code>集合中的正序排名</td>
<td align="center">ZRANK results a</td>
</tr>
<tr>
<td align="center">ZREVRANK key member</td>
<td align="center">返回<code>member</code>元素在<code>key</code>集合中的降序排名</td>
<td align="center">ZREVRANK results a</td>
</tr>
<tr>
<td align="center">ZCARD key</td>
<td align="center">返回元素的个数</td>
<td align="center">ZCARD results</td>
</tr>
<tr>
<td align="center">ZSCORE key member</td>
<td align="center">获取<code>member</code>元素的分数</td>
<td align="center">ZSCORE results a</td>
</tr>
</tbody></table>
<h2 id="非常用命令-2"><a href="#非常用命令-2" class="headerlink" title="非常用命令"></a>非常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ZRANGEBYSCORE key min max [WITHSCORES]</td>
<td align="center">按<code>[min,max]</code>分数范围返回<code>key</code>集合中的元素（正序）</td>
<td align="center">ZRANGEBYSCORE results 100 200 WITHSCORES</td>
</tr>
<tr>
<td align="center">ZREVRANGEBYSCORE key max min [WITHSCORES]</td>
<td align="center">按<code>[min,max]</code>分数范围返回<code>key</code>集合中的元素（降序）</td>
<td align="center">ZREVRANGEBYSCORE results 200 100 WITHSCORES</td>
</tr>
<tr>
<td align="center">ZREM key member</td>
<td align="center">删除<code>member</code>元素</td>
<td align="center">ZREM results a</td>
</tr>
<tr>
<td align="center">ZREMRANGEBYSCORE key min max [WITHSCORES]</td>
<td align="center">按<code>[min,max]</code>分数范围删除<code>key</code>集合中的元素（正序）</td>
<td align="center">ZREMRANGEBYSCORE results 100 200 WITHSCORES</td>
</tr>
<tr>
<td align="center">ZREMRANGEBYRANK key start stop</td>
<td align="center">删除<code>key</code>集合正序排名在<code>[start,stop)</code>中的元素</td>
<td align="center">ZREMRANGEBYRANK results 0 2</td>
</tr>
<tr>
<td align="center">ZCOUNT key min max</td>
<td align="center">返回<code>key</code>集合中分数在<code>[min,max]</code>中的元素个数</td>
<td align="center">ZCOUNT results 100 200</td>
</tr>
</tbody></table>
<h1 id="Redis全局命令"><a href="#Redis全局命令" class="headerlink" title="Redis全局命令"></a>Redis全局命令</h1><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">keys pattern</td>
<td align="center">根据<code>pattern</code>条件查询<code>keys</code></td>
</tr>
<tr>
<td align="center">EXISTS key</td>
<td align="center">判断<code>key</code>是否存在</td>
</tr>
<tr>
<td align="center">EXPIRE key seconds</td>
<td align="center">给<code>key</code>设置过期时间（秒）</td>
</tr>
<tr>
<td align="center">PERSIST key</td>
<td align="center">取消<code>key</code>过期时间</td>
</tr>
<tr>
<td align="center">SELECT index</td>
<td align="center">切换数据库（0-15）</td>
</tr>
<tr>
<td align="center">MOVE key index</td>
<td align="center">从当前数据库将<code>key</code>移动到指定<code>index</code>库</td>
</tr>
<tr>
<td align="center">RANDOMKEY</td>
<td align="center">随机返回一个<code>key</code></td>
</tr>
<tr>
<td align="center">RENAME key newkey</td>
<td align="center">将<code>key</code>重命名为<code>newkey</code></td>
</tr>
<tr>
<td align="center">ECHO message</td>
<td align="center">打印<code>message</code>信息</td>
</tr>
<tr>
<td align="center">DBSIZE</td>
<td align="center">返回当前库中<code>key</code>的个数</td>
</tr>
<tr>
<td align="center">INFO</td>
<td align="center">查看数据库信息</td>
</tr>
<tr>
<td align="center">CONFIG GET pattern</td>
<td align="center">根据<code>pattern</code>匹配条件查看数据库配置信息</td>
</tr>
<tr>
<td align="center">FLUSHDB</td>
<td align="center">清空当前数据库</td>
</tr>
<tr>
<td align="center">FLUSHALL</td>
<td align="center">清空所有数据库</td>
</tr>
</tbody></table>
<h1 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h1><ol>
<li><code>Linux</code>系统<ol>
<li>找到<code>redis.config</code>文件，在<code>requirepass</code>后面添加密码</li>
<li>重启<code>redis</code>服务，使用带密码的命令<code>redis-cli -a ******</code></li>
</ol>
</li>
<li><code>Windows</code>系统<ol>
<li>步骤与<code>Linux</code>系统相同，但是在<code>redis.windows-service.config</code></li>
</ol>
</li>
</ol>
<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>使用<code>MULTI</code>开启事务，使用<code>EXEC</code>执行事务，但是事务的执行并非<code>原子性的</code>，就算中间的命令出错，也不会影响到上下文的执行。</p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p><code>Redis</code>会将内存中的数据保存到硬盘中，实现数据的持久化。</p>
<h2 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h2><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><ol>
<li>使用<code>save</code>命令，会阻塞当前<code>Redis</code>进程直到持久化完成。</li>
<li>使用<code>bgsave</code>，创建一个子进程，由子进程实现持久化。</li>
</ol>
<h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><p>使用<code>save</code>相关配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save m n</span><br><span class="line">#m秒内有n个key被修改时，则发起持久化保持数据。</span><br></pre></td></tr></table></figure>

<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><code>RDB</code>文件是一个可以压缩的二进制文件，适合用于数据备份，全量复制等场景，可以按照每<code>6</code>小时执行一次备份，用于容灾备份。</li>
<li>恢复速度快于<code>ADF</code>方式。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>无法实时、秒级持久化。</li>
<li>不同版本快照文件不一样，容易引起兼容问题。</li>
</ul>
<h2 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h2><p>通过独立日志记录每次执行操作的命令，重启服务器的时候执行文件恢复数据，需要在配置文件中配置<code>appendonly yes</code>。</p>
<p><code>AOF</code>有三种同步策略：</p>
<table>
<thead>
<tr>
<th align="center">策略</th>
<th align="center">功能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">appendfsync always</td>
<td align="center">执行命令时立即写入到磁盘，效率最慢，但是能保证数据完全持久化</td>
<td></td>
</tr>
<tr>
<td align="center">appendfsync everysec</td>
<td align="center">每秒写入一次</td>
<td></td>
</tr>
<tr>
<td align="center">appendfsync no</td>
<td align="center">完全依赖<code>os</code>，一般周期为30秒</td>
<td></td>
</tr>
</tbody></table>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>安全性高，最多损失一秒的数据量。</li>
<li>执行<code>flushall</code>命令后，可以通过<code>AOF</code>方式恢复（删除<code>flushall</code>命令即可）。</li>
<li><code>AOF</code>文件是一个增量日志文件，难以损坏。</li>
<li><code>AOF</code>文件太大时，<code>Redis</code>会在后台自动重写文件。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>文件体积大。</li>
<li>性能较慢。</li>
</ul>
<h2 id="RDB-AOF混合使用"><a href="#RDB-AOF混合使用" class="headerlink" title="RDB-AOF混合使用"></a>RDB-AOF混合使用</h2><p>在<code>Redis 4.0</code>提出的新的解决方法。在写入的时候，先把当前数据写入到<code>RDB</code>文件中，再将后续命令写入到<code>AOF</code>文件中，实现全量备份和增量备份，提升备份效率。</p>
<p>如果不是混合模式，而是两种模式同时启动，<code>Redis</code>加载数据的流程：</p>
<p><img src="/2024/09/19/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis.png" alt="redis"></p>
<h1 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制"></a>Redis内存淘汰机制</h1><ol>
<li><strong>LRU（least recently used）</strong>：最近少使用的数据，仅和时间相关关。</li>
<li><strong>LFU（least frequently used）</strong>：最不经常使用的数据，和时间、频率相关。</li>
<li><strong>TTL</strong>：最接近过期时间的数据。</li>
<li><strong>随机淘汰</strong>。</li>
</ol>
<p><code>Redis</code>通过配置：<code>maxmemory-policy</code>来配置具体的淘汰机制：</p>
<ul>
<li><code>volatile-lru</code>：查询已设置过期时间的数据集，将最近最少使用的数据淘汰。</li>
<li><code>volatile-ttl</code>：查询已设置过期时间的数据集，将即将过期的数据淘汰。</li>
<li><code>volatile-random</code>：已设置过期时间的数据集，随机淘汰数据。</li>
<li><code>volatile-lfu</code>：已设置过期时间的数据集，将一段时间内，使用次数最少的数据淘汰。</li>
<li><code>allkeys-lru</code>：查询所有数据，将最近最少使用的数据淘汰。</li>
<li><code>allkeys-lfu</code>：查询所有数据，将一段时间内，使用次数最少的数据淘汰。</li>
<li><code>allkeys-random</code>：查询所有数据，随机淘汰数据。</li>
<li><code>noeviction</code>：默认配置，内存不足时报错，保证数据不丢失。</li>
</ul>
<h1 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期<code>key</code>处理</h1><ul>
<li><strong>惰性删除</strong>：当访问<code>key</code>时，才去判断是否过期，如果过期直接删除，长期不访问会占内存。</li>
<li><strong>定时删除</strong>：设置键的过期时间的同时，创建一个定时器，当到达过期时间点时立刻删除，对CPU不友好。</li>
<li><strong>定期删除</strong>：隔一段时间对数据检查，删除过期的<code>key</code>。</li>
</ul>
<p><code>Redis</code>服务器采用惰性和定期两种策略，<code>CPU</code>和内存浪费中取得平衡。</p>
<h1 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h1><p>单节点<code>Redis</code>的<strong>并发能力</strong>是有上限的，要进一步提高<code>Redis</code>的并发能力，就需要搭建主从集群，实现读写分离，由<code>主Redis</code>执行<strong>写</strong>操作，<code>从Redis</code>执行<strong>读</strong>操作。</p>
<p>在从节点<code>redis.conf</code>文件中新增配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>

<p>原理：通过<code>RDB-AOF</code>混合方式将数据文件发送给从节点。</p>
<p>每个主节点都有一个<code>Replication id</code>，简称<code>replid</code>标记，从节点会继承主节点的<code>replid</code>，通过判断知道是否第一次复制数据。</p>
<h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><p><code>Redis</code>提供了哨兵（Sentinel）来实现主从集群的自动故障恢复，哨兵的结构和作用如下：</p>
<ul>
<li><strong>监控</strong>：<code>Sentinel</code>会不断检测主从集群是否按预期工作。</li>
<li><strong>自动故障恢复</strong>：如果主节点故障，<code>Sentinel</code>会将一个从节点提升为主节点。</li>
</ul>
<p><code>Sentinel</code>基于心跳机制监测服务状态，每隔一秒向集群的每个实例发送ping命令：</p>
<ul>
<li><strong>主观下线</strong>：如果某<code>Sentinel</code>节点发现某实例未在规定时间内响应，则会认为该实例<strong>主观下线</strong>。</li>
<li><strong>客观下线</strong>：若超过指定数量（最好超过<code>Sentinel</code>数量的一半）的<code>Sentinel</code>都认为该实例<strong>主观下线</strong>，则该实例<strong>客观下线</strong>。</li>
</ul>
<h1 id="Go-redis"><a href="#Go-redis" class="headerlink" title="Go-redis"></a>Go-redis</h1><p><code>Redis</code>推出了<code>Go</code>语言使用<code>Redis</code>数据库的官方库<code>go-redis</code>，文档地址：[Go Redis <a href="https://redis.uptrace.dev/zh/guide/go-redis.html">快速入门] (uptrace.dev)</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化模块</span></span><br><span class="line">go mod init my_go_redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装go-redis库</span></span><br><span class="line">go get github.com/redis/go-redis/v9</span><br></pre></td></tr></table></figure>

<p>在<code>Go</code>中使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/redis/go-redis/v9&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 连接redis数据库</span></span><br><span class="line">	client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr: <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">		Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">		DB: <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">	&#125;)</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  另一种连接方式</span></span><br><span class="line"><span class="comment">  opt, err := redis.ParseURL(&quot;redis://&lt;user&gt;:&lt;pass&gt;@localhost:6379/&lt;db&gt;&quot;)</span></span><br><span class="line"><span class="comment">  if err != nil &#123;</span></span><br><span class="line"><span class="comment">    panic(err)</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	client := redis.NewClient(opt)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">  </span><br><span class="line">  ctx := context.Background()</span><br><span class="line">	<span class="comment">// 使用String数据类型创建一个key-value：foo-bar</span></span><br><span class="line">	err := client.Set(ctx, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="number">0</span>).Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取key为foo的value值</span></span><br><span class="line">	val, err := client.Get(ctx, <span class="string">&quot;foo&quot;</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;foo&quot;</span>, val)</span><br><span class="line">  <span class="comment">// 创建一个Hash类型的数据</span></span><br><span class="line">  session := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;surname&quot;</span>: <span class="string">&quot;Smith&quot;</span>, <span class="string">&quot;company&quot;</span>: <span class="string">&quot;Redis&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="string">&quot;29&quot;</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> session &#123;</span><br><span class="line">      err := client.HSet(ctx, <span class="string">&quot;user-session:123&quot;</span>, k, v).Err()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  userSession := client.HGetAll(ctx, <span class="string">&quot;user-session:123&quot;</span>).Val()</span><br><span class="line">  fmt.Println(userSession)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>缓存穿透</strong>是指客户端请求的数据在缓存和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>解决方案：</p>
<ul>
<li><p>缓存空对象</p>
<p>优点：实现简单，维护方便。</p>
<p>缺点：额外的消耗。可能造成短期的不一致。</p>
</li>
<li><p>布隆过滤</p>
<p>优点：内存占用少，没有多余 key。</p>
<p>缺点：实现复杂。存在误判可能。</p>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>缓存雪崩</strong>是指在同一时段大量的缓存 key 同时失效或者 Redis 服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ul>
<li>给不同的 key 添加随机的 TTL。</li>
<li>利用 Redis 集群提高服务可用性。</li>
<li>给缓存业务添加降级限流策略。</li>
<li>给业务添加多级缓存。</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>缓存击穿</strong>是指一个被高并发访问并且缓存重建业务较复杂的 key 突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>解决方案：</p>
<ul>
<li><p>添加互斥锁。</p>
<p>优点：没有额外内存消耗。保证一致性。实现简单。</p>
<p>缺点：线程需要等待，性能受影响。可能有死锁风险。</p>
<p><img src="/2024/09/19/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/huchisuo.png" alt="互斥锁"></p>
</li>
<li><p>逻辑过期：不设置 TTL，将过期时间放在 value 中。</p>
<p>优点：线程无需等待，性能较好。</p>
<p>缺点：不保证一致性。有额外内存消耗。实现复杂。</p>
<p><img src="/2024/09/19/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/luoji.png" alt="逻辑过期"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>gPRC学习笔记</title>
    <url>/2024/09/25/gPRC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、Protobuf使用"><a href="#一、Protobuf使用" class="headerlink" title="一、Protobuf使用"></a>一、Protobuf使用</h1><h2 id="1、定义-proto文件"><a href="#1、定义-proto文件" class="headerlink" title="1、定义.proto文件"></a>1、定义<code>.proto</code>文件</h2><p>在项目中创建**.proto**后缀的文件</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定proto版本</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// 指定默认包名</span></span><br><span class="line"><span class="keyword">package</span> user;</span><br><span class="line"><span class="comment">// 指定go包名</span></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./proto&quot;</span>;</span><br><span class="line"><span class="comment">// 定义rpc服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetUser (GetUserRequest) <span class="keyword">returns</span> (GetUserResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义服务端流式传输rpc服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetUser (GetUserRequest) <span class="keyword">returns</span> (stream GetUserResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义客户端流式传输rpc服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetUser (stream GetUserRequest) <span class="keyword">returns</span> (GetUserResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义双向流式传输rpc服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetUser (stream GetUserRequest) <span class="keyword">returns</span> (stream GetUserResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请求结构体</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetUserRequest</span> &#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 响应结构体</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetUserResponse</span> &#123;</span><br><span class="line">    User user = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// user结构体</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、安装-Protobuf-编译器和插件"><a href="#2、安装-Protobuf-编译器和插件" class="headerlink" title="2、安装 Protobuf 编译器和插件"></a>2、安装 Protobuf 编译器和插件</h2><p>从<a href="https://github.com/protocolbuffers/protobuf/releases">Releases · protocolbuffers&#x2F;protobuf (github.com)</a>中获取<strong>protoc</strong>编译器，然后安装<code>protoc-gen-go</code> 和 <code>protoc-gen-go-grpc</code> 插件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br><span class="line">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest</span><br></pre></td></tr></table></figure>

<h2 id="3、编译-proto文件"><a href="#3、编译-proto文件" class="headerlink" title="3、编译.proto文件"></a>3、编译<code>.proto</code>文件</h2><p><strong>powershell</strong>运行以下命令将**.proto<strong>文件转换成</strong>go**文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">protoc --go_out=. --go-grpc_out=. proto/user.proto</span><br></pre></td></tr></table></figure>

<p>运行后会生成<code>user.pb.go</code> 和 <code>user_grpc.pb.go</code> 两个文件。</p>
<h1 id="二、实现客户端、服务端"><a href="#二、实现客户端、服务端" class="headerlink" title="二、实现客户端、服务端"></a>二、实现客户端、服务端</h1><h2 id="1、服务端实现"><a href="#1、服务端实现" class="headerlink" title="1、服务端实现"></a>1、服务端实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">  pb <span class="string">&quot;go_grpc/proto&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">  pb.UnimplementedUserServiceServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, <span class="type">error</span>) &#123;</span><br><span class="line">  user := &amp;pb.User&#123;</span><br><span class="line">      Id:    req.Id,</span><br><span class="line">      Name:  <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">      Email: <span class="string">&quot;johndoe@example.com&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pb.GetUserResponse&#123;User: user&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:50051&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  grpcServer := grpc.NewServer()</span><br><span class="line">  pb.RegisterUserServiceServer(grpcServer, &amp;server&#123;&#125;)</span><br><span class="line">  log.Println(<span class="string">&quot;Server is running on port 50051&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err := grpcServer.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、客户端实现"><a href="#2、客户端实现" class="headerlink" title="2、客户端实现"></a>2、客户端实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">&quot;go_grpc/proto&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;localhost:50051&quot;</span>, grpc.WithInsecure(), grpc.WithBlock())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	client := pb.NewUserServiceClient(conn)</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	req := &amp;pb.GetUserRequest&#123;Id: <span class="number">1</span>&#125;</span><br><span class="line">	res, err := client.GetUser(ctx, req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;could not get user: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;User: %v&quot;</span>, res.User)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3、启动服务"><a href="#3、启动服务" class="headerlink" title="3、启动服务"></a>3、启动服务</h2><p>同时通过<code>go run</code>启动服务端和客户端。</p>
<p>服务端启动成功：<code>2024/09/26 15:36:17 Server is running on port 50051</code></p>
<p>客户端启动成功：<code>2024/09/26 15:36:28 User: id:1 name:&quot;John Doe&quot; email:&quot;johndoe@example.com&quot;</code></p>
<h1 id="三、proto数据类型"><a href="#三、proto数据类型" class="headerlink" title="三、proto数据类型"></a>三、proto数据类型</h1><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;type/proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="type">double</span> a1 = <span class="number">1</span>;</span><br><span class="line">  <span class="type">float</span> a2 = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> a3 = <span class="number">3</span>;</span><br><span class="line">  <span class="type">uint32</span> a4 = <span class="number">4</span>;</span><br><span class="line">  <span class="type">uint64</span> a5 = <span class="number">5</span>;</span><br><span class="line">  <span class="type">sint32</span> a6 = <span class="number">6</span>;</span><br><span class="line">  <span class="type">sint64</span> a7 = <span class="number">7</span>;</span><br><span class="line">  <span class="type">fixed32</span> a8 = <span class="number">8</span>;</span><br><span class="line">  <span class="type">fixed64</span> a9 = <span class="number">9</span>;</span><br><span class="line">  <span class="type">sfixed32</span> a10 = <span class="number">10</span>;</span><br><span class="line">  <span class="type">sfixed64</span> a11 = <span class="number">11</span>;</span><br><span class="line">  <span class="type">bool</span> a12 = <span class="number">12</span>;</span><br><span class="line">  <span class="type">string</span> a13 = <span class="number">13</span>;</span><br><span class="line">  <span class="type">bytes</span> a14 = <span class="number">14</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Item</span> &#123;</span><br><span class="line">  <span class="type">string</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">List</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">int32</span> list = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">repeated</span> Item item_list = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Map</span> &#123;</span><br><span class="line">  map&lt;<span class="type">int32</span>, <span class="type">string</span>&gt; k_v1 = <span class="number">1</span>;</span><br><span class="line">  map&lt;<span class="type">int32</span>, Item&gt; k_v2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应Go数据类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型</span></span><br><span class="line"><span class="keyword">type</span> Type <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	A1  <span class="type">float64</span> <span class="string">`protobuf:&quot;fixed64,1,opt,name=a1,proto3&quot; json:&quot;a1,omitempty&quot;`</span></span><br><span class="line">	A2  <span class="type">float32</span> <span class="string">`protobuf:&quot;fixed32,2,opt,name=a2,proto3&quot; json:&quot;a2,omitempty&quot;`</span></span><br><span class="line">	A3  <span class="type">int32</span>   <span class="string">`protobuf:&quot;varint,3,opt,name=a3,proto3&quot; json:&quot;a3,omitempty&quot;`</span></span><br><span class="line">	A4  <span class="type">uint32</span>  <span class="string">`protobuf:&quot;varint,4,opt,name=a4,proto3&quot; json:&quot;a4,omitempty&quot;`</span></span><br><span class="line">	A5  <span class="type">uint64</span>  <span class="string">`protobuf:&quot;varint,5,opt,name=a5,proto3&quot; json:&quot;a5,omitempty&quot;`</span></span><br><span class="line">	A6  <span class="type">int32</span>   <span class="string">`protobuf:&quot;zigzag32,6,opt,name=a6,proto3&quot; json:&quot;a6,omitempty&quot;`</span></span><br><span class="line">	A7  <span class="type">int64</span>   <span class="string">`protobuf:&quot;zigzag64,7,opt,name=a7,proto3&quot; json:&quot;a7,omitempty&quot;`</span></span><br><span class="line">	A8  <span class="type">uint32</span>  <span class="string">`protobuf:&quot;fixed32,8,opt,name=a8,proto3&quot; json:&quot;a8,omitempty&quot;`</span></span><br><span class="line">	A9  <span class="type">uint64</span>  <span class="string">`protobuf:&quot;fixed64,9,opt,name=a9,proto3&quot; json:&quot;a9,omitempty&quot;`</span></span><br><span class="line">	A10 <span class="type">int32</span>   <span class="string">`protobuf:&quot;fixed32,10,opt,name=a10,proto3&quot; json:&quot;a10,omitempty&quot;`</span></span><br><span class="line">	A11 <span class="type">int64</span>   <span class="string">`protobuf:&quot;fixed64,11,opt,name=a11,proto3&quot; json:&quot;a11,omitempty&quot;`</span></span><br><span class="line">	A12 <span class="type">bool</span>    <span class="string">`protobuf:&quot;varint,12,opt,name=a12,proto3&quot; json:&quot;a12,omitempty&quot;`</span></span><br><span class="line">	A13 <span class="type">string</span>  <span class="string">`protobuf:&quot;bytes,13,opt,name=a13,proto3&quot; json:&quot;a13,omitempty&quot;`</span></span><br><span class="line">	A14 []<span class="type">byte</span>  <span class="string">`protobuf:&quot;bytes,14,opt,name=a14,proto3&quot; json:&quot;a14,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	A <span class="type">string</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=a,proto3&quot; json:&quot;a,omitempty&quot;`</span></span><br><span class="line">	B <span class="type">int32</span>  <span class="string">`protobuf:&quot;varint,2,opt,name=b,proto3&quot; json:&quot;b,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 切片</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	List     []<span class="type">int32</span> <span class="string">`protobuf:&quot;varint,1,rep,packed,name=list,proto3&quot; json:&quot;list,omitempty&quot;`</span></span><br><span class="line">	ItemList []*Item <span class="string">`protobuf:&quot;bytes,2,rep,name=item_list,json=itemList,proto3&quot; json:&quot;item_list,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	KV1 <span class="keyword">map</span>[<span class="type">int32</span>]<span class="type">string</span> <span class="string">`protobuf:&quot;bytes,1,rep,name=k_v1,json=kV1,proto3&quot; json:&quot;k_v1,omitempty&quot; protobuf_key:&quot;varint,1,opt,name=key,proto3&quot; protobuf_val:&quot;bytes,2,opt,name=value,proto3&quot;`</span></span><br><span class="line">	KV2 <span class="keyword">map</span>[<span class="type">int32</span>]*Item  <span class="string">`protobuf:&quot;bytes,2,rep,name=k_v2,json=kV2,proto3&quot; json:&quot;k_v2,omitempty&quot; protobuf_key:&quot;varint,1,opt,name=key,proto3&quot; protobuf_val:&quot;bytes,2,opt,name=value,proto3&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解GMP模型</title>
    <url>/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一、单进程到多进程的改变"><a href="#一、单进程到多进程的改变" class="headerlink" title="一、单进程到多进程的改变"></a>一、单进程到多进程的改变</h1><h2 id="1、单进程"><a href="#1、单进程" class="headerlink" title="1、单进程"></a>1、单进程</h2><p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/danjincheng.png" alt="danjincheng"></p>
<p>同一时刻只能执行单个进程，进程阻塞浪费了 CPU 资源。</p>
<h2 id="2、多进程"><a href="#2、多进程" class="headerlink" title="2、多进程"></a>2、多进程</h2><p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/duojincheng.png" alt="duojincheng"></p>
<p>使用时间片轮询方式切换进程，进程切换时也会浪费 CPU 资源。进程占用空间约为虚拟内存的 <em>4GB</em>，线程占用空间约为 <em>4MB</em>。 </p>
<h1 id="二、协程（co-routine）"><a href="#二、协程（co-routine）" class="headerlink" title="二、协程（co-routine）"></a>二、协程（co-routine）</h1><p>线程分为由 CPU 调度的内核态线程，由用户进程自行调度的用户态线程，以及 CPU 和用户都能调度的混合态线程。协程就是在用户态线程基础上实现的轻量级线程。</p>
<h1 id="三、GM模型"><a href="#三、GM模型" class="headerlink" title="三、GM模型"></a>三、GM模型</h1><p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/gmmodel.png" alt="gmmodel"></p>
<p>早期调度器由<strong>线程</strong>和<strong>协程全局队列</strong>组成。<span style="color: blue">M</span> 想要执行、放回 <span style="color: green">G</span> 都必须访问全局 <span style="color: green">G</span> 队列，并且 <span style="color: blue">M</span> 有多个，即多线程访问同一资源需要加锁进行保证互斥&#x2F;同步，所以全局 <span style="color: green">G</span> 队列是有互斥锁进行保护的。</p>
<ol>
<li>创建、销毁、调度G都需要每个M获取锁，这就形成了<strong>激烈的锁竞争</strong>。</li>
<li><span style="color: blue">M</span> 转移 <span style="color: green">G</span> 会造成<strong>延迟和额外的系统负载</strong>。比如当 <span style="color: green">G</span> 中包含创建新协程的时候，M 创建了 <span style="color: green">G’</span>，为了继续执行G，需要把 <span style="color: green">G’</span> 交给 M’ 执行，也造成了<strong>很差的局部性</strong>，因为 <span style="color: green">G’</span> 和 <span style="color: green">G</span> 是相关的，最好放在 <span style="color: blue">M</span> 上执行，而不是其他 <span style="color: blue">M</span>‘ 。</li>
<li>系统调用（CPU 在 <span style="color: blue">M</span> 之间的切换）导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ol>
<h1 id="四、GMP模型"><a href="#四、GMP模型" class="headerlink" title="四、GMP模型"></a>四、GMP模型</h1><p>GMP 是 Go 语言实现的对<strong>线程（M：machine）</strong>、<strong>goroutine（G）</strong>的<strong>调度器（P：processer 处理器）</strong>优化，将 <strong>goroutine</strong> 内存占用限制在 <em>4KB</em>。</p>
<p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/gmpmodel.jpeg" alt="model"></p>
<ol>
<li><strong>全局队列</strong>（Global Queue）：存放等待运行的 <span style="color: green">G</span>。</li>
<li><strong>P的本地队列</strong>：同全局队列类似，存放的也是等待运行的 <span style="color: green">G</span>，存的数量有限，不超过256个。新建 <span style="color: green">G’</span> 时，<span style="color: green">G’</span> 优先加入到 <span style="color: yellow">P</span> 的本地队列，如果队列满了，则会把本地队列中一半的 <span style="color: green">G</span> 移动到全局队列。</li>
<li><strong>P列表</strong>：所有的 <span style="color: yellow">P</span> 都在程序启动时创建，并保存在数组中，最多有<code>GOMAXPROCS</code>(可配置)个。</li>
<li><strong><span style="color: blue">M</span><strong>：当前操作系统分配的操作 Go 程序的内核线程数。线程想运行任务就得获取 <span style="color: yellow">P</span>，从 <span style="color: yellow">P</span> 的本地队列获取 <span style="color: green">G</span>，<span style="color: yellow">P</span> 队列为空时，<span style="color: blue">M</span> 也会尝试从全局队列</strong>拿</strong>一批 <span style="color: green">G</span> 放到P的本地队列，或从其他 <span style="color: yellow">P</span> 的本地队列<strong>偷</strong>一半放到自己P的本地队列。<span style="color: blue">M</span> 运行 <span style="color: green">G</span>，<span style="color: green">G</span> 执行之后，<span style="color: blue">M</span> 会从 <span style="color: yellow">P</span> 获取下一个 <span style="color: green">G</span>，不断重复下去。</li>
</ol>
<h2 id="调度器的设计策略"><a href="#调度器的设计策略" class="headerlink" title="调度器的设计策略"></a>调度器的设计策略</h2><h3 id="1、复用线程"><a href="#1、复用线程" class="headerlink" title="1、复用线程"></a>1、复用线程</h3><p>复用线程策略主要分为两种机制：<strong>work stealing 机制</strong>和<strong>hand off 机制</strong>：</p>
<p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/workstealing.png" alt="work stealing 机制"></p>
<p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/handoff.png" alt="hand off 机制"></p>
<ul>
<li>work stealing 机制：在线程空闲时会从其他线程的本地队列中偷取 <span style="color: green">G</span> 执行。</li>
<li>hand off 机制：在一个线程出现 <span style="color: green">G</span> 阻塞的状况下，会将当前线程和 <span style="color: yellow">P</span> 分离，创建或者唤醒新的线程并将 <span style="color: yellow">P</span> 和新的线程绑定，而原来的线程在 <span style="color: green">G</span> 执行完毕后进入睡眠状态或被销毁。</li>
</ul>
<h3 id="2、利用并行"><a href="#2、利用并行" class="headerlink" title="2、利用并行"></a>2、利用并行</h3><p>使用<code>GOMAXPROCS</code>限定 <span style="color: yellow">P</span> 的个数为 CPU 个数 &#x2F; 2</p>
<h3 id="3、-抢占"><a href="#3、-抢占" class="headerlink" title="3、 抢占"></a>3、 抢占</h3><p>通过时间轮询，每 10ms CPU 会被其他 <span style="color: green">G</span> 抢占执行。</p>
<h3 id="4、全局-G-队列"><a href="#4、全局-G-队列" class="headerlink" title="4、全局 G 队列"></a>4、全局 <span style="color: green">G</span> 队列</h3><p>在 <strong>work stealing 机制</strong>基础上，如果在其他 <span style="color: yellow">P</span> 中无法偷取 G，就会从全局队列中获取。在新的调度器中依然有全局 <span style="color: green">G</span> 队列，当 <span style="color: yellow">P</span> 的本地队列为空时，优先从全局队列获取，如果全局队列为空时则通过 <strong>work stealing 机制</strong>从其他 <span style="color: yellow">P</span> 的本地队列偷取 <span style="color: green">G</span>。</p>
<h2 id="go-func-流程"><a href="#go-func-流程" class="headerlink" title="go func 流程"></a>go func 流程</h2><p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/gofunc.jpeg" alt="go func 流程"></p>
<ol>
<li><p>我们通过 go func() 来创建一个 goroutine；</p>
</li>
<li><p>有两个存储 <span style="color: green">G</span> 的队列，一个是局部调度器 <span style="color: yellow">P</span> 的本地队列、一个是全局 <span style="color: green">G</span> 队列。新创建的 <span style="color: green">G</span> 会先保存在 <span style="color: yellow">P</span> 的本地队列中，如果 <span style="color: yellow">P</span> 的本地队列已经满了就会保存在全局的队列中；</p>
</li>
<li><p><span style="color: green">G</span> 只能运行在 <span style="color: blue">M</span> 中，一个 <span style="color: blue">M</span> 必须持有一个 P，M 与 <span style="color: yellow">P</span> 是 1：1 的关系。M 会从 <span style="color: yellow">P</span> 的本地队列弹出一个可执行状态的 <span style="color: green">G</span> 来执行，如果 <span style="color: yellow">P</span> 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 <span style="color: green">G</span> 来执行；</p>
</li>
<li><p>一个 <span style="color: blue">M</span> 调度 <span style="color: green">G</span> 执行的过程是一个循环机制；</p>
</li>
<li><p>当 <span style="color: blue">M</span> 执行某一个 <span style="color: green">G</span> 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 <span style="color: green">G</span> 在执行，runtime 会把这个线程 <span style="color: blue">M</span> 从 <span style="color: yellow">P</span> 中摘除（detach），然后再创建一个新的操作系统的线程（如果有空闲的线程可用就复用空闲线程）来服务于这个 P；</p>
</li>
<li><p>当 <span style="color: blue">M</span> 系统调用结束时候，这个 <span style="color: green">G</span> 会尝试获取一个空闲的 <span style="color: yellow">P</span> 执行，并放入到这个 <span style="color: yellow">P</span> 的本地队列。如果获取不到 P，那么这个线程 <span style="color: blue">M</span> 变成休眠状态， 加入到空闲线程中，然后这个 <span style="color: green">G</span> 会被放入全局队列中。</p>
</li>
</ol>
<h2 id="调度器的生命周期"><a href="#调度器的生命周期" class="headerlink" title="调度器的生命周期"></a>调度器的生命周期</h2><p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/life.png" alt="生命周期"></p>
<ul>
<li><p>**<span style="color: blue">M0</span>**：<span style="color: blue">M0</span> 是启动程序后的编号为 0 的主线程，这个 <span style="color: blue">M</span> 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，<span style="color: blue">M0</span> 负责执行初始化操作和启动第一个 G， 在之后 <span style="color: blue">M0</span> 就和其他的 <span style="color: blue">M</span> 一样了。</p>
</li>
<li><p>**<span style="color: green">G0</span>**：<span style="color: green">G0</span> 是每次启动一个 <span style="color: blue">M</span> 都会第一个创建的 gourtine，<span style="color: green">G0</span> 仅用于负责调度的 G，<span style="color: green">G0</span> 不指向任何可执行的函数，每个 <span style="color: blue">M</span> 都会有一个自己的 G0。在调度或系统调用时会使用 <span style="color: green">G0</span> 的栈空间，全局变量的 <span style="color: green">G0</span> 是 <span style="color: blue">M0</span> 的 <span style="color: green">G0</span>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>后端</tag>
      </tags>
  </entry>
</search>
