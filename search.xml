<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker学习笔记</title>
    <url>/2024/09/12/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、Docker安装"><a href="#一、Docker安装" class="headerlink" title="一、Docker安装"></a>一、Docker安装</h1><h2 id="1、Centos安装过程"><a href="#1、Centos安装过程" class="headerlink" title="1、Centos安装过程"></a>1、Centos安装过程</h2><h3 id="（1）卸载旧版本的Docker"><a href="#（1）卸载旧版本的Docker" class="headerlink" title="（1）卸载旧版本的Docker"></a>（1）卸载旧版本的Docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure>

<h3 id="（2）更新yum源"><a href="#（2）更新yum源" class="headerlink" title="（2）更新yum源"></a>（2）更新yum源</h3><p>更新前先备份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure>

<p>下载新的<code>CentOS-Base.repo</code>到<code>/etc/yum.repos.d/</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure>

<p>生成缓存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<h3 id="（3）安装docker"><a href="#（3）安装docker" class="headerlink" title="（3）安装docker"></a>（3）安装docker</h3><p>Docker 的安装需要一些依赖包，包括<code>yum-utils</code>、<code>device-mapper-persistent-data</code>和<code>lvm2</code>等。可以使用命令<code>yum install -y yum-utils device-mapper-persistent-data lvm2</code>来安装这些依赖包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure>

<p>配置<code>Docker</code>的<code>yum</code>源。可以使用命令<code>yum-config-manager --add-repo</code>来添加<code>Docker</code>的官方源或国内镜像源（如阿里云镜像源）。添加后，使用命令<code>yum makecache fast</code>来更新 yum 缓存。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>

<p>安装<code>Docker</code>社区版</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure>

<p>启动Docker。先关闭并禁用防火墙随机启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<p>启动后查看docker状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<h3 id="（4）安装docker-compose"><a href="#（4）安装docker-compose" class="headerlink" title="（4）安装docker-compose"></a>（4）安装docker-compose</h3><p>通过curl命令下载，并指定保存到 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/v2.32.1/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>增加文件执行权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>查看版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose version // Docker Compose version v2.32.1</span><br></pre></td></tr></table></figure>

<p>国内镜像站配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://docker.m.daocloud.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.1panel.live&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://hub.rat.dev&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.ccs.tencentyun.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirrors.aliyun.com&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="二、Docker基本命令"><a href="#二、Docker基本命令" class="headerlink" title="二、Docker基本命令"></a>二、Docker基本命令</h1><p><img src="/2024/09/12/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/docker.png" alt="docker"></p>
<h2 id="1、镜像"><a href="#1、镜像" class="headerlink" title="1、镜像"></a>1、镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull 镜像库/作者/镜像名:版本</span><br><span class="line">docker pull docker.io/library/nginx:latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--platform=系统架构</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看下载的镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除镜像</span></span><br><span class="line">docker rmi 镜像ID/镜像名</span><br></pre></td></tr></table></figure>

<h2 id="2、容器"><a href="#2、容器" class="headerlink" title="2、容器"></a>2、容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建并启动容器</span></span><br><span class="line">docker run 镜像名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 在后台运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 宿主机端口:容器端口 端口映射</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v 宿主机文件存放地址、挂载卷:容器文件存放地址 数据卷映射</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e 配置环境变量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name 容器自定义名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--<span class="built_in">rm</span> 停止容器后自动删除</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-it 启动容器后可以进入容器内部，如 Linux 容器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--restart 容器停止后自动重启，always 总是生效，unless-stopper 手动停止容器后不生效</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-c 替换 dockerfile 中的 CMD 命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--network 子网名 加入子网，host 下容器可以直接使用宿主机网络，不需要指定端口号</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-a 查看所有容器</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除容器</span></span><br><span class="line">docker rm 容器名/容器ID</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f 强制删除正在运行的容器</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop 容器名/容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器</span></span><br><span class="line">docker start 容器名/容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器配置</span></span><br><span class="line">docker inspect 容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建容器，后面可选参数与 run 命令相同</span></span><br><span class="line">docker create 镜像名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">docker logs 容器名/容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行 Linux 命令</span></span><br><span class="line">docker exec 容器名/容器ID Linux命令</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器并开启一个 Linux 命令行</span></span><br><span class="line">docker exec -it 容器名/容器ID /bin/sh</span><br></pre></td></tr></table></figure>

<h2 id="3、挂载卷"><a href="#3、挂载卷" class="headerlink" title="3、挂载卷"></a>3、挂载卷</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建挂载卷名</span></span><br><span class="line">docker volume create 挂载卷名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看挂载卷地址</span></span><br><span class="line">docker volume inspect 挂载卷名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有挂载卷</span></span><br><span class="line">docker volume list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除挂载卷</span></span><br><span class="line">docker volume rm 挂载卷名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有没有容器使用的挂载卷</span></span><br><span class="line">docker volume prune -a</span><br></pre></td></tr></table></figure>

<h2 id="4、网络"><a href="#4、网络" class="headerlink" title="4、网络"></a>4、网络</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个子网，同一个子网下的容器可以相互访问，在 Linux 使用 ping 容器名 可以查看子网IP</span></span><br><span class="line">docker network create 子网名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有网络</span></span><br><span class="line">docker network list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除自定义子网</span></span><br><span class="line">docker network rm 子网名/子网ID</span><br></pre></td></tr></table></figure>

<h2 id="5、compose"><a href="#5、compose" class="headerlink" title="5、compose"></a>5、compose</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行 compose 文件</span></span><br><span class="line">docker compose up</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 在后台执行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f 指定文件名</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止并删除 compose 下的容器</span></span><br><span class="line">docker compose down</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker compose stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动容器</span></span><br><span class="line">docker compose start</span><br></pre></td></tr></table></figure>

<h1 id="三、Dockerfile"><a href="#三、Dockerfile" class="headerlink" title="三、Dockerfile"></a>三、Dockerfile</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> 镜像名</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> 工作目录</span></span><br><span class="line"><span class="comment"># 复制工程下的所有文件到，第一个点表示当前工程文件夹，第二个点表示工作目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> 执行命令</span></span><br><span class="line"><span class="comment"># 只能存在一个 CMD</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [容器运行时默认执行的命令]</span></span><br><span class="line"><span class="comment"># 同 CMD</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> []</span></span><br><span class="line"><span class="comment"># 环境变量，一个 ENV 下可以设置多个环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> key=value</span><br><span class="line"><span class="comment"># 监听端口，实际不发布，只是作为开发之间的约束，不指定协议默认为 tcp</span></span><br><span class="line"><span class="keyword">EXPOSE</span> port/protocol</span><br><span class="line"><span class="keyword">MAINTAINER</span> 镜像维护者</span><br><span class="line"><span class="comment"># 设置容器下的用户，默认为 root</span></span><br><span class="line"><span class="keyword">USER</span> 用户名</span><br></pre></td></tr></table></figure>

<h1 id="四、docker-compose-yaml"><a href="#四、docker-compose-yaml" class="headerlink" title="四、docker-compose.yaml"></a>四、docker-compose.yaml</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">版本号</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="string">容器名:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">使用的镜像</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="string">环境变量</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">本地数据存放地址:容器数据存放地址</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">本机端口:容器端口</span></span><br><span class="line">    <span class="attr">depends-on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">依赖于哪个容器（判断执行顺序）</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">重启策略</span></span><br><span class="line"></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line">	<span class="string">自定义子网名:</span></span><br><span class="line">	</span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">	<span class="string">自定义数据卷名:</span></span><br></pre></td></tr></table></figure>

<p>同一个 <strong>yaml</strong> 文件下的子网地址是相同的。</p>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>GVM安装笔记</title>
    <url>/2024/10/17/GVM%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、GVM介绍"><a href="#一、GVM介绍" class="headerlink" title="一、GVM介绍"></a>一、GVM介绍</h1><p><strong>GVM（Go Version Manager）</strong>，一款<code>Go</code>语言版本管理工具，类似于<code>nodejs</code>版本管理工具<code>nvm</code>。</p>
<h1 id="二、Windows安装方式"><a href="#二、Windows安装方式" class="headerlink" title="二、Windows安装方式"></a>二、Windows安装方式</h1><p>在<a href="https://github.com/voidint/g/blob/master/README_CN.md">g&#x2F;README_CN.md at master · voidint&#x2F;g (github.com)</a>下找到安装包进行安装。</p>
<p><img src="/2024/10/17/GVM%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/install.png" alt="install"></p>
<p>打开系统环境变量，增加如下变量：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 配置golang下载镜像，不用翻墙。</span><br><span class="line">G_MIRROR=https://golang.google.cn/dl/</span><br><span class="line"># 开启实验特性，用于使修改go存放目录生效。</span><br><span class="line">G_EXPERIMENTAL=true</span><br><span class="line"># 更改go存放目录</span><br><span class="line">G_HOME=自定义地址</span><br><span class="line">GOROOT=%G_HOME%\go</span><br><span class="line"># 配置PATH变量</span><br><span class="line">%GOROOT%\bin</span><br></pre></td></tr></table></figure>

<p>设置完成后，打开<code>powershell</code>或者<code>cmd</code>测试一下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：</span></span><br><span class="line">g</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">NAME:</span><br><span class="line">  g - Golang Version Manager</span><br><span class="line"></span><br><span class="line"> USAGE:</span><br><span class="line">  g  command [<span class="type">arguments...</span>]</span><br><span class="line"></span><br><span class="line"> VERSION:</span><br><span class="line">  <span class="number">1.7</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"> AUTHOR:</span><br><span class="line">  voidint &lt;voidint@<span class="number">126</span>.com&gt;</span><br><span class="line"></span><br><span class="line"> COMMANDS:</span><br><span class="line">    <span class="built_in">ls</span>, l               List installed versions</span><br><span class="line">    <span class="built_in">ls</span><span class="literal">-remote</span>, lr, lsr  List remote versions available <span class="keyword">for</span> install</span><br><span class="line">    use                 <span class="keyword">Switch</span> to specified version</span><br><span class="line">    install, i          Download and install a version</span><br><span class="line">    uninstall           Uninstall a version</span><br><span class="line">    clean               Remove files from the package download directory</span><br><span class="line">    env                 Show env variables of g</span><br><span class="line">    self                Modify g itself</span><br><span class="line">    help, <span class="built_in">h</span>             Shows a list of commands or help <span class="keyword">for</span> one command</span><br><span class="line"></span><br><span class="line"> GLOBAL OPTIONS:</span><br><span class="line">  <span class="literal">--help</span>, <span class="literal">-h</span>     show help</span><br><span class="line">  <span class="literal">--version</span>, <span class="literal">-v</span>  print the version</span><br><span class="line"></span><br><span class="line"> COPYRIGHT:</span><br><span class="line">  Copyright (c) <span class="number">2019</span><span class="literal">-2024</span>, voidint. All rights reserved.</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 更新g本身：</span></span><br><span class="line">  g self update</span><br><span class="line">  <span class="comment"># 卸载g：</span></span><br><span class="line">  g self uninstall</span><br></pre></td></tr></table></figure>

<p>有关<strong>Linux</strong>系统下安装或其他信息可以参考文档：<a href="https://github.com/voidint/g/blob/master/README_CN.md">g&#x2F;README_CN.md at master · voidint&#x2F;g (github.com)</a>。</p>
<p><strong>Linux</strong>系统下也可以之间通过命令行方式安装。</p>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>Gin学习笔记</title>
    <url>/2024/08/16/Gin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、Gin简介"><a href="#一、Gin简介" class="headerlink" title="一、Gin简介"></a>一、Gin简介</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><ul>
<li><code>Golang</code>编写的一个轻量级<code>HTTP Web</code>框架，运行速度快。</li>
<li>擅长处理<code>API</code>接口的高并发。</li>
<li>官网地址：<a href="https://gin-gonic.com/zh-cn">https://gin-gonic.com/zh-cn</a></li>
<li><code>github</code>地址：<a href="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a></li>
</ul>
<h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><ul>
<li><p>快速：基于<code>Radix</code>树的路由，小内存占用。没有反射。可预测的<code>API</code>性能。</p>
</li>
<li><p>支持中间件：传入的<code>HTTP</code>请求可以由一系列中间件和最终操作来处理。 例如：<code>Logger</code>，<code>Authorization</code>，<code>GZIP</code>，最终操作<code>DB</code>。</p>
</li>
<li><p><code>Crash</code>处理：<code>Gin</code>可以<code>catch</code>一个发生在<code>HTTP</code>请求中的<code>panic</code>并<code>recover</code>它。这样，你的服务器将始终可用。例如，你可以向<code>Sentry</code>报告这个<code>panic</code>！</p>
</li>
<li><p><code>JSON</code>验证：<code>Gin</code>可以解析并验证请求的<code>JSON</code>，例如检查所需值的存在。</p>
</li>
<li><p>路由组：更好地组织路由。是否需要授权，不同的<code>API</code>版本…… 此外，这些组可以无限制地嵌套而不会降低性能。</p>
</li>
<li><p>错误管理：<code>Gin</code>提供了一种方便的方法来收集<code>HTTP</code>请求期间发生的所有错误。最终，中间件可以将它们写入日志文件，数据库并通过网络发送。</p>
</li>
<li><p>内置渲染：<code>Gin</code>为<code>JSON</code>，<code>XML</code>和<code>HTML</code>渲染提供了易于使用的<code>API</code>。</p>
</li>
<li><p>可扩展性：新建一个中间件非常简单，</p>
</li>
</ul>
<h2 id="2、安装使用"><a href="#2、安装使用" class="headerlink" title="2、安装使用"></a>2、安装使用</h2><ol>
<li><p>下载并安装 gin：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>
</li>
<li><p>将 gin 引入到代码中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>（可选）如果使用诸如 <code>http.StatusOK</code> 之类的常量，则需要引入 <code>net/http</code> 包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建main.go配置路由</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1.创建路由</span></span><br><span class="line">  r := gin.Default()</span><br><span class="line">  <span class="comment">// 2.绑定路由规则，执行的函数</span></span><br><span class="line">  <span class="comment">// gin.Context，封装了request和response</span></span><br><span class="line">  r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.String(http.StatusOK, <span class="string">&quot;hello World!&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 3.监听端口，默认在8080</span></span><br><span class="line">  <span class="comment">// Run(&quot;里面不指定端口号默认为8080&quot;) </span></span><br><span class="line">  r.Run(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开<code>http://localhost:8000/</code></p>
<p><img src="/2024/08/16/Gin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/helloworld.png" alt="helloworld"></p>
</li>
</ol>
<h2 id="2、响应参数"><a href="#2、响应参数" class="headerlink" title="2、响应参数"></a>2、响应参数</h2><h3 id="（1）JSON数据"><a href="#（1）JSON数据" class="headerlink" title="（1）JSON数据"></a>（1）JSON数据</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c.JSON(code, json)</span><br></pre></td></tr></table></figure>

<h3 id="（2）JSONP数据"><a href="#（2）JSONP数据" class="headerlink" title="（2）JSONP数据"></a>（2）JSONP数据</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://localhost:8000/jsonp?callback=xxxx</span></span><br><span class="line"><span class="comment">// xxx(json)</span></span><br><span class="line">r.GET(<span class="string">&quot;/jsonp&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  c.JSONP(code, json)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）XML数据"><a href="#（3）XML数据" class="headerlink" title="（3）XML数据"></a>（3）XML数据</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c.XML(code, gin.H&#123;</span><br><span class="line">  <span class="string">&quot;success&quot;</span>: <span class="literal">true</span></span><br><span class="line">  <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;这是XML数据&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;map&gt;</span></span><br><span class="line"><span class="comment">	&lt;success&gt;true&lt;/success&gt;</span></span><br><span class="line"><span class="comment">	&lt;msg&gt;这是XML数据&lt;msg&gt;</span></span><br><span class="line"><span class="comment">&lt;/map&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）HTML模板"><a href="#（4）HTML模板" class="headerlink" title="（4）HTML模板"></a>（4）HTML模板</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.LoadHTMLGlob(<span class="string">&quot;templates/*&quot;</span>)</span><br><span class="line">c.HTML(code, <span class="string">&quot;HTML文件名&quot;</span>, gin.H&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;这是title&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;.title&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>templates目录下有多级目录</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-templates</span></span><br><span class="line"><span class="comment">	-admin</span></span><br><span class="line"><span class="comment">		-index.html</span></span><br><span class="line"><span class="comment">  -shop</span></span><br><span class="line"><span class="comment">		-index.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">r.LoadHTMLGlob(<span class="string">&quot;templates/**/*&quot;</span>)</span><br><span class="line">c.HTML(code, <span class="string">&quot;default/index.html&quot;</span>, gin.H&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;这是title&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用define定义文件名 --&gt;</span></span><br><span class="line">&#123;&#123; define: &quot;default/index.html&quot; &#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;.title&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）静态文件"><a href="#（5）静态文件" class="headerlink" title="（5）静态文件"></a>（5）静态文件</h3><p>HTML引入了静态文件的，需要配置静态web服务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.Status(<span class="string">&quot;静态文件路由&quot;</span>, <span class="string">&quot;静态文件地址&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3、请求参数"><a href="#3、请求参数" class="headerlink" title="3、请求参数"></a>3、请求参数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">  UserName <span class="type">string</span> <span class="string">`json:&quot;username&quot; form:&quot;username&quot; xml:&quot;username&quot;`</span></span><br><span class="line">  Age <span class="type">string</span> <span class="string">`json:&quot;username&quot; form:&quot;username&quot; xml:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（1）get"><a href="#（1）get" class="headerlink" title="（1）get"></a>（1）get</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://xxx/getInfo?username=admin&amp;age=18</span></span><br><span class="line">r.GET(<span class="string">&quot;/getInfo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  username := c.Query(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">  age := c.Query(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">  page := c.DefaultQuery(<span class="string">&quot;page&quot;</span>, <span class="string">&quot;1&quot;</span>) <span class="comment">// 默认传参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数绑定到结构体</span></span><br><span class="line">r.GET(<span class="string">&quot;/getInfo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  user := &amp;UserInfo&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> err := c.ShouldBind(&amp;user); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    c.JSON(code, user)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c.JSON(code, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;err&quot;</span>: err.Error(),</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）post"><a href="#（2）post" class="headerlink" title="（2）post"></a>（2）post</h3><h4 id="获取表单数据"><a href="#获取表单数据" class="headerlink" title="获取表单数据"></a>获取表单数据</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/getInfo&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">  年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.Post(<span class="string">&quot;/getInfo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  username := c.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">  age := c.PostForm(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">  page := c.DefaultPostForm(<span class="string">&quot;page&quot;</span>, <span class="string">&quot;1&quot;</span>) <span class="comment">// 默认传参，没有传这个参数就会使用默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数绑定到结构体</span></span><br><span class="line">r.Post(<span class="string">&quot;/getInfo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  user := &amp;UserInfo&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> err := c.Bind(&amp;user); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    c.JSON(code, user)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c.JSON(code, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;err&quot;</span>: err.Error(),</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取XML数据"><a href="#获取XML数据" class="headerlink" title="获取XML数据"></a>获取XML数据</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?XML version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">username</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">age</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>&gt;</span>18<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.Post(<span class="string">&quot;/xml&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  xmlSlice, err := c.GetRawData()</span><br><span class="line">  user := &amp;UserInfo&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err1 := xml.Unmarshal(xmlSlice, &amp;user); <span class="type">error</span> == <span class="literal">nil</span> &#123;</span><br><span class="line">      c.JSON(code, user)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      c.JSON(code, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;err&quot;</span>: err1.Error(),</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c.JSON(code, gin.H&#123;</span><br><span class="line">      <span class="string">&quot;err&quot;</span>: err.Error(),</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）动态路由"><a href="#（3）动态路由" class="headerlink" title="（3）动态路由"></a>（3）动态路由</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/user/:uid&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  uid := c.Param(<span class="string">&quot;uid&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、路由组"><a href="#4、路由组" class="headerlink" title="4、路由组"></a>4、路由组</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  router := gin.Default()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 简单的路由组: v1</span></span><br><span class="line">  v1 := router.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    v1.POST(<span class="string">&quot;/login&quot;</span>, loginEndpoint)</span><br><span class="line">    v1.POST(<span class="string">&quot;/submit&quot;</span>, submitEndpoint)</span><br><span class="line">    v1.POST(<span class="string">&quot;/read&quot;</span>, readEndpoint)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 简单的路由组: v2</span></span><br><span class="line">  v2 := router.Group(<span class="string">&quot;/v2&quot;</span>, 中间件<span class="number">1</span>, 中间件<span class="number">2</span> ...)</span><br><span class="line">  <span class="comment">// v2.use(中间件1, 中间件2 ...)</span></span><br><span class="line">  &#123;</span><br><span class="line">    v2.POST(<span class="string">&quot;/login&quot;</span>, loginEndpoint)</span><br><span class="line">    v2.POST(<span class="string">&quot;/submit&quot;</span>, submitEndpoint)</span><br><span class="line">    v2.POST(<span class="string">&quot;/read&quot;</span>, readEndpoint)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、中间件"><a href="#5、中间件" class="headerlink" title="5、中间件"></a>5、中间件</h2><p>中间件：匹配路由前和匹配路由完成后执行的一系列操作。</p>
<h3 id="（1）局部中间件"><a href="#（1）局部中间件" class="headerlink" title="（1）局部中间件"></a>（1）局部中间件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在最后一个函数前的所有函数都代表中间件。</span></span><br><span class="line">r.GET(<span class="string">&quot;/xml&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;... <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;&#125;</span><br><span class="line">r.POST(<span class="string">&quot;/xml&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;... <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）Next"><a href="#（2）Next" class="headerlink" title="（2）Next"></a>（2）Next</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/xml&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 中间件开始执行的操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 执行当前中间件的下一个函数</span></span><br><span class="line">  c.Next()</span><br><span class="line">  <span class="comment">// 中间件执行完成后续操作</span></span><br><span class="line">  ...</span><br><span class="line">&#125;... <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个中间件</span></span><br><span class="line">r.GET(<span class="string">&quot;/xml&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;这是第一个中间件开始&quot;</span>)</span><br><span class="line">  c.Next()</span><br><span class="line">  fmt.Println(<span class="string">&quot;这是第一个中间件结束&quot;</span>)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;这是第二个中间件开始&quot;</span>)</span><br><span class="line">  c.Next()</span><br><span class="line">  fmt.Println(<span class="string">&quot;这是第二个中间件结束&quot;</span>)</span><br><span class="line">&#125;... <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>) &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;路由操作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是第一个中间件开始</span></span><br><span class="line"><span class="comment">这是第二个中间件开始</span></span><br><span class="line"><span class="comment">路由操作</span></span><br><span class="line"><span class="comment">这是第二个中间件结束</span></span><br><span class="line"><span class="comment">这是第一个中间件结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）全局中间件"><a href="#（3）全局中间件" class="headerlink" title="（3）全局中间件"></a>（3）全局中间件</h3><p>所有路由函数都会执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.use(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="（4）数据共享"><a href="#（4）数据共享" class="headerlink" title="（4）数据共享"></a>（4）数据共享</h3><p>中间件与中间件、控制器之间的数据传递。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c.Set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;go&quot;</span>)</span><br><span class="line">username, err := c.Get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">v, ok := username(.<span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<h3 id="（5）Logger和Recovery"><a href="#（5）Logger和Recovery" class="headerlink" title="（5）Logger和Recovery"></a>（5）Logger和Recovery</h3><p>使用<code>gin.Default</code>创建路由默认带有<code>Logger</code>和<code>Recovery</code>中间件：</p>
<ul>
<li><code>Logger</code>：将日志写入<code>gin.DefaultWriter</code>。</li>
<li><code>Recovery</code>：<code>recover</code>任何<code>panic</code>，如果有<code>panic</code>的话，就会写入<code>500</code>响应码。</li>
</ul>
<p>如果不想使用这两个中间件，可以使用<code>gin.New</code>创建路由。</p>
<h3 id="（6）中间件使用goroutine"><a href="#（6）中间件使用goroutine" class="headerlink" title="（6）中间件使用goroutine"></a>（6）中间件使用goroutine</h3><p>当在中间件或<code>handler</code>中启动新的<code>Goroutine</code>时，<strong>不能</strong>使用原始的上下文，必须使用只读副本。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;/long_async&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 创建在 goroutine 中使用的副本</span></span><br><span class="line">		cCp := c.Copy()</span><br><span class="line">    <span class="comment">// 不需要使用wg.Done()结束任务，因为主程序一直开启。</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 用 time.Sleep() 模拟一个长任务。</span></span><br><span class="line">			time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 请注意您使用的是复制的上下文 &quot;cCp&quot;，这一点很重要</span></span><br><span class="line">			log.Println(<span class="string">&quot;Done! in path &quot;</span> + cCp.Request.URL.Path)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;/long_sync&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 用 time.Sleep() 模拟一个长任务。</span></span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 因为没有使用 goroutine，不需要拷贝上下文</span></span><br><span class="line">		log.Println(<span class="string">&quot;Done! in path &quot;</span> + c.Request.URL.Path)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（7）重定向"><a href="#（7）重定向" class="headerlink" title="（7）重定向"></a>（7）重定向</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Redirect</span></span><br><span class="line">r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  c.Redirect(code, <span class="string">&quot;重定向地址&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// HandleContext</span></span><br><span class="line">r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.Request.URL.Path = <span class="string">&quot;重定向地址&quot;</span></span><br><span class="line">    r.HandleContext(c)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="6、文件上传"><a href="#6、文件上传" class="headerlink" title="6、文件上传"></a>6、文件上传</h2><h3 id="（1）单文件上传"><a href="#（1）单文件上传" class="headerlink" title="（1）单文件上传"></a>（1）单文件上传</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  r := gin.Default()</span><br><span class="line">  <span class="comment">//限制上传最大尺寸</span></span><br><span class="line">  r.MaxMultipartMemory = <span class="number">8</span> &lt;&lt; <span class="number">20</span></span><br><span class="line">  r.POST(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// file：input文件输入框的name</span></span><br><span class="line">    file, err := c.FormFile(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      c.String(<span class="number">500</span>, <span class="string">&quot;上传图片出错&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存上传的文件至指定文件地址</span></span><br><span class="line">    dst := <span class="string">&quot;./&quot;</span> + file.Filename</span><br><span class="line">    c.SaveUploadedFile(file, dst)</span><br><span class="line">    c.String(http.StatusOK, file.Filename)</span><br><span class="line">  &#125;)</span><br><span class="line">  r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）多文件上传"><a href="#（2）多文件上传" class="headerlink" title="（2）多文件上传"></a>（2）多文件上传</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	<span class="comment">// 为 multipart forms 设置较低的内存限制 (默认是 32 MiB)</span></span><br><span class="line">	r.MaxMultipartMemory = <span class="number">8</span> &lt;&lt; <span class="number">20</span>  <span class="comment">// 8 MiB</span></span><br><span class="line">	r.POST(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// Multipart form</span></span><br><span class="line">		form, _ := c.MultipartForm()</span><br><span class="line">    <span class="comment">// upload[]：input文件输入框的name</span></span><br><span class="line">		files := form.File[<span class="string">&quot;upload[]&quot;</span>]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">			log.Println(file.Filename)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 上传文件至指定目录</span></span><br><span class="line">			dst := <span class="string">&quot;./&quot;</span> + file.Filename</span><br><span class="line">			c.SaveUploadedFile(file, dst)</span><br><span class="line">		&#125;</span><br><span class="line">		c.String(http.StatusOK, fmt.Sprintf(<span class="string">&quot;%d files uploaded!&quot;</span>, <span class="built_in">len</span>(files)))</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、Cookie"><a href="#7、Cookie" class="headerlink" title="7、Cookie"></a>7、Cookie</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1.创建路由</span></span><br><span class="line">  <span class="comment">// 默认使用了2个中间件Logger(), Recovery()</span></span><br><span class="line">  r := gin.Default()</span><br><span class="line">  <span class="comment">// 服务端要给客户端cookie</span></span><br><span class="line">  r.GET(<span class="string">&quot;cookie&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取客户端是否携带cookie</span></span><br><span class="line">    cookie, err := c.Cookie(<span class="string">&quot;key_cookie&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      cookie = <span class="string">&quot;NotSet&quot;</span></span><br><span class="line">      <span class="comment">// 给客户端设置cookie：</span></span><br><span class="line">      <span class="comment">// name：cookie名称</span></span><br><span class="line">      <span class="comment">// value string：cookie的值</span></span><br><span class="line">      <span class="comment">// maxAge int：过期时间，单位为秒，-1表示删除cookie</span></span><br><span class="line">      <span class="comment">// path：cookie所在目录</span></span><br><span class="line">      <span class="comment">// domain string：域名，&quot;.wongzeonwai&quot;前面加.表示二级域名也设置cookie</span></span><br><span class="line">      <span class="comment">// secure bool：是否只能通过https访问</span></span><br><span class="line">      <span class="comment">// httpOnly bool：是否允许别人通过客户端获取自己的cookie</span></span><br><span class="line">      c.SetCookie(<span class="string">&quot;key_cookie&quot;</span>, <span class="string">&quot;value_cookie&quot;</span>, <span class="number">60</span>, <span class="string">&quot;/&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;localhost&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;cookie的值是： %s\n&quot;</span>, cookie)</span><br><span class="line">  &#125;)</span><br><span class="line">  r.Run(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、Session"><a href="#8、Session" class="headerlink" title="8、Session"></a>8、Session</h2><p>gorilla&#x2F;sessions为自定义session后端提供cookie和文件系统session以及基础结构。</p>
<p>主要功能是：</p>
<ul>
<li>简单的API：将其用作设置签名（以及可选的加密）cookie的简便方法。</li>
<li>内置的后端可将session存储在cookie或文件系统中。</li>
<li>Flash消息：一直持续读取的session值。</li>
<li>切换session持久性（又称“记住我”）和设置其他属性的便捷方法。</li>
<li>旋转身份验证和加密密钥的机制。</li>
<li>每个请求有多个session，即使使用不同的后端也是如此。</li>
<li>自定义session后端的接口和基础结构：可以使用通用API检索并批量保存来自不同商店的session。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gorilla/sessions&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个cookie存储对象</span></span><br><span class="line"><span class="comment">// something-very-secret应该是一个你自己的密匙，只要不被别人知道就行</span></span><br><span class="line"><span class="keyword">var</span> store = sessions.NewCookieStore([]<span class="type">byte</span>(<span class="string">&quot;something-very-secret&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/save&quot;</span>, SaveSession)</span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/get&quot;</span>, GetSession)</span><br><span class="line">  err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;HTTP server failed,err:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveSession</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Get a session. We&#x27;re ignoring the error resulted from decoding an</span></span><br><span class="line">  <span class="comment">// existing session: Get() always returns a session, even if empty.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//　获取一个session对象，session-name是session的名字</span></span><br><span class="line">  session, err := store.Get(r, <span class="string">&quot;session-name&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在session中存储值</span></span><br><span class="line">  session.Values[<span class="string">&quot;foo&quot;</span>] = <span class="string">&quot;bar&quot;</span></span><br><span class="line">  session.Values[<span class="number">42</span>] = <span class="number">43</span></span><br><span class="line">  <span class="comment">// 保存更改</span></span><br><span class="line">  session.Save(r, w)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSession</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  session, err := store.Get(r, <span class="string">&quot;session-name&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  foo := session.Values[<span class="string">&quot;foo&quot;</span>]</span><br><span class="line">  fmt.Println(foo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、go-ini"><a href="#9、go-ini" class="headerlink" title="9、go-ini"></a>9、go-ini</h2><p>使用<code>go-ini</code>操作<code>ini</code>文件。</p>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>GO学习笔记</title>
    <url>/2024/08/07/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、Go-基础"><a href="#一、Go-基础" class="headerlink" title="一、Go 基础"></a>一、Go 基础</h1><h2 id="1、Go-的-25-个关键字"><a href="#1、Go-的-25-个关键字" class="headerlink" title="1、Go 的 25 个关键字"></a>1、Go 的 25 个关键字</h2><table>
     <tr>
        <td>break</td>
        <td>default</td>
        <td>func</td>
        <td>interface</td>
        <td>select</td>
    </tr>
     <tr>
        <td>case</td>
        <td>defer</td>
        <td>go</td>
        <td>map</td>
        <td>struct</td>
    </tr>
     <tr>
        <td>chan</td>
        <td>else</td>
        <td>goto</td>
        <td>package</td>
        <td>switch</td>
    </tr>
     <tr>
        <td>const</td>
        <td>fallthrough</td>
        <td>if</td>
        <td>range</td>
        <td>type</td>
    </tr>
     <tr>
        <td>continue</td>
        <td>for</td>
        <td>import</td>
        <td>return</td>
        <td>var</td>
    </tr>
</table>

<h2 id="2、Go-的-36-个预定义标识符："><a href="#2、Go-的-36-个预定义标识符：" class="headerlink" title="2、Go 的 36 个预定义标识符："></a>2、Go 的 36 个预定义标识符：</h2><table>
    <tr>
        <td>append</td>
        <td>bool</td>
        <td>byte</td>
        <td>cap</td>
        <td>close</td>
        <td>complex</td>
        <td>complex64</td>
        <td>complex128</td>
        <td>uint16</td>
    </tr>
    <tr>
        <td>copy</td>
        <td>false</td>
        <td>float32</td>
        <td>float64</td>
        <td>imag</td>
        <td>int</td>
        <td>int8</td>
        <td>int16</td>
        <td>uint32</td>
    </tr>
    <tr>
        <td>int32</td>
        <td>int64</td>
        <td>iota</td>
        <td>len</td>
        <td>make</td>
        <td>new</td>
        <td>nil</td>
        <td>panic</td>
        <td>uint64</td>
    </tr>
    <tr>
        <td>print</td>
        <td>println</td>
        <td>real</td>
        <td>recover</td>
        <td>string</td>
        <td>true</td>
        <td>uint</td>
        <td>uint8</td>
        <td>uintptr</td>
    </tr>
</table>



<h2 id="3、Go-的基本数据类型"><a href="#3、Go-的基本数据类型" class="headerlink" title="3、Go 的基本数据类型"></a>3、Go 的基本数据类型</h2><h3 id="（1）布尔类型"><a href="#（1）布尔类型" class="headerlink" title="（1）布尔类型"></a>（1）布尔类型</h3><p>使用 <strong>boolean</strong> 声明的类型，只有 <strong>true（真）和 false（假）</strong>两种值。默认值为 <code>false</code>。</p>
<h3 id="（2）数字类型"><a href="#（2）数字类型" class="headerlink" title="（2）数字类型"></a>（2）数字类型</h3><p>包括整型和浮点型以及其他数据类型。</p>
<h4 id="整型（默认值为-0）："><a href="#整型（默认值为-0）：" class="headerlink" title="整型（默认值为 0）："></a>整型（默认值为 0）：</h4><table>
<thead>
<tr>
<th>类型</th>
<th>长度（字节）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>4</td>
<td>有符号 32 位整型</td>
</tr>
<tr>
<td>int8</td>
<td>1</td>
<td>有符号 8 位整型（-128 ~ 128）</td>
</tr>
<tr>
<td>int16</td>
<td>2</td>
<td>有符号 16 位整型（-32768 ~ 32767）</td>
</tr>
<tr>
<td>int32</td>
<td>4</td>
<td>有符号 32 位整型（-2147483648 ~ 2147483647）</td>
</tr>
<tr>
<td>int64</td>
<td>8</td>
<td>有符号 64 位整型（-9223372036854775808 ~ 9223372036854775807）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度（字节）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>uint</td>
<td>4</td>
<td>无符号 32 位整型</td>
</tr>
<tr>
<td>uint8</td>
<td>1</td>
<td>无符号 8 位整型（0 ~ 255）</td>
</tr>
<tr>
<td>uint16</td>
<td>2</td>
<td>无符号 16 位整型（0 ~ 65535）</td>
</tr>
<tr>
<td>uint32</td>
<td>4</td>
<td>无符号 32 位整型（0 ~ 4294967295）</td>
</tr>
<tr>
<td>uint64</td>
<td>8</td>
<td>无符号 64 位整型（0 ~ 18446744073709551615）</td>
</tr>
</tbody></table>
<h4 id="浮点型："><a href="#浮点型：" class="headerlink" title="浮点型："></a>浮点型：</h4><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>float32</td>
<td>32 位浮点型数，默认值为 0</td>
</tr>
<tr>
<td>float64</td>
<td>64 位浮点型数，默认值为 0</td>
</tr>
<tr>
<td>complex64</td>
<td>32 位实数和虚数</td>
</tr>
<tr>
<td>complex128</td>
<td>64 位实数和虚数</td>
</tr>
</tbody></table>
<h4 id="其他数字类型："><a href="#其他数字类型：" class="headerlink" title="其他数字类型："></a>其他数字类型：</h4><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>uint8，默认值为 0</td>
</tr>
<tr>
<td>rune</td>
<td>Unicode Code Point, int32，默认值为 0</td>
</tr>
<tr>
<td>uintptr</td>
<td>以存储指针的 uint32 或 uint64 整数</td>
</tr>
</tbody></table>
<h3 id="（3）字符串类型："><a href="#（3）字符串类型：" class="headerlink" title="（3）字符串类型："></a>（3）字符串类型：</h3><p>使用 string 声明的 UTF-8 字符串。默认值为<code>&quot;&quot;</code>。</p>
<h4 id="字符串转义符："><a href="#字符串转义符：" class="headerlink" title="字符串转义符："></a>字符串转义符：</h4><table>
<thead>
<tr>
<th>转义</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\r</td>
<td>回车符（返回行首）</td>
</tr>
<tr>
<td>\n</td>
<td>换行符（直接跳到下一行的同列位置）</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>&#39;</td>
<td>单引号</td>
</tr>
<tr>
<td>&quot;</td>
<td>双引号</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
</tr>
</tbody></table>
<p>Go 语言中要定义一个多行字符串时，就必须使用反引号字符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">    第二行</span></span><br><span class="line"><span class="string">    第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一行</span></span><br><span class="line"><span class="comment">                第二行</span></span><br><span class="line"><span class="comment">                第三\&#x27;行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>但是在多行字符串中转义字符无法生效。</p>
<h4 id="字符串常用方法："><a href="#字符串常用方法：" class="headerlink" title="字符串常用方法："></a>字符串常用方法：</h4><table>
<thead>
<tr>
<th>方法</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>len(str)</td>
<td>求长度</td>
</tr>
<tr>
<td>+或fmt.Sprintf</td>
<td>拼接字符串</td>
</tr>
<tr>
<td>strings.Split</td>
<td>分割字符串为切片</td>
</tr>
<tr>
<td>strings.Contains</td>
<td>判断是否包含</td>
</tr>
<tr>
<td>strings.HasPrefix,strings.HasSuffix</td>
<td>前缀&#x2F;后缀判断</td>
</tr>
<tr>
<td>strings.Index(),strings.LastIndex()</td>
<td>子串出现的位置</td>
</tr>
<tr>
<td>strings.Join(a[]string, sep string)</td>
<td>切片连接成字符串</td>
</tr>
</tbody></table>
<h3 id="（4）其他类型："><a href="#（4）其他类型：" class="headerlink" title="（4）其他类型："></a>（4）其他类型：</h3><ul>
<li>指针类型（Pointer）：默认值为 <code>nil</code></li>
<li>数组类型（array）</li>
<li>结构化类型（struct）</li>
<li>Channel 类型（channel）：默认值为 <code>nil</code></li>
<li>函数类型（function）：默认值为 <code>nil</code></li>
<li>切片类型（slice）：默认值为 <code>nil</code></li>
<li>接口类型（interface）：默认值为 <code>nil</code></li>
<li>Map 类型（map）：默认值为 <code>nil</code></li>
</ul>
<h2 id="4、运算符"><a href="#4、运算符" class="headerlink" title="4、运算符"></a>4、运算符</h2><h3 id="（1）算术运算符"><a href="#（1）算术运算符" class="headerlink" title="（1）算术运算符"></a>（1）算术运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>相加</td>
</tr>
<tr>
<td>-</td>
<td>相减</td>
</tr>
<tr>
<td>*</td>
<td>相乘</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>相除</td>
</tr>
<tr>
<td>%</td>
<td>求余</td>
</tr>
</tbody></table>
<h3 id="（2）关系运算符"><a href="#（2）关系运算符" class="headerlink" title="（2）关系运算符"></a>（2）关系运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>检查两个值是否相等，如果相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td>&gt;</td>
<td>检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td>&lt;</td>
<td>检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
</tbody></table>
<h3 id="（3）逻辑运算符"><a href="#（3）逻辑运算符" class="headerlink" title="（3）逻辑运算符"></a>（3）逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td>ll</td>
<td>逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td>!</td>
<td>逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td>
</tr>
</tbody></table>
<h3 id="（4）位运算符"><a href="#（4）位运算符" class="headerlink" title="（4）位运算符"></a>（4）位运算符</h3><p>位运算符对整数在内存中的二进制位进行操作。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>参与运算的两数各对应的二进位相与。（两位均为 1 才为 1 ）</td>
</tr>
<tr>
<td>l</td>
<td>参与运算的两数各对应的二进位相或。（两位有一个为 1 就为 1 ）</td>
</tr>
<tr>
<td>^</td>
<td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为 1。（两位不一样则为 1）</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移 n 位就是乘以 2 的 n 次方。“a&lt;&lt;b”是把 a 的各二进位全部左移 b 位，高位丢弃，低位补 0。</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移 n 位就是除以 2 的 n 次方。“a&gt;&gt;b”是把 a 的各二进位全部右移 b 位。</td>
</tr>
</tbody></table>
<h3 id="（5）赋值运算符"><a href="#（5）赋值运算符" class="headerlink" title="（5）赋值运算符"></a>（5）赋值运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>简单的赋值运算符，将一个表达式的值赋给一个左值</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>相加后再赋值</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>相减后再赋值</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>相乘后再赋值</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>相除后再赋值</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>求余后再赋值</td>
</tr>
<tr>
<td>&lt;&lt;&#x3D;</td>
<td>左移后赋值</td>
</tr>
<tr>
<td>&gt;&gt;&#x3D;</td>
<td>右移后赋值</td>
</tr>
<tr>
<td>&amp;&#x3D;</td>
<td>按位与后赋值</td>
</tr>
<tr>
<td>l&#x3D;</td>
<td>按位或后赋值</td>
</tr>
<tr>
<td>^&#x3D;</td>
<td>按位异或后赋值</td>
</tr>
</tbody></table>
<h2 id="5、常用标准库"><a href="#5、常用标准库" class="headerlink" title="5、常用标准库"></a>5、常用标准库</h2><h3 id="（1）fmt"><a href="#（1）fmt" class="headerlink" title="（1）fmt"></a>（1）fmt</h3><h4 id="Print、Printf、Println"><a href="#Print、Printf、Println" class="headerlink" title="Print、Printf、Println"></a>Print、Printf、Println</h4><p>Print系列函数会将内容输出到系统的标准输出，区别在于 Print 函数直接输出内容，Printf 函数支持格式化输出字符串，Println 函数会在输出内容的结尾添加一个换行符。</p>
<h5 id="通用占位符"><a href="#通用占位符" class="headerlink" title="通用占位符"></a>通用占位符</h5><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%v</td>
<td>值的默认格式表示</td>
</tr>
<tr>
<td>%+v</td>
<td>类似 %v，但输出结构体时会添加字段名</td>
</tr>
<tr>
<td>%#v</td>
<td>值的 Go 语法表示</td>
</tr>
<tr>
<td>%T</td>
<td>打印值的类型</td>
</tr>
<tr>
<td>%%</td>
<td>百分号</td>
</tr>
</tbody></table>
<h5 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h5><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%t</td>
<td>true 或 false</td>
</tr>
</tbody></table>
<h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%b</td>
<td>表示为二进制</td>
</tr>
<tr>
<td>%c</td>
<td>该值对应的 unicode 码值</td>
</tr>
<tr>
<td>%d</td>
<td>表示为十进制</td>
</tr>
<tr>
<td>%o</td>
<td>表示为八进制</td>
</tr>
<tr>
<td>%x</td>
<td>表示为十六进制，使用 a-f</td>
</tr>
<tr>
<td>%X</td>
<td>表示为十六进制，使用 A-F</td>
</tr>
<tr>
<td>%U</td>
<td>表示为 Unicode 格式：U+1234，等价于 ”U+%04X”</td>
</tr>
<tr>
<td>%q</td>
<td>该值对应的单引号括起来的 go 语法字符字面值，必要时会采用安全的转义表示</td>
</tr>
</tbody></table>
<h5 id="浮点数与复数"><a href="#浮点数与复数" class="headerlink" title="浮点数与复数"></a>浮点数与复数</h5><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%b</td>
<td>无小数部分、二进制指数的科学计数法，如 -123456p-78</td>
</tr>
<tr>
<td>%e</td>
<td>科学计数法，如 -1234.456e+78</td>
</tr>
<tr>
<td>%E</td>
<td>科学计数法，如 -1234.456E+78</td>
</tr>
<tr>
<td>%f</td>
<td>有小数部分但无指数部分，如 123.456</td>
</tr>
<tr>
<td>%F</td>
<td>等价于 %f</td>
</tr>
<tr>
<td>%g</td>
<td>根据实际情况采用 %e 或 %f 格式（以获得更简洁、准确的输出）</td>
</tr>
<tr>
<td>%G</td>
<td>根据实际情况采用 %E 或 %F 格式（以获得更简洁、准确的输出）</td>
</tr>
</tbody></table>
<h5 id="字符串和-byte"><a href="#字符串和-byte" class="headerlink" title="字符串和[]byte"></a>字符串和[]byte</h5><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>直接输出字符串或者 []byte</td>
</tr>
<tr>
<td>%q</td>
<td>该值对应的双引号括起来的 go 语法字符串字面值，必要时会采用安全的转义表示</td>
</tr>
<tr>
<td>%x</td>
<td>每个字节用两字符十六进制数表示（使用 a-f）</td>
</tr>
<tr>
<td>%X</td>
<td>每个字节用两字符十六进制数表示（使用 A-F）</td>
</tr>
</tbody></table>
<h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%p</td>
<td>表示为十六进制，并加上前导的 0x</td>
</tr>
</tbody></table>
<h5 id="宽度标识符"><a href="#宽度标识符" class="headerlink" title="宽度标识符"></a>宽度标识符</h5><p>宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为 0。举例如下</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%f</td>
<td>默认宽度，默认精度</td>
</tr>
<tr>
<td>%9f</td>
<td>宽度 9，默认精度</td>
</tr>
<tr>
<td>%.2f</td>
<td>默认宽度，精度 2</td>
</tr>
<tr>
<td>%9.2f</td>
<td>宽度 9，精度 2</td>
</tr>
<tr>
<td>%9.f</td>
<td>宽度 9，精度 0</td>
</tr>
</tbody></table>
<h3 id="（2）time"><a href="#（2）time" class="headerlink" title="（2）time"></a>（2）time</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  now := time.Now() <span class="comment">//获取当前时间</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;current time:%v\n&quot;</span>, now)</span><br><span class="line"></span><br><span class="line">  year := now.Year()     <span class="comment">//年</span></span><br><span class="line">  month := now.Month()   <span class="comment">//月</span></span><br><span class="line">  day := now.Day()       <span class="comment">//日</span></span><br><span class="line">  hour := now.Hour()     <span class="comment">//小时</span></span><br><span class="line">  minute := now.Minute() <span class="comment">//分钟</span></span><br><span class="line">  second := now.Second() <span class="comment">//秒</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year, month, day, hour, minute, second)</span><br><span class="line"></span><br><span class="line">  timestamp1 := now.Unix()     <span class="comment">//时间戳</span></span><br><span class="line">  timestamp2 := now.UnixNano() <span class="comment">//纳秒时间戳</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;current timestamp1:%v\n&quot;</span>, timestamp1)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;current timestamp2:%v\n&quot;</span>, timestamp2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间戳转换日期"><a href="#时间戳转换日期" class="headerlink" title="时间戳转换日期"></a>时间戳转换日期</h4><p>使用 Unix 函数将时间戳转换为时间格式，第一个参数为毫秒时间戳，第二个参数为纳秒时间戳。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timestampDemo2</span><span class="params">(timestamp <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">    timeObj := time.Unix(timestamp, <span class="number">0</span>) <span class="comment">//将时间戳转为时间格式</span></span><br><span class="line">    fmt.Println(timeObj)</span><br><span class="line">    year := timeObj.Year()     <span class="comment">//年</span></span><br><span class="line">    month := timeObj.Month()   <span class="comment">//月</span></span><br><span class="line">    day := timeObj.Day()       <span class="comment">//日</span></span><br><span class="line">    hour := timeObj.Hour()     <span class="comment">//小时</span></span><br><span class="line">    minute := timeObj.Minute() <span class="comment">//分钟</span></span><br><span class="line">    second := timeObj.Second() <span class="comment">//秒</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year, month, day, hour, minute, second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间常量"><a href="#时间常量" class="headerlink" title="时间常量"></a>时间常量</h4><p>time.Duration 是 time 包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。time.Duration 表示一段时间间隔，可表示的最长时间段大约 290 年。</p>
<p>time包中定义的时间间隔类型的常量如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">  Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">  Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">  Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">  Minute               = <span class="number">60</span> * Second</span><br><span class="line">  Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>例如：time.Duration 表示 1 纳秒，time.Second 表示 1 秒。</p>
<h4 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Add(d Duration) Time</span><br></pre></td></tr></table></figure>

<p>求一个小时之后的时间：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    now := time.Now()</span><br><span class="line">    later := now.Add(time.Hour) <span class="comment">// 当前时间加1小时后的时间</span></span><br><span class="line">    fmt.Println(later)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Sub"><a href="#Sub" class="headerlink" title="Sub"></a>Sub</h4><p>求两个时间之间的差值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span></span> Sub(u Time) Duration</span><br></pre></td></tr></table></figure>

<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>使用 time.Tick（时间间隔）来设置定时器，定时器的本质上是一个通道（channel）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tickDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ticker := time.NewTicker(time.Second) <span class="comment">//定义一个1秒间隔的定时器</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">    fmt.Println(i)<span class="comment">//每秒都会执行的任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h4><p>使用 Format 函数传入格式化模板（2006 1 2 3 4 Mon Jan），如果想格式化为 12 小时方式，需指定 PM。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  now := time.Now()</span><br><span class="line">  <span class="comment">// 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan</span></span><br><span class="line">  <span class="comment">// 24小时制</span></span><br><span class="line">  fmt.Println(now.Format(<span class="string">&quot;2006-01-02 15:04:05.000 Mon Jan&quot;</span>))</span><br><span class="line">  <span class="comment">// 12小时制</span></span><br><span class="line">  fmt.Println(now.Format(<span class="string">&quot;2006-01-02 03:04:05.000 PM Mon Jan&quot;</span>))</span><br><span class="line">  fmt.Println(now.Format(<span class="string">&quot;2006/01/02 15:04&quot;</span>))</span><br><span class="line">  fmt.Println(now.Format(<span class="string">&quot;15:04 2006/01/02&quot;</span>))</span><br><span class="line">  fmt.Println(now.Format(<span class="string">&quot;2006/01/02&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）reflect"><a href="#（3）reflect" class="headerlink" title="（3）reflect"></a>（3）reflect</h3><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ul>
<li>反射是指在程序运行期对程序本身进行访问和修改的能力。</li>
<li><code>reflect </code> 包封装了反射相关的方法。</li>
<li>获取类型信息：<code>reflect.TypeOf</code>，是静态的。</li>
<li>获取值信息：<code>reflect.ValueOf</code>，是动态的。</li>
<li>获取类型名称：<code>reflect.Name</code></li>
<li>获取类型种类：<code>reflect.Kind</code>，底层的具体类型。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectFn</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  v := reflect.TypeOf(x)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;类型：%v，类型名称：%v，类型种类：%v&quot;</span>, v, v.Name(), v.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := <span class="number">10</span></span><br><span class="line">  b := <span class="number">23.4</span></span><br><span class="line">  c := <span class="literal">true</span></span><br><span class="line">  d := <span class="string">&quot;test&quot;</span></span><br><span class="line">  <span class="keyword">var</span> e myInt = <span class="number">12</span></span><br><span class="line">  <span class="keyword">var</span> f = Person&#123;</span><br><span class="line">    Name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    Age: <span class="number">12</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  i := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">  j := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">  reflectFn(a) <span class="comment">// 类型：int，类型名称：int，类型种类：int</span></span><br><span class="line">  reflectFn(b) <span class="comment">// 类型：float64，类型名称：float64，类型种类：float64</span></span><br><span class="line">  reflectFn(c) <span class="comment">// 类型：bool，类型名称：bool，类型种类：bool</span></span><br><span class="line">  reflectFn(d) <span class="comment">// 类型：string，类型名称：string，类型种类：string</span></span><br><span class="line">  reflectFn(e) <span class="comment">// 类型：main.myInt，类型名称：myInt，类型种类：int</span></span><br><span class="line">  reflectFn(f) <span class="comment">// 类型：main.Person，类型名称：Person，类型种类：struct</span></span><br><span class="line">  reflectFn(&amp;a) <span class="comment">// 类型：*int，类型名称：，类型种类：ptr</span></span><br><span class="line">  reflectFn(i) <span class="comment">// 类型：[3]int，类型名称：，类型种类：array</span></span><br><span class="line">  reflectFn(j) <span class="comment">// 类型：[]int，类型名称：，类型种类：slice</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取原始值"><a href="#获取原始值" class="headerlink" title="获取原始值"></a>获取原始值</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectFn</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  v := reflect.ValueOf(x)</span><br><span class="line">  kind := v.Kind()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">switch</span> kind &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Int64:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;原始值是：&quot;</span>, v.Int())</span><br><span class="line">    <span class="keyword">case</span> reflect.Float32:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;原始值是：&quot;</span>, v.Float())</span><br><span class="line">    <span class="keyword">case</span> reflect.Float64:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;原始值是：&quot;</span>, v.Float())</span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">    	fmt.Println(<span class="string">&quot;原始值是：&quot;</span>, v.String())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改值信息"><a href="#修改值信息" class="headerlink" title="修改值信息"></a>修改值信息</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射修改值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_set_value</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  v := reflect.ValueOf(a)</span><br><span class="line">  k := v.Kind()</span><br><span class="line">  <span class="keyword">switch</span> k &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Float64:</span><br><span class="line">    <span class="comment">// 反射修改值</span></span><br><span class="line">    v.SetFloat(<span class="number">6.9</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a is &quot;</span>, v.Float())</span><br><span class="line">    <span class="keyword">case</span> reflect.Ptr:</span><br><span class="line">    <span class="comment">// Elem()获取地址指向的值</span></span><br><span class="line">    v.Elem().SetFloat(<span class="number">7.9</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;case:&quot;</span>, v.Elem().Float())</span><br><span class="line">    <span class="comment">// 地址</span></span><br><span class="line">    fmt.Println(v.Pointer())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">  <span class="comment">// 反射认为下面是指针类型，不是float类型</span></span><br><span class="line">  reflect_set_value(&amp;x)</span><br><span class="line">  fmt.Println(<span class="string">&quot;main:&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反射与结构体"><a href="#反射与结构体" class="headerlink" title="反射与结构体"></a>反射与结构体</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span> <span class="string">`json:&quot;name&quot; form:&quot;username&quot;`</span></span><br><span class="line">  Age <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span></span> GetInfo() <span class="type">string</span> &#123;</span><br><span class="line">  str := fmt.Sprintf(<span class="string">&quot;姓名：%v 年龄：%v&quot;</span>, s.Name, s.Age)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> SetInfo(name <span class="type">string</span>, age <span class="type">int</span>) &#123;</span><br><span class="line">  s.Name = name</span><br><span class="line">  s.Age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintStructField</span><span class="params">(s <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  t := reflect.TypeOf(s)</span><br><span class="line">  v := reflect.ValueOf(s)</span><br><span class="line">  <span class="keyword">if</span> t.Kind() != reflect.Struct &amp;&amp; t.Elem().Kind() != reflect.Struct &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;传参不是结构体&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用Field方法可以通过结构体字段下标获取结构体中的字段</span></span><br><span class="line">  field0 := t.Field(<span class="number">0</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%#v&quot;</span>, field0) <span class="comment">// reflect.StructField&#123;Name:&quot;Name&quot;, PkgPath:&quot;&quot;, Type:(*reflect.rtype)(0x1003d80), Tag:&quot;json:\&quot;name\&quot; form:\&quot;username\&quot;&quot;, Offset:0x0, Index:[]int&#123;0&#125;, Anonymous:false&#125;</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;字段名称：&quot;</span>, field0.Name)</span><br><span class="line">  fmt.Println(<span class="string">&quot;字段类型：&quot;</span>, field0.Type)</span><br><span class="line">  fmt.Println(<span class="string">&quot;字段标签：&quot;</span>, field0.Tag)</span><br><span class="line">  fmt.Println(<span class="string">&quot;字段标签：&quot;</span>, field0.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用FieldByName方法可以通过结构体字段名获取结构体字段</span></span><br><span class="line">  field1, ok := t.FieldByName(<span class="string">&quot;Age&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v&quot;</span>, field01) <span class="comment">// reflect.StructField&#123;Name:&quot;Age&quot;, PkgPath:&quot;&quot;, Type:(*reflect.rtype)(0xdc51c0), Tag:&quot;json:\&quot;age\&quot;&quot;, Offset:0x10, Index:[]int&#123;1&#125;, Anonymous:false&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过NumField获取结构体字段个数</span></span><br><span class="line">  fieldCount := t.NumField()</span><br><span class="line">  fmt.Println(<span class="string">&quot;结构体有&quot;</span>, fieldCount, <span class="string">&quot;个字段&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过值信息获取结构体属性对应的值</span></span><br><span class="line">  fmt.Println(v.FieldByName(<span class="string">&quot;Name&quot;</span>))</span><br><span class="line">  fmt.Println(v.Field(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结构体方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintStructMethod</span><span class="params">(s <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  t := reflect.TypeOf(s)</span><br><span class="line">  v := reflect.ValueOf(s)</span><br><span class="line">  </span><br><span class="line">  method0 := t.Method(<span class="number">0</span>) <span class="comment">// 下标根据方法名的ASCII码排列，和编写顺序无关</span></span><br><span class="line">  fmt.Println(method0) <span class="comment">// &#123;GetInfo  func(main.Student) string &lt;func(main.Student) string Value&gt; 0&#125;</span></span><br><span class="line">  method1, ok := t.MethodByName(<span class="string">&quot;GetInfo&quot;</span>)</span><br><span class="line">  fmt.Println(method0) <span class="comment">// &#123;GetInfo  func(main.Student) string &lt;func(main.Student) string Value&gt; 0&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 执行方法</span></span><br><span class="line">  info := v.MethodByName(<span class="string">&quot;GetInfo&quot;</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">  fmt.Println(info) <span class="comment">// [姓名：test 年龄：12]</span></span><br><span class="line">  </span><br><span class="line">  params := []reflect.Value&#123;</span><br><span class="line">		reflect.ValueOf(<span class="string">&quot;李四&quot;</span>),</span><br><span class="line">		reflect.ValueOf(<span class="number">12</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	v.MethodByName(<span class="string">&quot;SetInfo&quot;</span>).Call(params)</span><br><span class="line"></span><br><span class="line">	info1 := v.MethodByName(<span class="string">&quot;GetInfo&quot;</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(info1) <span class="comment">// [姓名：李四 年龄：12]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取方法数量</span></span><br><span class="line">  fmt.Println(t.NumMethod())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  s := Student&#123;</span><br><span class="line">		Name: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">		Age:  <span class="number">12</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	PrintStructField(&amp;s) <span class="comment">// 修改参数必须传入地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）IO操作"><a href="#（4）IO操作" class="headerlink" title="（4）IO操作"></a>（4）IO操作</h3><h4 id="os包文件操作"><a href="#os包文件操作" class="headerlink" title="os包文件操作"></a>os包文件操作</h4><h5 id="文件打开方式："><a href="#文件打开方式：" class="headerlink" title="文件打开方式："></a>文件打开方式：</h5><table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>os.O_WRONLY</td>
<td>只写</td>
</tr>
<tr>
<td>os.O_CREATE</td>
<td>创建文件</td>
</tr>
<tr>
<td>os.O_RDONLY</td>
<td>只读</td>
</tr>
<tr>
<td>os.O_RDWR</td>
<td>读写</td>
</tr>
<tr>
<td>os.O_TRUNC</td>
<td>清空</td>
</tr>
<tr>
<td>os.O_APPEND</td>
<td>追加</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以只读方式打开文件</span></span><br><span class="line">file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close() <span class="comment">// 必须关闭文件流</span></span><br><span class="line"></span><br><span class="line">fmt.Println(file) <span class="comment">// 返回文件地址 &amp;&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件内容</span></span><br><span class="line"><span class="keyword">var</span> strSlice []<span class="type">byte</span></span><br><span class="line">tempSlice := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  n, err := file.Read(tempSlice)</span><br><span class="line">  <span class="comment">// 读到文件末尾会返回io.EOF错误</span></span><br><span class="line">  <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;读取完毕&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;读取完毕&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;读取到%v个字节&quot;</span>, n) <span class="comment">// 128</span></span><br><span class="line">  strSlice = <span class="built_in">append</span>(strSlice, tempSlice[:n]...)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(strSlice)) <span class="comment">// 完整的文件内容</span></span><br></pre></td></tr></table></figure>

<h5 id="perm："><a href="#perm：" class="headerlink" title="perm："></a>perm：</h5><p>文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。默认为 0666，所有人有所有权限。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读写文件</span></span><br><span class="line">file, err := os.OpenFile(<span class="string">&quot;./main.go&quot;</span>, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  file.WriteString(<span class="string">&quot;ab\n&quot;</span>)</span><br><span class="line">  file.Write([]<span class="type">byte</span>(<span class="string">&quot;cd\n&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := os.Mkdir(<span class="string">&quot;./abc&quot;</span>, <span class="number">0666</span>)</span><br><span class="line">err := os.Mkdir(<span class="string">&quot;./dir1/dir2/dir3&quot;</span>, <span class="number">0666</span>) <span class="comment">// 创建多级目录</span></span><br></pre></td></tr></table></figure>

<h5 id="删除文件夹或文件"><a href="#删除文件夹或文件" class="headerlink" title="删除文件夹或文件"></a>删除文件夹或文件</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := os.Remove(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">err := os.Remove(<span class="string">&quot;./dir&quot;</span>)</span><br><span class="line">err := os.RemoveAll(<span class="string">&quot;./dir&quot;</span>) <span class="comment">// 删除文件夹下所有文件</span></span><br></pre></td></tr></table></figure>

<h5 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := os.Rename(文件<span class="number">1</span>, 文件<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="通过bufio包读写文件"><a href="#通过bufio包读写文件" class="headerlink" title="通过bufio包读写文件"></a>通过bufio包读写文件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">&quot;./main.go&quot;</span>)</span><br><span class="line">reader := bufio.NewReader(file) <span class="comment">// 创建reader对象</span></span><br><span class="line">line, err := reader.ReadString(<span class="string">&quot;\n&quot;</span>) <span class="comment">// 每次读取一行</span></span><br><span class="line"><span class="comment">// 读取到末尾也会返回io.EOF，但是还会返回最后一行数据</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">  strSlice += line</span><br><span class="line">  fmt.Println(<span class="string">&quot;读取完毕&quot;</span>)</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">file, err := os.OpenFile(<span class="string">&quot;./main.go&quot;</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">writer := bufio.NewWriter(file) <span class="comment">// 创建writer对象</span></span><br><span class="line">writer.WriteString(<span class="string">&quot;ab\n&quot;</span>) <span class="comment">// 将数据写入缓存</span></span><br><span class="line">writer.Flush() <span class="comment">// 将缓存数据写入文件</span></span><br></pre></td></tr></table></figure>

<h4 id="通过ioutil包读写文件"><a href="#通过ioutil包读写文件" class="headerlink" title="通过ioutil包读写文件"></a>通过ioutil包读写文件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">byteStr, err := ioutil.ReadFile(<span class="string">&quot;./main.go&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">&quot;ab\n&quot;</span></span><br><span class="line">err := ioutil.WriteFile(<span class="string">&quot;./main.go&quot;</span>, []<span class="type">byte</span>(str), <span class="number">0666</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复制文件</span></span><br><span class="line">byteStr, err := ioutil.ReadFile(<span class="string">&quot;C:/main.go&quot;</span>)</span><br><span class="line">err := ioutil.WriteFile(<span class="string">&quot;D:/main.go&quot;</span>, byteStr, <span class="number">0666</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6、下划线"><a href="#6、下划线" class="headerlink" title="6、下划线"></a>6、下划线</h2><h3 id="（1）下划线在-import-中"><a href="#（1）下划线在-import-中" class="headerlink" title="（1）下划线在 import 中"></a>（1）下划线在 import 中</h3><p>​	import 下划线的作用：当导入一个包时，该包下的文件里所有 init() 函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行 init() 函数而已。这个时候就可以使用 import* 引用该包。即使用【import _ 包路径】只是引用该包，仅仅是为了调用 init() 函数，所以无法通过包名来调用包中的其他函数。 示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;./hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// hello.Print() </span></span><br><span class="line">  <span class="comment">//编译报错：./main.go:6:5: undefined: hello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：imp-init() come here.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;imp-init() come here.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）下划线在代码中"><a href="#（2）下划线在代码中" class="headerlink" title="（2）下划线在代码中"></a>（2）下划线在代码中</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">  f, _ := os.Open(<span class="string">&quot;/Users/***/Desktop/text.txt&quot;</span>)</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    n, _ := f.Read(buf)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    os.Stdout.Write(buf[:n])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表一个占位符，open方法返回两个结果，*os.File和error，但只需要第一个，忽略error，不会因不使用error而报错。</span></span><br></pre></td></tr></table></figure>

<h2 id="7、变量"><a href="#7、变量" class="headerlink" title="7、变量"></a>7、变量</h2><h3 id="（1）变量声明"><a href="#（1）变量声明" class="headerlink" title="（1）变量声明"></a>（1）变量声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure>

<h4 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a <span class="type">string</span></span><br><span class="line">  b <span class="type">int</span></span><br><span class="line">  c <span class="type">bool</span></span><br><span class="line">  d <span class="type">float32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure>

<h4 id="批量初始化变量"><a href="#批量初始化变量" class="headerlink" title="批量初始化变量"></a>批量初始化变量</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name, sex = <span class="string">&quot;pprof.cn&quot;</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line"><span class="keyword">var</span> sex = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h4 id="匿名变量（用下划线表示）"><a href="#匿名变量（用下划线表示）" class="headerlink" title="匿名变量（用下划线表示）"></a>匿名变量（用下划线表示）</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span>, <span class="string">&quot;Q1mi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x, _ := foo()</span><br><span class="line">  _, y := foo()</span><br><span class="line">  fmt.Println(<span class="string">&quot;x=&quot;</span>, x)</span><br><span class="line">  fmt.Println(<span class="string">&quot;y=&quot;</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）常量声明"><a href="#（2）常量声明" class="headerlink" title="（2）常量声明"></a>（2）常量声明</h3><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把 <code>var</code> 换成了 <code>const</code>，常量在定义的时候必须赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br></pre></td></tr></table></figure>

<h4 id="多个常量声明"><a href="#多个常量声明" class="headerlink" title="多个常量声明"></a>多个常量声明</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	pi = <span class="number">3.1415</span></span><br><span class="line">	e = <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>const</code> 同时声明多个常量时，如果省略了值则表示和上面一行的值相同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	n1 = <span class="number">100</span></span><br><span class="line">	n2</span><br><span class="line">	n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><p><code>iota</code> 是 <code>go</code> 语言的常量计数器，只能在常量的表达式中使用。 <code>iota</code> 在 <code>const</code> 关键字出现时将被重置为 <code>0</code>。<code>const</code> 中每新增一行常量声明将使 <code>iota</code> 计数一次(<code>iota</code> 可理解为 <code>const</code> 语句块中的行索引)。 使用 <code>iota</code> 能简化定义，在定义枚举时很有用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	n1 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">	n2        <span class="comment">// 1</span></span><br><span class="line">	n3        <span class="comment">// 2</span></span><br><span class="line">	n4        <span class="comment">// 3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>使用_跳过某些值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	n1 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">	n2        <span class="comment">// 1</span></span><br><span class="line">	_</span><br><span class="line">	n4        <span class="comment">// 3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>iota</code> 声明中间插队</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	n1 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">	n2 = <span class="number">100</span>  <span class="comment">// 100</span></span><br><span class="line">	n3 = <span class="literal">iota</span> <span class="comment">// 2</span></span><br><span class="line">	n4        <span class="comment">// 3</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>定义数量级 （这里的 <code>&lt;&lt;</code> 表示左移操作，<code>1&lt;&lt;10</code> 表示将 <code>1</code> 的二进制表示向左移 <code>10</code> 位，也就是由 <code>1</code> 变成了<code>10000000000</code>，也就是十进制的 <code>1024</code>。同理 <code>2&lt;&lt;2</code> 表示将 <code>2 </code> 的二进制表示向左移 <code>2</code> 位，也就是由 <code>10</code> 变成了 <code>1000</code>，也就是十进制的 <code>8</code>）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	_  = <span class="literal">iota</span></span><br><span class="line">	KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>多个 <code>iota </code> 定义在一行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">// 1, 2</span></span><br><span class="line">  c, d                      <span class="comment">// 2, 3</span></span><br><span class="line">  e, f                      <span class="comment">// 3, 4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="8、数组"><a href="#8、数组" class="headerlink" title="8、数组"></a>8、数组</h2><h3 id="（1）数组声明"><a href="#（1）数组声明" class="headerlink" title="（1）数组声明"></a>（1）数组声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 [数组长度]数据类型</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">3</span>]<span class="type">int</span> <span class="comment">// [0 0 0] 不赋值自动填充默认值</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// [0 1 2]</span></span><br><span class="line">arr3 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// [0 1 2]</span></span><br><span class="line"><span class="keyword">var</span> arr4 = [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// [0 1 2]，使用...自行推断数组长度</span></span><br><span class="line">arr5 = [...]<span class="type">int</span>&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">5</span>: <span class="number">10</span>&#125; <span class="comment">// [1 2 0 0 0 10]</span></span><br></pre></td></tr></table></figure>

<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 [元素数量][元素数量]T</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有第一层可以使用 ... 推导长度</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">  &#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;成都&quot;</span>, <span class="string">&quot;重庆&quot;</span>&#125;, <span class="comment">// 最后一行也要加逗号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、切片"><a href="#9、切片" class="headerlink" title="9、切片"></a>9、切片</h2><p>与数组不同，数组属于值类型，修改原变量不会改变副本值。而切片属于引用类型，修改原变量会改变副本值。</p>
<h3 id="（1）切片声明"><a href="#（1）切片声明" class="headerlink" title="（1）切片声明"></a>（1）切片声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 []T</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 []<span class="type">int</span> <span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> arr2 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// [1 2 3]</span></span><br><span class="line"><span class="keyword">var</span> arr3 = []<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">10</span>, <span class="number">5</span>: <span class="number">20</span>&#125; <span class="comment">// [0 2 10 0 0 20]</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）基于数组定义切片"><a href="#（2）基于数组定义切片" class="headerlink" title="（2）基于数组定义切片"></a>（2）基于数组定义切片</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice0 []<span class="type">int</span> = arr[start:end] <span class="comment">// 包含start不包含end</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="type">int</span> = arr[:end]</span><br><span class="line"><span class="keyword">var</span> slice2 []<span class="type">int</span> = arr[start:]</span><br><span class="line"><span class="keyword">var</span> slice3 []<span class="type">int</span> = arr[:] <span class="comment">// 获取所有值</span></span><br><span class="line"><span class="keyword">var</span> slice4 = arr[:<span class="built_in">len</span>(arr)<span class="number">-1</span>]      <span class="comment">//去掉切片的最后一个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）基于切片定义切片"><a href="#（3）基于切片定义切片" class="headerlink" title="（3）基于切片定义切片"></a>（3）基于切片定义切片</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> slice0 []<span class="type">int</span> = arr[start:end] <span class="comment">// 包含start不包含end</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="type">int</span> = arr[:end]</span><br><span class="line"><span class="keyword">var</span> slice2 []<span class="type">int</span> = arr[start:]</span><br><span class="line"><span class="keyword">var</span> slice3 []<span class="type">int</span> = arr[:] <span class="comment">// 获取所有值</span></span><br><span class="line"><span class="keyword">var</span> slice4 = arr[:<span class="built_in">len</span>(arr)<span class="number">-1</span>]      <span class="comment">//去掉切片的最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用len()和cap()获取切片的长度和容量</span></span><br><span class="line"><span class="comment">// 切片的长度：切片包含元素的个数</span></span><br><span class="line"><span class="comment">// 切片的容量：切片从第一个元素开始，到其底层数组或切片元素下标的个数</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;长度%d 容量%d\n&quot;</span>, <span class="built_in">len</span>(slice3), <span class="built_in">cap</span>(slice3)) <span class="comment">// 长度5 容量5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice0 []<span class="type">int</span> = arr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Printf(<span class="string">&quot;长度%d 容量%d\n&quot;</span>, <span class="built_in">len</span>(slice0), <span class="built_in">cap</span>(slice0)) <span class="comment">// 长度2 容量4</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）使用-make-声明切片"><a href="#（4）使用-make-声明切片" class="headerlink" title="（4）使用 make 声明切片"></a>（4）使用 make 声明切片</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> T：数据类型</span></span><br><span class="line"><span class="comment"> size：切片元素个数</span></span><br><span class="line"><span class="comment"> cap：切片容量</span></span><br><span class="line"><span class="comment"> 没有cap默认cap=size</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">make</span>([]T, size, <span class="built_in">cap</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">4</span>, <span class="number">8</span>) <span class="comment">// [0 0 0 0]</span></span><br></pre></td></tr></table></figure>

<h2 id="10、Map"><a href="#10、Map" class="headerlink" title="10、Map"></a>10、Map</h2><h3 id="（1）Map-的声明"><a href="#（1）Map-的声明" class="headerlink" title="（1）Map 的声明"></a>（1）Map 的声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// KeyType：key的类型</span></span><br><span class="line"><span class="comment">// ValueType：value的类型</span></span><br><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userinfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">userinfo[<span class="string">&quot;username&quot;</span>] = <span class="string">&quot;张三&quot;</span></span><br><span class="line">userinfo[<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;20&quot;</span></span><br><span class="line">fmt.Println(userinfo) <span class="comment">// map[username:张三 age:20]</span></span><br><span class="line">fmt.Println(userinfo[<span class="string">&quot;sex&quot;</span>]) <span class="comment">// &quot;&quot;，key不存在value返回零值</span></span><br><span class="line"></span><br><span class="line">userinfo := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">  <span class="string">&quot;username&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="string">&quot;20&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）判断某个键值对是否存在"><a href="#（2）判断某个键值对是否存在" class="headerlink" title="（2）判断某个键值对是否存在"></a>（2）判断某个键值对是否存在</h3><p>map使用ok判断键值是否存在</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := userinfo[<span class="string">&quot;username&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">  fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）删除键值对"><a href="#（3）删除键值对" class="headerlink" title="（3）删除键值对"></a>（3）删除键值对</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>对象, key)</span><br></pre></td></tr></table></figure>

<h2 id="11、指针"><a href="#11、指针" class="headerlink" title="11、指针"></a>11、指针</h2><h3 id="（1）指针地址和指针类型"><a href="#（1）指针地址和指针类型" class="headerlink" title="（1）指针地址和指针类型"></a>（1）指针地址和指针类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v:代表被取地址的变量，类型为T</span></span><br><span class="line"><span class="comment">// ptr:用于接收地址的变量，ptr的类型就为*T，称做T的指针类型。*代表指针。</span></span><br><span class="line">ptr := &amp;v    <span class="comment">// v的类型为T</span></span><br><span class="line"><span class="comment">// 空指针</span></span><br><span class="line"><span class="keyword">var</span> ptr *T <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := <span class="number">10</span></span><br><span class="line">  b := &amp;a</span><br><span class="line">  fmt.Printf(<span class="string">&quot;a:%d ptr:%p\n&quot;</span>, a, &amp;a) <span class="comment">// a:10 ptr:0xc00001a078</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;b:%p type:%T\n&quot;</span>, b, b) <span class="comment">// b:0xc00001a078 type:*int</span></span><br><span class="line">  fmt.Println(&amp;b)                    <span class="comment">// 0xc00000e018</span></span><br><span class="line">  fmt.Println(*b)										 <span class="comment">// 10</span></span><br><span class="line">  *b = <span class="number">30</span></span><br><span class="line">  fmt.Println(a)										 <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）new-函数"><a href="#（2）new-函数" class="headerlink" title="（2）new 函数"></a>（2）new 函数</h3><p>创建一个类型的指针，并且该指针对应的值为该类型的零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">  b := <span class="built_in">new</span>(<span class="type">bool</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, a) <span class="comment">// *int</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, b) <span class="comment">// *bool</span></span><br><span class="line">  fmt.Println(*a)       <span class="comment">// 0</span></span><br><span class="line">  fmt.Println(*b)       <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）new-和-make-的区别"><a href="#（3）new-和-make-的区别" class="headerlink" title="（3）new 和 make 的区别"></a>（3）new 和 make 的区别</h3><ol>
<li><strong>make</strong> 返回的是引用类型本身，而 <strong>new</strong> 返回的是指向类型的指针。</li>
<li><strong>make</strong> 只能初始化类型为 <em>slice、map、channel</em>，而 <strong>new</strong> 可以初始化任意数据类型。</li>
<li>对于引用类型，<strong>new</strong> 只会为其分配内存空间，内部字段还需进一步初始化，<strong>make</strong> 则会对内部数据类型也进行初始化。</li>
</ol>
<h2 id="12、结构体"><a href="#12、结构体" class="headerlink" title="12、结构体"></a>12、结构体</h2><h3 id="（1）自定义类型别名"><a href="#（1）自定义类型别名" class="headerlink" title="（1）自定义类型别名"></a>（1）自定义类型别名</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> name T</span><br><span class="line"><span class="keyword">type</span> name = T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区别</span></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a NewInt</span><br><span class="line">  <span class="keyword">var</span> b MyInt</span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">// type of a:main.NewInt</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;type of b:%T\n&quot;</span>, b) <span class="comment">// type of b:int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）结构体声明"><a href="#（2）结构体声明" class="headerlink" title="（2）结构体声明"></a>（2）结构体声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体名 <span class="keyword">struct</span> &#123;</span><br><span class="line">  字段名 字段类型</span><br><span class="line">  字段名 字段类型</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结构体名首字母大写表示公有，在其他包中可以使用，小写表示私有。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">  sex <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体实例化</span></span><br><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line">p1.name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">p1.age = <span class="number">20</span></span><br><span class="line">p1.sex = <span class="string">&quot;男&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指针类型结构体</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)     <span class="comment">// *main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">// p2=&amp;main.person&#123;name:&quot;&quot;, sex:&quot;&quot;, age:0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Go语言中支持对结构体指针直接使用.来访问结构体的成员</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">&quot;李四&quot;</span></span><br><span class="line">p2.age = <span class="number">18</span></span><br><span class="line">p2.sex = <span class="string">&quot;男&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">// p2=&amp;main.person&#123;name:&quot;李四&quot;, sex:&quot;男&quot;, age:18&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取结构体地址实例化</span></span><br><span class="line"><span class="keyword">var</span> p3 = &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3)     <span class="comment">// *main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">// p3=&amp;main.person&#123;name:&quot;&quot;, sex:&quot;&quot;, age:0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用键值对初始化结构体</span></span><br><span class="line">p4 := person&#123;</span><br><span class="line">  name: <span class="string">&quot;王五&quot;</span>,</span><br><span class="line">  sex: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p5 := &amp;person&#123;</span><br><span class="line">  name: <span class="string">&quot;王五&quot;</span>,</span><br><span class="line">  sex: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略键初始化结构体，顺序必须与结构体相对应</span></span><br><span class="line">p6 := person&#123;</span><br><span class="line">  <span class="string">&quot;哈哈&quot;</span>,</span><br><span class="line">  <span class="number">20</span>,</span><br><span class="line">  <span class="string">&quot;女&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p7 := &amp;person&#123;</span><br><span class="line">  <span class="string">&quot;哈哈&quot;</span>,</span><br><span class="line">  <span class="number">20</span>,</span><br><span class="line">  <span class="string">&quot;女&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）结构体方法和接收者"><a href="#（3）结构体方法和接收者" class="headerlink" title="（3）结构体方法和接收者"></a>（3）结构体方法和接收者</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>, age <span class="type">int8</span>)</span></span> *Person &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Dream() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := NewPerson(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetAge(newAge <span class="type">int8</span>) &#123;</span><br><span class="line">  p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p1 := NewPerson(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">  fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">  p1.SetAge(<span class="number">30</span>)</span><br><span class="line">  fmt.Println(p1.age) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetAge2 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> SetAge2(newAge <span class="type">int8</span>) &#123;</span><br><span class="line">  p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p1 := NewPerson(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">  p1.Dream()</span><br><span class="line">  fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">  p1.SetAge2(<span class="number">30</span>) <span class="comment">// (*p1).SetAge2(30)</span></span><br><span class="line">  fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">什么时候使用不同类型接收者：</span></span><br><span class="line"><span class="comment">	1.需要修改接收者中的值</span></span><br><span class="line"><span class="comment">	2.接收者是拷贝代价比较大的大对象</span></span><br><span class="line"><span class="comment">	3.保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）结构体的匿名字段"><a href="#（4）结构体的匿名字段" class="headerlink" title="（4）结构体的匿名字段"></a>（4）结构体的匿名字段</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</span></span><br><span class="line"><span class="comment">// Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">string</span></span><br><span class="line">  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p1 := Person&#123;</span><br><span class="line">    <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">    <span class="number">18</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1)        <span class="comment">// main.Person&#123;string:&quot;pprof.cn&quot;, int:18&#125;</span></span><br><span class="line">  fmt.Println(p1.<span class="type">string</span>, p1.<span class="type">int</span>) <span class="comment">// pprof.cn 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）嵌套结构体"><a href="#（5）嵌套结构体" class="headerlink" title="（5）嵌套结构体"></a>（5）嵌套结构体</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">  Province <span class="type">string</span></span><br><span class="line">  City     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name    <span class="type">string</span></span><br><span class="line">  Gender  <span class="type">string</span></span><br><span class="line">  Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  user1 := User&#123;</span><br><span class="line">    Name:   <span class="string">&quot;pprof&quot;</span>,</span><br><span class="line">    Gender: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">    Address: Address&#123;</span><br><span class="line">      Province: <span class="string">&quot;黑龙江&quot;</span>,</span><br><span class="line">      City:     <span class="string">&quot;哈尔滨&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)<span class="comment">//user1=main.User&#123;Name:&quot;pprof&quot;, Gender:&quot;女&quot;, Address:main.Address&#123;Province:&quot;黑龙江&quot;, City:&quot;哈尔滨&quot;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问结构体成员时会先从当前结构体查找，找不到再去上层结构体中查找。</span></span><br><span class="line">  user1.City = <span class="string">&quot;北京&quot;</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)<span class="comment">//user1=main.User&#123;Name:&quot;pprof&quot;, Gender:&quot;女&quot;, Address:main.Address&#123;Province:&quot;黑龙江&quot;, City:&quot;北京&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（6）结构体字段名冲突"><a href="#（6）结构体字段名冲突" class="headerlink" title="（6）结构体字段名冲突"></a>（6）结构体字段名冲突</h3><p>父结构体与子结构体存在字段名冲突，会优先查找父结构体字段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name   <span class="type">string</span></span><br><span class="line">  Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> user3 User</span><br><span class="line">  user3.Name = <span class="string">&quot;user3&quot;</span>   <span class="comment">// main.User&#123;Name: &quot;user3&quot;, Address: main.Address&#123;Name: &quot;&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">  Province   <span class="type">string</span></span><br><span class="line">  City       <span class="type">string</span></span><br><span class="line">  CreateTime <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">  Account    <span class="type">string</span></span><br><span class="line">  CreateTime <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name   <span class="type">string</span></span><br><span class="line">  Gender <span class="type">string</span></span><br><span class="line">  Address</span><br><span class="line">  Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> user3 User</span><br><span class="line">  user3.Name = <span class="string">&quot;pprof&quot;</span></span><br><span class="line">  user3.Gender = <span class="string">&quot;女&quot;</span></span><br><span class="line">  <span class="comment">// user3.CreateTime = &quot;2019&quot; // ambiguous selector user3.CreateTime</span></span><br><span class="line">  user3.Address.CreateTime = <span class="string">&quot;2000&quot;</span> <span class="comment">// 指定Address结构体中的CreateTime</span></span><br><span class="line">  user3.Email.CreateTime = <span class="string">&quot;2000&quot;</span>   <span class="comment">// 指定Email结构体中的CreateTime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（7）结构体继承"><a href="#（7）结构体继承" class="headerlink" title="（7）结构体继承"></a>（7）结构体继承</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> move() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">  Feet    <span class="type">int8</span></span><br><span class="line">  *Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  d1 := &amp;Dog&#123;</span><br><span class="line">    Feet: <span class="number">4</span>,</span><br><span class="line">    Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">      name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">  d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（8）结构体与JSON相互转换"><a href="#（8）结构体与JSON相互转换" class="headerlink" title="（8）结构体与JSON相互转换"></a>（8）结构体与JSON相互转换</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用encoding/json包将结构体序列化</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span>,</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须公有，否则无法被json包访问</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  s1 := Student&#123;</span><br><span class="line">    ID: <span class="number">1</span>,</span><br><span class="line">    Name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 结构体转JSON</span></span><br><span class="line">  jsonByte, err := json.Marshal(s1) <span class="comment">// 返回一个byte切片（[]byte）和err</span></span><br><span class="line">  jsonStr := <span class="type">string</span>(jsonByte) <span class="comment">// &#123;&quot;ID&quot;: 1, &quot;Name&quot;: &quot;张三&quot;&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// JSON转结构体</span></span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">`&#123;&quot;ID&quot;: 1, &quot;Name&quot;: &quot;张三&quot;&#125;`</span></span><br><span class="line">  <span class="keyword">var</span> s2 Student</span><br><span class="line">  err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;s2) <span class="comment">// 返回err</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体标签</span></span><br><span class="line"><span class="comment">// 表示JSON序列化后转换的键名</span></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID <span class="type">int</span> <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125; <span class="comment">// &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;张三&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="13、函数"><a href="#13、函数" class="headerlink" title="13、函数"></a>13、函数</h2><h3 id="（1）函数参数"><a href="#（1）函数参数" class="headerlink" title="（1）函数参数"></a>（1）函数参数</h3><p>参数类型相同时可以只声明一个类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）不定参数"><a href="#（2）不定参数" class="headerlink" title="（2）不定参数"></a>（2）不定参数</h3><p>不定参数本质上是切片，指参数个数未知，参数类型相同</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(x ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [1 2 3]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(x <span class="type">int</span>, y ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 1 [2 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）返回值"><a href="#（3）返回值" class="headerlink" title="（3）返回值"></a>（3）返回值</h3><p>Go的返回值可以被命名，当return语句没有返回值时，返回返回值的当前值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x, y <span class="type">int</span>)</span></span> (sum, sub <span class="type">int</span>) &#123;</span><br><span class="line">  sum = x + y</span><br><span class="line">  sub = x - y</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a, b := test(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 30 -10</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）闭包"><a href="#（4）闭包" class="headerlink" title="（4）闭包"></a>（4）闭包</h3><p>常驻内存，不污染全局。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i += y</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = add()</span><br><span class="line">fn(<span class="number">10</span>) <span class="comment">// 20</span></span><br><span class="line">fn(<span class="number">10</span>) <span class="comment">// 30</span></span><br><span class="line">fn(<span class="number">10</span>) <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）defer"><a href="#（5）defer" class="headerlink" title="（5）defer"></a>（5）defer</h3><ol>
<li>关键字 defer 用于注册延迟调用。</li>
<li>这些调用直到 return 前才被执。因此，可以用来做资源清理。</li>
<li>多个defer语句，按先进后出的方式执行。</li>
<li>defer语句中的变量，在defer声明时就决定了。</li>
</ol>
<p><img src="/2024/08/07/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/defer.png" alt="defer"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defer注册要执行延迟执行的函数时该函数所有的参数都需要确定其值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="type">string</span>, a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  ret := a + b</span><br><span class="line">  fmt.Println(index, a, b, ret)</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  x := <span class="number">1</span></span><br><span class="line">  y := <span class="number">2</span></span><br><span class="line">  <span class="keyword">defer</span> calc(<span class="string">&quot;AA&quot;</span>, x, calc(<span class="string">&quot;A&quot;</span>, x, y))</span><br><span class="line">  x = <span class="number">10</span></span><br><span class="line">  <span class="keyword">defer</span> calc(<span class="string">&quot;BB&quot;</span>, x, calc(<span class="string">&quot;B&quot;</span>, x, y))</span><br><span class="line">  y = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注册顺序：</span></span><br><span class="line"><span class="comment">defer calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))</span></span><br><span class="line"><span class="comment">defer calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))</span></span><br><span class="line"><span class="comment">执行顺序：</span></span><br><span class="line"><span class="comment">defer calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))</span></span><br><span class="line"><span class="comment">defer calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">calc(&quot;A&quot;, x, y) A 1 2 3</span></span><br><span class="line"><span class="comment">calc(&quot;B&quot;, x, y) B 10 2 12</span></span><br><span class="line"><span class="comment">calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y)) BB 10 12 22</span></span><br><span class="line"><span class="comment">calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y)) AA 1 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（6）panic-recover"><a href="#（6）panic-recover" class="headerlink" title="（6）panic&#x2F;recover"></a>（6）panic&#x2F;recover</h3><p>Golang 没有结构化异常，使用 panic 抛出错误，recover 捕获错误。</p>
<p>异常的使用场景简单描述：Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。</p>
<p>panic：</p>
<ol>
<li>内置函数</li>
<li>假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行</li>
<li>返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行</li>
<li>直到goroutine整个退出，并报告错误</li>
</ol>
<p>recover：</p>
<ol>
<li>内置函数</li>
<li>用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为</li>
<li>一般的调用建议<ul>
<li>在defer函数中，通过recever来终止一个goroutine的panicking过程，从而恢复正常代码的执行</li>
<li>可以获取通过panic传递的error</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(err.(<span class="type">string</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;panic error!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// panic error!</span></span><br></pre></td></tr></table></figure>

<h2 id="14、流程控制"><a href="#14、流程控制" class="headerlink" title="14、流程控制"></a>14、流程控制</h2><h3 id="（1）if…else"><a href="#（1）if…else" class="headerlink" title="（1）if…else"></a>（1）if…else</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）for"><a href="#（2）for" class="headerlink" title="（2）for"></a>（2）for</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> init; condition; post &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br><span class="line">init： 一般为赋值表达式，给控制变量赋初值；</span><br><span class="line">condition： 关系表达式或逻辑表达式，循环控制条件；</span><br><span class="line">post： 一般为赋值表达式，给控制变量增量或减量。</span><br><span class="line"><span class="keyword">for</span>语句执行过程如下：</span><br><span class="line">①先对表达式 init 赋初值；</span><br><span class="line">②判别赋值表达式 init 是否满足给定 condition 条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止<span class="keyword">for</span>循环，执行循环体外语句。</span><br></pre></td></tr></table></figure>

<h3 id="（3）range"><a href="#（3）range" class="headerlink" title="（3）range"></a>（3）range</h3><p>Golang range类似迭代器操作，返回 (索引, 值) 或 (键, 值)。</p>
<p>for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）switch…case"><a href="#（4）switch…case" class="headerlink" title="（4）switch…case"></a>（4）switch…case</h3><p>分支可以用逗号间隔，表示同一个分支。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">  <span class="keyword">case</span> val1:</span><br><span class="line">  	...</span><br><span class="line">  <span class="keyword">case</span> val2:</span><br><span class="line">  	...</span><br><span class="line">  <span class="keyword">case</span> val3, val4:</span><br><span class="line">  	...</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h4><p><code>fallthrough</code>可以强制执行满足<code>case</code>条件的下一个<code>case</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> age := <span class="number">10</span>; age &#123;</span><br><span class="line">  <span class="keyword">case</span> age &lt; <span class="number">20</span>:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">  	<span class="keyword">fallthrough</span></span><br><span class="line">  <span class="keyword">case</span> age &gt;= <span class="number">20</span> &amp;&amp; age &lt; <span class="number">40</span>:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> age &gt;= <span class="number">40</span>:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="省略判断变量"><a href="#省略判断变量" class="headerlink" title="省略判断变量"></a>省略判断变量</h4><p>分支使用表达式时<code>switch</code>后面可以省略判断变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> n &gt; <span class="number">0</span> &amp;&amp; n &lt; <span class="number">10</span>:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;i &gt; 0 and i &lt; 10&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> n &gt; <span class="number">10</span> &amp;&amp; n &lt; <span class="number">20</span>:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;i &gt; 10 and i &lt; 20&quot;</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	fmt.Println(<span class="string">&quot;def&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）break"><a href="#（5）break" class="headerlink" title="（5）break"></a>（5）break</h3><p>跳出当前循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">    <span class="keyword">if</span> j == <span class="number">3</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;i=%v j=%v&#x27;\n&quot;</span>, i, j)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i=0 j=0</span></span><br><span class="line"><span class="comment">i=0 j=1</span></span><br><span class="line"><span class="comment">i=0 j=2</span></span><br><span class="line"><span class="comment">i=1 j=0</span></span><br><span class="line"><span class="comment">i=1 j=1</span></span><br><span class="line"><span class="comment">i=1 j=2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>使用<code>lable</code>标签：，表示结束标签对应的循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">lablename: <span class="comment">// 自定义的lable标签</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> j == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> lablename</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;i=%v j=%v&#x27;\n&quot;</span>, i, j)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i=0 j=0</span></span><br><span class="line"><span class="comment">i=0 j=1</span></span><br><span class="line"><span class="comment">i=0 j=2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（6）continue"><a href="#（6）continue" class="headerlink" title="（6）continue"></a>（6）continue</h3><p>结束当前循环，执行下一次循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">if</span> i == <span class="number">3</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure>

<p>使用<code>lable</code>标签，表示开始标签对应的循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">lablename: <span class="comment">// 自定义的lable标签</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">      <span class="keyword">if</span> j == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span> lablename</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;i=%v j=%v&#x27;\n&quot;</span>, i, j)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// i=0 j=0</span></span><br><span class="line"><span class="comment">// i=0 j=1</span></span><br><span class="line"><span class="comment">// i=0 j=2</span></span><br><span class="line"><span class="comment">// i=1 j=0</span></span><br><span class="line"><span class="comment">// i=1 j=1</span></span><br><span class="line"><span class="comment">// i=1 j=2</span></span><br></pre></td></tr></table></figure>

<h3 id="（7）goto"><a href="#（7）goto" class="headerlink" title="（7）goto"></a>（7）goto</h3><p>通过<code>lable</code>跳转到指定位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">age := <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;成年人&quot;</span>)</span><br><span class="line">  <span class="keyword">goto</span> lablename</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;222&quot;</span>)</span><br><span class="line">lablename:</span><br><span class="line">	fmt.Println(<span class="string">&quot;333&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;444&quot;</span>)</span><br><span class="line"><span class="comment">// 成年人</span></span><br><span class="line"><span class="comment">// 333</span></span><br><span class="line"><span class="comment">// 444</span></span><br></pre></td></tr></table></figure>

<h2 id="15、接口"><a href="#15、接口" class="headerlink" title="15、接口"></a>15、接口</h2><h3 id="（1）接口的定义"><a href="#（1）接口的定义" class="headerlink" title="（1）接口的定义"></a>（1）接口的定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">接口是一个或多个方法签名的集合。</span><br><span class="line">任何类型的方法集中只要拥有该接口<span class="string">&#x27;对应的全部方法&#x27;</span>签名。</span><br><span class="line">就表示它 <span class="string">&quot;实现&quot;</span> 了该接口，无须在该类型上显式声明实现了哪个接口。</span><br><span class="line">这称为Structural Typing。</span><br><span class="line">所谓对应方法，是指有相同名称、参数列表 (不包括参数名) 以及返回值。</span><br><span class="line">当然，该类型还可以有其他方法。</span><br><span class="line"></span><br><span class="line">接口只有方法声明，没有实现，没有数据字段。</span><br><span class="line">接口可以匿名嵌入其他接口，或嵌入到结构中。</span><br><span class="line">对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针。</span><br><span class="line">只有当接口存储的类型和对象都为<span class="literal">nil</span>时，接口才等于<span class="literal">nil</span>。</span><br><span class="line">接口调用不会做receiver的自动转换。</span><br><span class="line">接口同样支持匿名字段方法。</span><br><span class="line">接口也可实现类似OOP中的多态。</span><br><span class="line">空接口可以作为任何类型数据的容器。</span><br><span class="line">一个类型可实现多个接口。</span><br><span class="line">接口命名习惯以 er 结尾。</span><br></pre></td></tr></table></figure>

<p>每个接口由数个方法组成，接口的定义格式如下：</p>
<ul>
<li><p>接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。</p>
</li>
<li><p>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</p>
</li>
<li><p>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">  方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">  方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">  …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> writer <span class="keyword">interface</span>&#123;</span><br><span class="line">  Write([]<span class="type">byte</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）实现接口的条件"><a href="#（2）实现接口的条件" class="headerlink" title="（2）实现接口的条件"></a>（2）实现接口的条件</h3><p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表。</p>
<p>我们来定义一个Sayer接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">  say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义dog和cat两个结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>因为Sayer接口里只有一个say方法，所以我们只需要给dog和cat 分别实现say方法就可以实现Sayer接口了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dog实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> say() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;汪汪汪&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span></span> say() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;喵喵喵&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，Sayer类型的变量能够存储dog和cat类型的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x Sayer <span class="comment">// 声明一个Sayer类型的变量x</span></span><br><span class="line">  a := cat&#123;&#125;  <span class="comment">// 实例化一个cat</span></span><br><span class="line">  b := dog&#123;&#125;  <span class="comment">// 实例化一个dog</span></span><br><span class="line">  x = a       <span class="comment">// 可以把cat实例直接赋值给x</span></span><br><span class="line">  x.say()     <span class="comment">// 喵喵喵</span></span><br><span class="line">  x = b       <span class="comment">// 可以把dog实例直接赋值给x</span></span><br><span class="line">  x.say()     <span class="comment">// 汪汪汪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）空接口"><a href="#（3）空接口" class="headerlink" title="（3）空接口"></a>（3）空接口</h3><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p>
<p>空接口类型的变量可以存储任意类型的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 定义一个空接口x</span></span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  s := <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">  x = s</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">  i := <span class="number">100</span></span><br><span class="line">  x = i</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">  b := <span class="literal">true</span></span><br><span class="line">  x = b</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用空接口实现可以接收任意类型的函数参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空接口作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用空接口实现可以保存任意值的字典。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空接口作为map值</span></span><br><span class="line"><span class="keyword">var</span> studentInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">studentInfo[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;李白&quot;</span></span><br><span class="line">studentInfo[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line">studentInfo[<span class="string">&quot;married&quot;</span>] = <span class="literal">false</span></span><br><span class="line">fmt.Println(studentInfo)</span><br></pre></td></tr></table></figure>

<p>使用空接口实现可以保存任意值的切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">1</span>, <span class="string">&quot;2&quot;</span>, <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）类型断言"><a href="#（4）类型断言" class="headerlink" title="（4）类型断言"></a>（4）类型断言</h3><p>想要判断空接口中的值这个时候就可以使用类型断言，其语法格式<code>x.(T)</code>：</p>
<ul>
<li>x：表示类型为interface{}的变量</li>
<li>T：表示断言x可能是的类型。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  x = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">  v, ok := x.(<span class="type">string</span>)</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;类型断言失败&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>x.(type)</code>配合<code>switch</code>语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">justifyType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;x is a string，value is %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;x is a int is %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;x is a bool is %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;unsupport type！&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）值类型接收者和指针类型接收者实现接口的区别"><a href="#（5）值类型接收者和指针类型接收者实现接口的区别" class="headerlink" title="（5）值类型接收者和指针类型接收者实现接口的区别"></a>（5）值类型接收者和指针类型接收者实现接口的区别</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">  move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span></span> move() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x Mover</span><br><span class="line">  <span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">  x = wangcai         <span class="comment">// x可以接收dog类型</span></span><br><span class="line">  <span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">  x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">  x.move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span></span> move() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x Mover</span><br><span class="line">  <span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">  x = wangcai         <span class="comment">// x不可以接收dog类型</span></span><br><span class="line">  <span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">  x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、并发编程"><a href="#二、并发编程" class="headerlink" title="二、并发编程"></a>二、并发编程</h1><h2 id="1、并发的定义"><a href="#1、并发的定义" class="headerlink" title="1、并发的定义"></a>1、并发的定义</h2><h3 id="（1）进程和线程"><a href="#（1）进程和线程" class="headerlink" title="（1）进程和线程"></a>（1）进程和线程</h3><ul>
<li>进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。</li>
<li>进程至少有五种基本状态：初始态、执行态、等待状态、就绪状态、终止状态。</li>
<li>线程是进程的一个执行实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</li>
<li>一个进程可以创建和撤销多个线程；同一个进程中的多个线程之间可以并发执行。</li>
</ul>
<h3 id="（2）并发和并行"><a href="#（2）并发和并行" class="headerlink" title="（2）并发和并行"></a>（2）并发和并行</h3><ul>
<li>多线程程序在一个核的CPU上运行，就是并发。</li>
<li>多线程程序在多个核的CPU上运行，就是并行。</li>
</ul>
<h3 id="（3）协程和线程"><a href="#（3）协程和线程" class="headerlink" title="（3）协程和线程"></a>（3）协程和线程</h3><p>协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。<br>    线程：一个线程上可以跑多个协程，协程是轻量级的线程。</p>
<h2 id="2、Goroutine"><a href="#2、Goroutine" class="headerlink" title="2、Goroutine"></a>2、Goroutine</h2><p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但<code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将<code>goroutine</code>中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p>
<p>在方法前面加上<code>go</code>关键字，就可以开启<code>goroutine</code>。一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> hello()</span><br><span class="line">  fmt.Println(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main goroutine done! 没有输出Hello Goroutine!</span></span><br></pre></td></tr></table></figure>

<p>但是当<code>main</code>函数执行完成时即时协程未执行完毕也会退出。这时候就需要使用<code>Sync</code>包中的<code>WaitGroup</code>方法等待协程结束。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> wg.Done() <span class="comment">// 协程计数器 - 1</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>) <span class="comment">// 协程计数器 + 1</span></span><br><span class="line">  <span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">  wg.Wait() <span class="comment">// 等待所有协程执行完毕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、runtime包"><a href="#3、runtime包" class="headerlink" title="3、runtime包"></a>3、runtime包</h2><h3 id="（1）NumCPU"><a href="#（1）NumCPU" class="headerlink" title="（1）NumCPU"></a>（1）NumCPU</h3><p>获取当前计算机CPU个数</p>
<h3 id="（2）GOMAXPROCS"><a href="#（2）GOMAXPROCS" class="headerlink" title="（2）GOMAXPROCS"></a>（2）GOMAXPROCS</h3><p>设置当前程序并发时占用的CPU逻辑核心数。</p>
<h2 id="4、channel"><a href="#4、channel" class="headerlink" title="4、channel"></a>4、channel</h2><p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明<code>channel</code>的时候需要为其指定元素类型。</p>
<h3 id="（1）channel声明"><a href="#（1）channel声明" class="headerlink" title="（1）channel声明"></a>（1）channel声明</h3><p>channel是一种引用类型。声明通道类型的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure>

<p>声明的通道后需要使用make函数初始化之后才能使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br><span class="line"></span><br><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>单向管道，表示管道只读或只写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- 元素类型, [缓冲大小]) <span class="comment">// 只写管道，只能写入数据</span></span><br><span class="line"><span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> 元素类型, [缓冲大小]) <span class="comment">// 只读管道，只能读取数据</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）管道的操作"><a href="#（2）管道的操作" class="headerlink" title="（2）管道的操作"></a>（2）管道的操作</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储数据，管道长度大于容量会造成死锁</span></span><br><span class="line">ch4 &lt;- <span class="number">10</span></span><br><span class="line"><span class="comment">// 获取数据，获取不到数据（管道没有数据）会造成死锁</span></span><br><span class="line">i := &lt;- ch4</span><br><span class="line"><span class="comment">// 获取数据但不赋值给变量</span></span><br><span class="line">&lt;- ch4</span><br><span class="line"><span class="comment">// 关闭管道</span></span><br><span class="line"><span class="built_in">close</span>(ch4)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.对一个关闭的通道再发送值就会导致panic。</span></span><br><span class="line"><span class="comment">2.对一个关闭的通道进行接收会一直获取值直到通道为空。</span></span><br><span class="line"><span class="comment">3.对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</span></span><br><span class="line"><span class="comment">4.关闭一个已经关闭的通道会导致panic。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）select"><a href="#（3）select" class="headerlink" title="（3）select"></a>（3）select</h3><p><code>select</code>的使用类似于<code>switch</code>语句，它有一系列<code>case</code>分支和一个默认的分支。每个<code>case</code>会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-chan1:</span><br><span class="line">  <span class="comment">// 如果chan1成功读到数据，则进行该case处理语句</span></span><br><span class="line">  <span class="keyword">case</span> chan2 &lt;- <span class="number">1</span>:</span><br><span class="line">  <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">// 如果上面都没有成功，则进入default处理流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>select</code>可以同时监听一个或多个<code>channel</code>，直到其中一个<code>channel</code>ready。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">  ch &lt;- <span class="string">&quot;test1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">  ch &lt;- <span class="string">&quot;test2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 2个管道</span></span><br><span class="line">  output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">  output2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">  <span class="comment">// 跑2个子协程，写数据</span></span><br><span class="line">  <span class="keyword">go</span> test1(output1)</span><br><span class="line">  <span class="keyword">go</span> test2(output2)</span><br><span class="line">  <span class="comment">// 用select监控</span></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> s1 := &lt;-output1:</span><br><span class="line">    fmt.Println(<span class="string">&quot;s1=&quot;</span>, s1)</span><br><span class="line">    <span class="keyword">case</span> s2 := &lt;-output2:</span><br><span class="line">    fmt.Println(<span class="string">&quot;s2=&quot;</span>, s2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果多个<code>channel</code>同时ready，则随机选择一个执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建2个管道</span></span><br><span class="line">  int_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">  string_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//time.Sleep(2 * time.Second)</span></span><br><span class="line">    int_chan &lt;- <span class="number">1</span></span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    string_chan &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> value := &lt;-int_chan:</span><br><span class="line">    fmt.Println(<span class="string">&quot;int:&quot;</span>, value)</span><br><span class="line">    <span class="keyword">case</span> value := &lt;-string_chan:</span><br><span class="line">    fmt.Println(<span class="string">&quot;string:&quot;</span>, value)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用于判断管道是否存满。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断管道有没有存满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建管道</span></span><br><span class="line">  output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">  <span class="comment">// 子协程写数据</span></span><br><span class="line">  <span class="keyword">go</span> write(output1)</span><br><span class="line">  <span class="comment">// 取数据</span></span><br><span class="line">  <span class="keyword">for</span> s := <span class="keyword">range</span> output1 &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;res:&quot;</span>, s)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="comment">// 写数据</span></span><br><span class="line">      <span class="keyword">case</span> ch &lt;- <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;write hello&quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;channel full&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）并发安全和锁"><a href="#（4）并发安全和锁" class="headerlink" title="（4）并发安全和锁"></a>（4）并发安全和锁</h3><p>有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg.Add(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">go</span> add()</span><br><span class="line">  <span class="keyword">go</span> add()</span><br><span class="line">  wg.Wait()</span><br><span class="line">  fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们开启了两个<code>goroutine</code>去累加变量x的值，这两个<code>goroutine</code>在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int64</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">    lock.Lock() <span class="comment">// 加锁</span></span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    lock.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  wg.Add(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">go</span> add()</span><br><span class="line">  <span class="keyword">go</span> add()</span><br><span class="line">  wg.Wait()</span><br><span class="line">  fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h4><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p>
<p>读写锁分为两种：读锁和写锁。当一个<code>goroutine</code>获取读锁之后，其他的<code>goroutine</code>如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  x      <span class="type">int64</span></span><br><span class="line">  wg     sync.WaitGroup</span><br><span class="line">  lock   sync.Mutex</span><br><span class="line">  rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// lock.Lock()   // 加互斥锁</span></span><br><span class="line">  rwlock.Lock() <span class="comment">// 加写锁</span></span><br><span class="line">  x = x + <span class="number">1</span></span><br><span class="line">  time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="comment">// 假设读操作耗时10毫秒</span></span><br><span class="line">  rwlock.Unlock()                   <span class="comment">// 解写锁</span></span><br><span class="line">  <span class="comment">// lock.Unlock()                     // 解互斥锁</span></span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// lock.Lock()                  // 加互斥锁</span></span><br><span class="line">  rwlock.RLock()               <span class="comment">// 加读锁</span></span><br><span class="line">  time.Sleep(time.Millisecond) <span class="comment">// 假设读操作耗时1毫秒</span></span><br><span class="line">  rwlock.RUnlock()             <span class="comment">// 解读锁</span></span><br><span class="line">  <span class="comment">// lock.Unlock()                // 解互斥锁</span></span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  start := time.Now()</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> write()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> read()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wg.Wait()</span><br><span class="line">  end := time.Now()</span><br><span class="line">  fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解GMP模型</title>
    <url>/2025/06/09/Golang%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="一、Go-V1-3-标记清除法"><a href="#一、Go-V1-3-标记清除法" class="headerlink" title="一、Go V1.3 标记清除法"></a>一、Go V1.3 标记清除法</h1><p>Go 在 V1.3 之前使用的是标记清除法：</p>
<p><img src="/2025/06/09/Golang%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/marksweep.png" alt="标记清除法"></p>
<ol>
<li>暂停程序业务逻辑，分类出可达和不可达的对象，然后做上标记。</li>
<li>开始标记，程序找出它所有可达的对象，并做上标记。</li>
<li>标记完了之后，然后开始清除未标记的对象。</li>
<li>停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</li>
</ol>
<p>标记清除法有非常严重的问题：</p>
<ul>
<li>STW（stop the world），让程序暂停，程序出现卡顿。</li>
<li>标记需要扫描整个 heap。</li>
<li>清除数据会产生 heap 碎片。</li>
</ul>
<p>STW 整个过程经过“暂停程序 -&gt; 标记 -&gt; 清除 -&gt; 重新启动程序”，Go 在 GC 回收中优化了 STW 过程，将清除放到 STW 之外，减少了程序暂停时间，但是仍会造成程序卡顿。</p>
<h1 id="二、Go-V1-5-三色标记法"><a href="#二、Go-V1-5-三色标记法" class="headerlink" title="二、Go V1.5 三色标记法"></a>二、Go V1.5 三色标记法</h1><p>为了解决 STW 带来的问题，Go 在 V1.5 之后引入了三色标记法。</p>
<ol>
<li>每次创建新的对象，都会将对象标记为**<span style="color: #C0C4CC;">白色</span>**。</li>
<li>GC 开始时，从根节点开始遍历，将根节点对象标记为**<span style="color: gray;">灰色</span>**。</li>
<li>遍历**<span style="color: gray;">灰色</span><strong>节点，将</strong><span style="color: gray;">灰色</span><strong>节点引用的对象标记为</strong><span style="color: gray;">灰色</span><strong>，原来的</strong><span style="color: gray;">灰色</span><strong>节点标记为</strong>黑色**。</li>
<li>重复步骤 3，直到没有**<span style="color: gray;">灰色</span>**节点。</li>
<li>回收所有**<span style="color: #C0C4CC;">白色</span>**节点。</li>
</ol>
<p>根对象：</p>
<ul>
<li>栈上的对象：Goroutine 栈上的变量（局部变量、参数等）。</li>
<li>全局变量：程序中的全局变量（存储在静态数据区）。</li>
<li>寄存器中的对象：当前执行代码可能通过寄存器引用对象。</li>
<li>运行时数据结构：例如 <code>runtime</code> 包中的特殊对象。</li>
</ul>
<h2 id="标记出错"><a href="#标记出错" class="headerlink" title="标记出错"></a>标记出错</h2><p>但是由于 V1.5 的垃圾回收机制是跟程序并发执行的，所以在一些特定条件下，三色标记法可能会出现错误。</p>
<h3 id="（1）对象漏标"><a href="#（1）对象漏标" class="headerlink" title="（1）对象漏标"></a>（1）对象漏标</h3><ul>
<li>对象 A 在 GC 开始时被标记为<strong>黑色</strong>，对象 B 是与另一个<strong>黑色</strong>对象的引用对象，因此会被标记为**<span style="color: gray;">灰色</span>**，对象 C 是对象 B 的引用对象。</li>
<li>在 GC 进行过程中，对象 B 删除了对对象 C 的引用，而对象 A 建立与对象 C 的引用。</li>
<li>对象 C 因为没有被标记成**<span style="color: gray;">灰色</span>**被错误扫描从而在 GC 结束后被回收。</li>
</ul>
<h3 id="（2）对象多标"><a href="#（2）对象多标" class="headerlink" title="（2）对象多标"></a>（2）对象多标</h3><ul>
<li>对象 A 在 GC 开始时被标记为<strong>黑色</strong>，对象 B 是对象 A 的引用，因此会被标记为**<span style="color: gray;">灰色</span>**。</li>
<li>在 GC 进行过程中，对象 A 删除了对对象 B 的引用。</li>
<li>因为对象 B 是**<span style="color: gray;">灰色</span><strong>，因此在下一轮扫描中仍然会被标记为</strong>黑色**，因此对象 B 没有被正确回收。这种对象成为“浮动垃圾”，但是由于对象 B 在下一次 GC 还是会被回收，我们可以容忍这种错误。</li>
</ul>
<p>在两种条件同时存在的情况下，对象漏标就会发生：</p>
<ol>
<li>一个白色对象被<strong>黑色</strong>对象引用。</li>
<li>**<span style="color: gray;">灰色</span><strong>对象与它之间的可达关系的</strong><span style="color: #C0C4CC;">白色</span>**对象遭到破坏。</li>
</ol>
<h2 id="强弱三色不变式"><a href="#强弱三色不变式" class="headerlink" title="强弱三色不变式"></a>强弱三色不变式</h2><p>为了解决这种问题，Go 提出了<strong>“强弱三色不变式”</strong>：</p>
<ul>
<li>强三色不变式：**<span style="color: #C0C4CC;">白色</span><strong>对象不能被</strong>黑色**对象直接引用（直接破坏条件 1）。</li>
<li>弱三色不变式：**<span style="color: #C0C4CC;">白色</span><strong>对象可以被</strong>黑色<strong>对象引用，但在白色对象的引用链上必须存在</strong><span style="color: gray;">灰色</span>**对象（破坏条件 2）。</li>
</ul>
<h2 id="屏障机制"><a href="#屏障机制" class="headerlink" title="屏障机制"></a>屏障机制</h2><p>遵循这两种方法，GC 算法引入了屏障机制。即在执行某种特定行动前，必须完成屏障的条件：</p>
<h3 id="（1）插入写屏障"><a href="#（1）插入写屏障" class="headerlink" title="（1）插入写屏障"></a>（1）插入写屏障</h3><p>当一个<strong>黑色</strong>对象指向一个**<span style="color: #C0C4CC;">白色</span><strong>对象前，会先触发屏障将</strong><span style="color: #C0C4CC;">白色</span><strong>对象置为</strong><span style="color: gray;">灰色</span>**，再建立引用。</p>
<h3 id="（2）删除写屏障"><a href="#（2）删除写屏障" class="headerlink" title="（2）删除写屏障"></a>（2）删除写屏障</h3><p>当一个**<span style="color: #C0C4CC;">白色</span><strong>对象即将被上游删除引用前，会触发屏障将其置为</strong><span style="color: gray;">灰色</span>**，之后再删除上游指向其的引用。</p>
<p>屏障机制依旧存在缺陷，不能对栈对象生效，因此在 GC 最后依旧需要 STW 最后进行一次栈的扫描。</p>
<h1 id="三、Go-V1-8混合写屏障"><a href="#三、Go-V1-8混合写屏障" class="headerlink" title="三、Go V1.8混合写屏障"></a>三、Go V1.8混合写屏障</h1><p>为了消除最后一次 STW 的成本，Go V1.8 开始使用混合写屏障 + 三色标记法模式：</p>
<ol>
<li>在 GC 开始前，将栈上所有可达对象置<strong>黑</strong>。</li>
<li>GC 期间，栈上新创建的对象都会被置<strong>黑</strong>。</li>
<li>堆对象正常使用插入、删除写屏障。</li>
</ol>
<p>在 V1.8 中，GC 只在开始和结束使用 STW，告知程序启用和关闭屏障。</p>
<h1 id="四、GC触发时机"><a href="#四、GC触发时机" class="headerlink" title="四、GC触发时机"></a>四、GC触发时机</h1><ul>
<li>自动触发：当堆当中存活的对象大小达到上一次 GC 结束后对内存的比例时触发，默认由环境变量 <code>GOGC</code> 控制（默认值为 <em><strong>100</strong></em>，即当堆内存增长 <em><strong>100%</strong></em> 时触发）。</li>
<li>手动触发：使用 <code>runtime.GC()</code> 强制触发一次 GC，通常用于性能测试或者内存泄漏测试。</li>
<li>系统监控强制触发：系统一般会在距离上一次 GC 两分钟后强制触发一次 GC。</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Go改变命令行输出颜色</title>
    <url>/2025/03/26/Go%E6%94%B9%E5%8F%98%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<h1 id="faith-color包"><a href="#faith-color包" class="headerlink" title="faith&#x2F;color包"></a>faith&#x2F;color包</h1><p><em><strong>faith&#x2F;color</strong></em>是一个用于美化终端输出的<em><strong>Golang</strong></em>库，可以改变输出文本的颜色。GitHub地址：<a href="https://github.com/faith/color%E3%80%82%E4%B8%8B%E9%9D%A2%E6%98%AF%E5%AE%83%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95%EF%BC%9A">https://github.com/faith/color。下面是它的一些用法：</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/fatih/color</span><br></pre></td></tr></table></figure>

<h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><h3 id="标准颜色"><a href="#标准颜色" class="headerlink" title="标准颜色"></a>标准颜色</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Print with default helper functions</span></span><br><span class="line">color.Cyan(<span class="string">&quot;Prints text in cyan.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// A newline will be appended automatically</span></span><br><span class="line">color.Blue(<span class="string">&quot;Prints %s in blue.&quot;</span>, <span class="string">&quot;text&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// These are using the default foreground colors</span></span><br><span class="line">color.Red(<span class="string">&quot;We have red&quot;</span>)</span><br><span class="line">color.Magenta(<span class="string">&quot;And many others ..&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/03/26/Go%E6%94%B9%E5%8F%98%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2/standard.png" alt="standard"></p>
<h3 id="RGB颜色"><a href="#RGB颜色" class="headerlink" title="RGB颜色"></a>RGB颜色</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">color.RGB(<span class="number">255</span>, <span class="number">128</span>, <span class="number">0</span>).Println(<span class="string">&quot;foreground orange&quot;</span>)</span><br><span class="line">color.RGB(<span class="number">230</span>, <span class="number">42</span>, <span class="number">42</span>).Println(<span class="string">&quot;foreground red&quot;</span>)</span><br><span class="line"></span><br><span class="line">color.BgRGB(<span class="number">255</span>, <span class="number">128</span>, <span class="number">0</span>).Println(<span class="string">&quot;background orange&quot;</span>)</span><br><span class="line">color.BgRGB(<span class="number">230</span>, <span class="number">42</span>, <span class="number">42</span>).Println(<span class="string">&quot;background red&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/03/26/Go%E6%94%B9%E5%8F%98%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2/RGB.png" alt="RGB"></p>
<h3 id="混合颜色"><a href="#混合颜色" class="headerlink" title="混合颜色"></a>混合颜色</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new color object</span></span><br><span class="line">c := color.New(color.FgCyan).Add(color.Underline)</span><br><span class="line">c.Println(<span class="string">&quot;Prints cyan text with an underline.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or just add them to New()</span></span><br><span class="line">d := color.New(color.FgCyan, color.Bold)</span><br><span class="line">d.Printf(<span class="string">&quot;This prints bold cyan %s\n&quot;</span>, <span class="string">&quot;too!.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mix up foreground and background colors, create new mixes!</span></span><br><span class="line">red := color.New(color.FgRed)</span><br><span class="line"></span><br><span class="line">boldRed := red.Add(color.Bold)</span><br><span class="line">boldRed.Println(<span class="string">&quot;This will print text in bold red.&quot;</span>)</span><br><span class="line"></span><br><span class="line">whiteBackground := red.Add(color.BgWhite)</span><br><span class="line">whiteBackground.Println(<span class="string">&quot;Red text with white background.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mix with RGB color codes</span></span><br><span class="line">color.RGB(<span class="number">255</span>, <span class="number">128</span>, <span class="number">0</span>).AddBgRGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).Println(<span class="string">&quot;orange with black background&quot;</span>)</span><br><span class="line"></span><br><span class="line">color.BgRGB(<span class="number">255</span>, <span class="number">128</span>, <span class="number">0</span>).AddRGB(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>).Println(<span class="string">&quot;orange background with white foreground&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/03/26/Go%E6%94%B9%E5%8F%98%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2/mix.png" alt="mix"></p>
<h3 id="配合fmt使用"><a href="#配合fmt使用" class="headerlink" title="配合fmt使用"></a>配合fmt使用</h3><p>在fmt中使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create SprintXxx functions to mix strings with other non-colorized strings:</span></span><br><span class="line">yellow := color.New(color.FgYellow).SprintFunc()</span><br><span class="line">red := color.New(color.FgRed).SprintFunc()</span><br><span class="line">fmt.Printf(<span class="string">&quot;This is a %s and this is %s.\n&quot;</span>, yellow(<span class="string">&quot;warning&quot;</span>), red(<span class="string">&quot;error&quot;</span>))</span><br><span class="line"></span><br><span class="line">info := color.New(color.FgWhite, color.BgGreen).SprintFunc()</span><br><span class="line">fmt.Printf(<span class="string">&quot;This %s rocks!\n&quot;</span>, info(<span class="string">&quot;package&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use helper functions</span></span><br><span class="line">fmt.Println(<span class="string">&quot;This&quot;</span>, color.RedString(<span class="string">&quot;warning&quot;</span>), <span class="string">&quot;should be not neglected.&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %v\n&quot;</span>, color.GreenString(<span class="string">&quot;Info:&quot;</span>), <span class="string">&quot;an important message.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows supported too! Just don&#x27;t forget to change the output to color.Output</span></span><br><span class="line">fmt.Fprintf(color.Output, <span class="string">&quot;Windows support: %s&quot;</span>, color.GreenString(<span class="string">&quot;PASS&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><img src="/2025/03/26/Go%E6%94%B9%E5%8F%98%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2/fmt.png" alt="fmt"></p>
<p>插入fmt打印</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use handy standard colors</span></span><br><span class="line">color.Set(color.FgYellow)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Existing text will now be in yellow&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;This one %s\n&quot;</span>, <span class="string">&quot;too&quot;</span>)</span><br><span class="line"></span><br><span class="line">color.Unset() <span class="comment">// Don&#x27;t forget to unset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can mix up parameters</span></span><br><span class="line">color.Set(color.FgMagenta, color.Bold)</span><br><span class="line"><span class="keyword">defer</span> color.Unset() <span class="comment">// Use it in your function</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;All text will now be bold magenta.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2025/03/26/Go%E6%94%B9%E5%8F%98%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2/insertfmt.png" alt="insertfmt"></p>
<h2 id="配合Logrus日志库打印出带颜色的日志"><a href="#配合Logrus日志库打印出带颜色的日志" class="headerlink" title="配合Logrus日志库打印出带颜色的日志"></a>配合Logrus日志库打印出带颜色的日志</h2><p>我们需要定义一个继承<strong>logrus.TextFormatter</strong>的结构体<strong>CustomTextFormatter</strong>，并实现<strong>Format</strong>方法来自定义日志的输出格式。还需要将<strong>Logrus</strong>实例的<strong>Formatter</strong>设置为自定义格式化器<strong>CustomTextFormatter</strong>。而不是直接使用<strong>logrus.TextFormatter</strong>。</p>
<p>在<strong>CustomTextFormatter</strong>结构体中，我们添加了<strong>ForceColors</strong>属性以及四个<strong>color.Color</strong>用于不同级别的日志消息。</p>
<p>同时在<strong>CustomTextFormatter</strong>的<strong>Format</strong>方法中根据日志级别选择设置对应的自定义颜色并打印日志消息。如果<strong>ForceColors</strong>为<strong>true</strong>，则使用定义的颜色样式来打印日志；否则，调用父类的<strong>TextFormatter.Format</strong>方法进行默认的格式化操作。</p>
<p><strong>PrintColored</strong>方法用于默认颜色的方式打印日志条目。它将日志级别添加到消息前面，并根据需要添加调用者信息。最后，通过调用**fmt.Fprintln(color.Output, msg)**将带颜色的消息打印到终端。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局的Logger变量</span></span><br><span class="line"><span class="keyword">var</span> Logg *logrus.Logger</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义格式化器，继承自logrus.TextFormatter</span></span><br><span class="line"><span class="keyword">type</span> ColorLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">	logrus.TextFormatter</span><br><span class="line">	ForceColors   <span class="type">bool</span></span><br><span class="line">	ColorInfo     *color.Color</span><br><span class="line">	ColorWarning  *color.Color</span><br><span class="line">	ColorError    *color.Color</span><br><span class="line">	ColorCritical *color.Color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化方法，用于将日志条目格式化为字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ColorLogger)</span></span> Format(entry *logrus.Entry) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> c.ForceColors &#123;</span><br><span class="line">    <span class="comment">// 按日志级别更改日志颜色</span></span><br><span class="line">		<span class="keyword">switch</span> entry.Level &#123;</span><br><span class="line">		<span class="keyword">case</span> logrus.InfoLevel:</span><br><span class="line">			c.ColorInfo.Println(entry.Message)</span><br><span class="line">		<span class="keyword">case</span> logrus.WarnLevel:</span><br><span class="line">			c.ColorWarning.Println(entry.Message)</span><br><span class="line">		<span class="keyword">case</span> logrus.ErrorLevel:</span><br><span class="line">			c.ColorError.Println(entry.Message)</span><br><span class="line">		<span class="keyword">case</span> logrus.FatalLevel, logrus.PanicLevel:</span><br><span class="line">			c.ColorCritical.Println(entry.Message)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			c.PrintColored(entry)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c.TextFormatter.Format(entry)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义方法，用于将日志条目以带颜色的方式打印出来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ColorLogger)</span></span> PrintColored(entry *logrus.Entry) &#123;</span><br><span class="line">	levelColor := color.New(color.FgCyan, color.Bold)             <span class="comment">// 定义蓝色和粗体样式</span></span><br><span class="line">	levelText := levelColor.Sprintf(<span class="string">&quot;%-6s&quot;</span>, entry.Level.String()) <span class="comment">// 格式化日志级别文本</span></span><br><span class="line"></span><br><span class="line">	msg := levelText + <span class="string">&quot; &quot;</span> + entry.Message</span><br><span class="line">	<span class="keyword">if</span> entry.HasCaller() &#123;</span><br><span class="line">		msg += <span class="string">&quot; (&quot;</span> + entry.Caller.File + <span class="string">&quot;:&quot;</span> + strconv.Itoa(entry.Caller.Line) + <span class="string">&quot;)&quot;</span> <span class="comment">// 添加调用者信息</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Fprintln(color.Output, msg) <span class="comment">// 使用有颜色的方式打印消息到终端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Logg = logrus.New()</span><br><span class="line">	Logg.Formatter = &amp;ColorLogger&#123;</span><br><span class="line">		ForceColors:   <span class="literal">true</span>,</span><br><span class="line">		ColorInfo:     color.New(color.FgBlue),</span><br><span class="line">		ColorWarning:  color.New(color.FgYellow),</span><br><span class="line">		ColorError:    color.New(color.FgRed),</span><br><span class="line">		ColorCritical: color.New(color.BgRed, color.FgWhite),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考自：<a href="https://blog.csdn.net/qq_20185737/article/details/133560820">Logrus 日志框架——自定义日志颜色_logrus日志颜色-CSDN博客</a></p>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记</title>
    <url>/2025/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h1><h2 id="1、SQL-语句分类"><a href="#1、SQL-语句分类" class="headerlink" title="1、SQL 语句分类"></a>1、SQL 语句分类</h2><table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">全称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DDL</td>
<td align="center">Data Definition Language</td>
<td align="center">数据定义语言，用来定义数据库对象（数据库、表、字段）</td>
</tr>
<tr>
<td align="center">DML</td>
<td align="center">Data Manipulation Language</td>
<td align="center">数据操作语言，用来对数据库表中的数据进行增删改</td>
</tr>
<tr>
<td align="center">DQL</td>
<td align="center">Data Query Language</td>
<td align="center">数据查询语言，用来查询数据库中的表的记录</td>
</tr>
<tr>
<td align="center">DCL</td>
<td align="center">Data Control Language</td>
<td align="center">数据控制语言，用来创建数据库用户、控制数据库访问权限</td>
</tr>
</tbody></table>
<h3 id="1-1-DDL"><a href="#1-1-DDL" class="headerlink" title="1.1 DDL"></a>1.1 DDL</h3><h4 id="1-1-1-数据库操作"><a href="#1-1-1-数据库操作" class="headerlink" title="1.1.1 数据库操作"></a>1.1.1 数据库操作</h4><h5 id="1-1-1-1-查询"><a href="#1-1-1-1-查询" class="headerlink" title="1.1.1.1 查询"></a>1.1.1.1 查询</h5><h6 id="查询所有数据库"><a href="#查询所有数据库" class="headerlink" title="查询所有数据库"></a>查询所有数据库</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure>

<h6 id="查询当前使用的数据库"><a href="#查询当前使用的数据库" class="headerlink" title="查询当前使用的数据库"></a>查询当前使用的数据库</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-1-2-创建"><a href="#1-1-1-2-创建" class="headerlink" title="1.1.1.2 创建"></a>1.1.1.2 创建</h5><h6 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 [<span class="keyword">DEFAULT</span> CHARSET 字符集] [<span class="keyword">COLLATE</span> 排序规则];</span><br></pre></td></tr></table></figure>

<h5 id="1-1-1-3-删除"><a href="#1-1-1-3-删除" class="headerlink" title="1.1.1.3 删除"></a>1.1.1.3 删除</h5><h6 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] 数据库名</span><br></pre></td></tr></table></figure>

<h5 id="1-1-1-4-使用"><a href="#1-1-1-4-使用" class="headerlink" title="1.1.1.4 使用"></a>1.1.1.4 使用</h5><h6 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-表操作"><a href="#1-1-2-表操作" class="headerlink" title="1.1.2 表操作"></a>1.1.2 表操作</h4><h5 id="1-1-2-1-查询"><a href="#1-1-2-1-查询" class="headerlink" title="1.1.2.1 查询"></a>1.1.2.1 查询</h5><h6 id="查询当前数据库所有表"><a href="#查询当前数据库所有表" class="headerlink" title="查询当前数据库所有表"></a>查询当前数据库所有表</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure>

<h6 id="查询表结构"><a href="#查询表结构" class="headerlink" title="查询表结构"></a>查询表结构</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> 表名;</span><br></pre></td></tr></table></figure>

<h6 id="查询指定表的建表语句"><a href="#查询指定表的建表语句" class="headerlink" title="查询指定表的建表语句"></a>查询指定表的建表语句</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-2-创建"><a href="#1-1-2-2-创建" class="headerlink" title="1.1.2.2 创建"></a>1.1.2.2 创建</h5><h6 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	字段类型 字段名 [COMMENT 字段注释],</span><br><span class="line">	字段类型 字段名 [COMMENT 字段注释],</span><br><span class="line">  ...</span><br><span class="line">	字段类型 字段名 [COMMENT 字段注释]</span><br><span class="line">)[COMMENT 表注释];</span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-3-修改"><a href="#1-1-2-3-修改" class="headerlink" title="1.1.2.3 修改"></a>1.1.2.3 修改</h5><h6 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 字段类型 [COMMENT 字段注释];</span><br></pre></td></tr></table></figure>

<h6 id="修改字段类型"><a href="#修改字段类型" class="headerlink" title="修改字段类型"></a>修改字段类型</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 字段类型;</span><br></pre></td></tr></table></figure>

<h6 id="修改字段名和字段类型"><a href="#修改字段名和字段类型" class="headerlink" title="修改字段名和字段类型"></a>修改字段名和字段类型</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 字段类型 [COMMENT 字段注释];</span><br></pre></td></tr></table></figure>

<h6 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名;</span><br></pre></td></tr></table></figure>

<h6 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 旧表名 RENAME <span class="keyword">TO</span> 新表名;</span><br></pre></td></tr></table></figure>

<h6 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] 表名;</span><br></pre></td></tr></table></figure>

<h6 id="删除表并重新创建"><a href="#删除表并重新创建" class="headerlink" title="删除表并重新创建"></a>删除表并重新创建</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-DML"><a href="#1-2-DML" class="headerlink" title="1.2 DML"></a>1.2 DML</h3><h4 id="1-2-1-添加数据"><a href="#1-2-1-添加数据" class="headerlink" title="1.2.1 添加数据"></a>1.2.1 添加数据</h4><h5 id="1-2-1-1-给指定字段添加数据"><a href="#1-2-1-1-给指定字段添加数据" class="headerlink" title="1.2.1.1 给指定字段添加数据"></a>1.2.1.1 给指定字段添加数据</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 (字段<span class="number">1</span>,字段<span class="number">2</span>,字段<span class="number">3.</span>..) <span class="keyword">VALUES</span> (值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3.</span>..),(值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3.</span>..)...;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-1-2-给所有字段添加数据"><a href="#1-2-1-2-给所有字段添加数据" class="headerlink" title="1.2.1.2 给所有字段添加数据"></a>1.2.1.2 给所有字段添加数据</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3.</span>..),(值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3.</span>..)...;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-修改数据"><a href="#1-2-2-修改数据" class="headerlink" title="1.2.2 修改数据"></a>1.2.2 修改数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>,字段<span class="number">2</span><span class="operator">=</span>值<span class="number">2.</span>.. [<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure>

<h4 id="1-2-3-删除数据"><a href="#1-2-3-删除数据" class="headerlink" title="1.2.3 删除数据"></a>1.2.3 删除数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure>

<h3 id="1-3-DQL"><a href="#1-3-DQL" class="headerlink" title="1.3 DQL"></a>1.3 DQL</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	字段列表</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	表名列表</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	分组字段列表</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">	分组后条件列表</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">	分页参数</span><br></pre></td></tr></table></figure>

<h4 id="1-3-1-基本查询"><a href="#1-3-1-基本查询" class="headerlink" title="1.3.1 基本查询"></a>1.3.1 基本查询</h4><h5 id="1-3-1-1-查询多个字段："><a href="#1-3-1-1-查询多个字段：" class="headerlink" title="1.3.1.1 查询多个字段："></a>1.3.1.1 查询多个字段：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span> [<span class="keyword">AS</span> 别名<span class="number">1</span>],字段<span class="number">2</span> [<span class="keyword">AS</span> 别名<span class="number">2</span>],字段<span class="number">3</span> [<span class="keyword">AS</span> 别名<span class="number">3</span>]... <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-1-2-去除重复记录："><a href="#1-3-1-2-去除重复记录：" class="headerlink" title="1.3.1.2 去除重复记录："></a>1.3.1.2 去除重复记录：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-条件查询"><a href="#1-3-2-条件查询" class="headerlink" title="1.3.2 条件查询"></a>1.3.2 条件查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件列表;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">比较运算符</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&gt;</td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left">&gt;&#x3D;</td>
<td align="left">大于等于</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left">&lt;&#x3D;</td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="left">&#x3D;</td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left">&lt;&gt; 或 !&#x3D;</td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="left">BETWEEN…AND…</td>
<td align="left">在某个范围之内（含最小、最大值）</td>
</tr>
<tr>
<td align="left">IN(…)</td>
<td align="left">在 IN 之后的列表中的值，多选一</td>
</tr>
<tr>
<td align="left">LIKE 占位符</td>
<td align="left">模糊匹配（_匹配单个字符，%匹配任意个字符）</td>
</tr>
<tr>
<td align="left">IS NULL</td>
<td align="left">是 NULL</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>AND 或 &amp;&amp;</td>
<td>并且（多个条件同时成立）</td>
</tr>
<tr>
<td>OR 或 ||</td>
<td>或者（多个条件任意一个成立）</td>
</tr>
<tr>
<td>NOT 或 !</td>
<td>非，条件不成立</td>
</tr>
</tbody></table>
<h4 id="1-3-3-聚合函数"><a href="#1-3-3-聚合函数" class="headerlink" title="1.3.3 聚合函数"></a>1.3.3 聚合函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>COUNT</td>
<td>统计数量</td>
</tr>
<tr>
<td>MAX</td>
<td>最大值</td>
</tr>
<tr>
<td>MIN</td>
<td>最小值</td>
</tr>
<tr>
<td>AVG</td>
<td>平均值</td>
</tr>
<tr>
<td>SUM</td>
<td>求和</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 聚合函数(字段名) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-4-分组查询"><a href="#1-3-4-分组查询" class="headerlink" title="1.3.4 分组查询"></a>1.3.4 分组查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件] <span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段名 [<span class="keyword">HAVING</span> 分组后的过滤条件];</span><br></pre></td></tr></table></figure>

<h5 id="where-和-having-的区别"><a href="#where-和-having-的区别" class="headerlink" title="where 和 having 的区别"></a><em><strong>where</strong></em> 和 <em><strong>having</strong></em> 的区别</h5><ul>
<li>执行时机不同：<em><strong>where</strong></em> 是分组之前进行过滤，不满足 <em><strong>where</strong></em> 条件不参与分组；<em><strong>having</strong></em> 是分组后对结果进行过滤。</li>
</ul>
<ul>
<li>判断条件不同：<em><strong>where</strong></em> 不能对聚合函数进行判断，而 <em><strong>having</strong></em> 可以。</li>
</ul>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>执行顺序：<em><strong>where</strong></em> &gt; 聚合函数 &gt; <em><strong>having</strong></em>。</li>
<li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。</li>
</ul>
<h4 id="1-3-5-排序查询"><a href="#1-3-5-排序查询" class="headerlink" title="1.3.5 排序查询"></a>1.3.5 排序查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>, 字段<span class="number">2</span> 排序方式<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h5 id="排序方式"><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h5><ul>
<li>ASC 升序</li>
<li>DESC 降序</li>
</ul>
<h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><p>如果是多字段排序，当<strong>第一个</strong>字段值<em><strong>相同</strong></em>时，才会根据<strong>第二个</strong>字段进行排序。</p>
<h4 id="1-3-6-分页查询"><a href="#1-3-6-分页查询" class="headerlink" title="1.3.6 分页查询"></a>1.3.6 分页查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT 起始索引, 查询记录数;</span><br></pre></td></tr></table></figure>

<h5 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>起始索引从 0 开始，起始索引 &#x3D;（查询页码 - 1）* 每页显示记录数。</li>
<li>分页查询是数据库的方言，不同数据库有不同实现，MySQL 是 LIMIT。</li>
<li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10。</li>
</ul>
<h4 id="1-3-7-执行顺序"><a href="#1-3-7-执行顺序" class="headerlink" title="1.3.7 执行顺序"></a>1.3.7 执行顺序</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> LIMIT</span><br></pre></td></tr></table></figure>

<h3 id="1-4-DCL"><a href="#1-4-DCL" class="headerlink" title="1.4 DCL"></a>1.4 DCL</h3><h4 id="1-4-1-管理用户"><a href="#1-4-1-管理用户" class="headerlink" title="1.4.1 管理用户"></a>1.4.1 管理用户</h4><h5 id="1-4-1-1-查询用户"><a href="#1-4-1-1-查询用户" class="headerlink" title="1.4.1.1 查询用户"></a>1.4.1.1 查询用户</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h5 id="1-4-2-创建用户"><a href="#1-4-2-创建用户" class="headerlink" title="1.4.2 创建用户"></a>1.4.2 创建用户</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br><span class="line"><span class="comment">-- 创建用户test，能在任意主机访问</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;test&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="1-4-3-修改用户密码："><a href="#1-4-3-修改用户密码：" class="headerlink" title="1.4.3 修改用户密码："></a>1.4.3 修改用户密码：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="1-4-4-删除用户："><a href="#1-4-4-删除用户：" class="headerlink" title="1.4.4 删除用户："></a>1.4.4 删除用户：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-2-权限控制"><a href="#1-4-2-权限控制" class="headerlink" title="1.4.2 权限控制"></a>1.4.2 权限控制</h4><h5 id="常用权限"><a href="#常用权限" class="headerlink" title="常用权限"></a>常用权限</h5><table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ALL, ALL PRIVILEGES</td>
<td>所有权限</td>
</tr>
<tr>
<td>SELECT</td>
<td>查询数据</td>
</tr>
<tr>
<td>INSERT</td>
<td>插入数据</td>
</tr>
<tr>
<td>UPDATE</td>
<td>修改数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除数据</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改表</td>
</tr>
<tr>
<td>DROP</td>
<td>删除数据库&#x2F;表&#x2F;视图</td>
</tr>
<tr>
<td>CREATE</td>
<td>创建数据库&#x2F;表</td>
</tr>
</tbody></table>
<h5 id="查询权限"><a href="#查询权限" class="headerlink" title="查询权限"></a>查询权限</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="撤销权限"><a href="#撤销权限" class="headerlink" title="撤销权限"></a>撤销权限</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>多个权限用逗号分隔</li>
<li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li>
</ul>
<h2 id="2、函数"><a href="#2、函数" class="headerlink" title="2、函数"></a>2、函数</h2><h3 id="2-1-字符串函数"><a href="#2-1-字符串函数" class="headerlink" title="2.1 字符串函数"></a>2.1 字符串函数</h3><h4 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CONCAT(s1, s2, …, sn)</td>
<td>字符串拼接，将s1, s2, …, sn 拼接成一个字符串</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>将字符串全部转为小写</td>
</tr>
<tr>
<td>UPPER(str)</td>
<td>将字符串全部转为大写</td>
</tr>
<tr>
<td>LPAD(str, n, pad)</td>
<td>左填充，用字符串 pad 对 str 的左边进行填充，达到 n 个字符串长度</td>
</tr>
<tr>
<td>RPAD(str, n, pad)</td>
<td>右填充，用字符串 pad 对 str 的右边进行填充，达到 n 个字符串长度</td>
</tr>
<tr>
<td>TRIM(str)</td>
<td>去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td>SUBSTRING(str, start, len)</td>
<td>返回从字符串 str 从 start 位置起的 len 个长度的字符串</td>
</tr>
<tr>
<td>REPLACE(column, source, replace)</td>
<td>替换字符串</td>
</tr>
</tbody></table>
<h3 id="2-2-数值函数"><a href="#2-2-数值函数" class="headerlink" title="2.2 数值函数"></a>2.2 数值函数</h3><h4 id="常见函数-1"><a href="#常见函数-1" class="headerlink" title="常见函数"></a>常见函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CEIL(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>MOD(x, y)</td>
<td>返回 x &#x2F; y 的模</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回 0 ~ 1内的随机数</td>
</tr>
<tr>
<td>ROUND(x, y)</td>
<td>求参数 x 的四舍五入值，保留 y 位小数</td>
</tr>
</tbody></table>
<h3 id="2-3-日期函数"><a href="#2-3-日期函数" class="headerlink" title="2.3 日期函数"></a>2.3 日期函数</h3><h4 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h4><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CURDATE()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>NOW()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>YEAR(date)</td>
<td>获取指定 date 的年份</td>
</tr>
<tr>
<td>MONTH(date)</td>
<td>获取指定 date 的月份</td>
</tr>
<tr>
<td>DAY(date)</td>
<td>获取指定 date 的日期</td>
</tr>
<tr>
<td>DATE_ADD(date, INTERVAL expr type)</td>
<td>返回一个日期&#x2F;时间值加上一个时间间隔 expr 后的时间值</td>
</tr>
<tr>
<td>DATEDIFF(date1, date2)</td>
<td>返回起始时间 date1 和结束时间 date2 之间的天数</td>
</tr>
</tbody></table>
<h3 id="2-4-流程函数"><a href="#2-4-流程函数" class="headerlink" title="2.4 流程函数"></a>2.4 流程函数</h3><h4 id="常用函数：-1"><a href="#常用函数：-1" class="headerlink" title="常用函数："></a>常用函数：</h4><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>IF(value, t, f)</td>
<td>如果 value 为 true，则返回 t，否则返回 f</td>
</tr>
<tr>
<td>IFNULL(value1, value2)</td>
<td>如果 value1 不为空，返回 value1，否则返回 value2</td>
</tr>
<tr>
<td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td>
<td>如果 val1 为 true，返回 res1，… 否则返回 default 默认值</td>
</tr>
<tr>
<td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td>
<td>如果 expr 的值等于 val1，返回 res1，… 否则返回 default 默认值</td>
</tr>
</tbody></table>
<h2 id="3、约束"><a href="#3、约束" class="headerlink" title="3、约束"></a>3、约束</h2><h3 id="3-1-分类"><a href="#3-1-分类" class="headerlink" title="3.1 分类"></a>3.1 分类</h3><table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>非空约束</td>
<td>限制该字段的数据不能为 null</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证该字段的所有数据都是唯一、不重复的</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段的值，则采用默认值</td>
<td>DEFAULT</td>
</tr>
<tr>
<td>检查约束（8.0.1版本后）</td>
<td>保证字段值满足某一个条件</td>
<td>CHECK</td>
</tr>
<tr>
<td>外键约束</td>
<td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td>
<td>FOREIGN KEY</td>
</tr>
</tbody></table>
<p>约束是作用于表中字段上的，可以再创建表&#x2F;修改表的时候添加约束。</p>
<h3 id="3-2-常见约束"><a href="#3-2-常见约束" class="headerlink" title="3.2 常见约束"></a>3.2 常见约束</h3><table>
<thead>
<tr>
<th align="left">约束条件</th>
<th align="left">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">主键</td>
<td align="left">PRIMARY KEY</td>
</tr>
<tr>
<td align="left">自动增长</td>
<td align="left">AUTO_INCREMENT</td>
</tr>
<tr>
<td align="left">不为空</td>
<td align="left">NOT NULL</td>
</tr>
<tr>
<td align="left">唯一</td>
<td align="left">UNIQUE</td>
</tr>
<tr>
<td align="left">逻辑条件</td>
<td align="left">CHECK</td>
</tr>
<tr>
<td align="left">默认值</td>
<td align="left">DEFAULT</td>
</tr>
</tbody></table>
<h3 id="3-3-外键约束"><a href="#3-3-外键约束" class="headerlink" title="3.3 外键约束"></a>3.3 外键约束</h3><p>外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p>
<h4 id="3-3-1-添加外键"><a href="#3-3-1-添加外键" class="headerlink" title="3.3.1 添加外键"></a>3.3.1 添加外键</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	字段名 字段类型,</span><br><span class="line">	...</span><br><span class="line">	[<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN</span> KEY(外键字段名) <span class="keyword">REFERENCES</span> 主表(主表列名)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表(主表列名) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> 行为 <span class="keyword">ON</span> <span class="keyword">DELETE</span> 行为;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例子</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key(dept_id) <span class="keyword">references</span> dept(id);</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-删除外键"><a href="#3-3-2-删除外键" class="headerlink" title="3.3.2 删除外键"></a>3.3.2 删除外键</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键名;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-删除-更新行为"><a href="#3-3-3-删除-更新行为" class="headerlink" title="3.3.3 删除&#x2F;更新行为"></a>3.3.3 删除&#x2F;更新行为</h4><table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NO ACTION</td>
<td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与 RESTRICT 一致）</td>
</tr>
<tr>
<td>RESTRICT</td>
<td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与 NO ACTION 一致）</td>
</tr>
<tr>
<td>CASCADE</td>
<td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录</td>
</tr>
<tr>
<td>SET NULL</td>
<td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td>
</tr>
<tr>
<td>SET DEFAULT</td>
<td>父表有变更时，子表将外键设为一个默认值（Innodb 不支持）</td>
</tr>
</tbody></table>
<h2 id="4、多表查询"><a href="#4、多表查询" class="headerlink" title="4、多表查询"></a>4、多表查询</h2><h3 id="4-1-多表关系"><a href="#4-1-多表关系" class="headerlink" title="4.1 多表关系"></a>4.1 多表关系</h3><h4 id="4-1-1-一对多"><a href="#4-1-1-一对多" class="headerlink" title="4.1.1 一对多"></a>4.1.1 一对多</h4><p>案例：部门与员工</p>
<p>关系：一个部门对应多个员工，一个员工对应一个部门。</p>
<p>实现：在多的一方建立外键，指向一的一方的主键。</p>
<h4 id="4-1-2-多对多"><a href="#4-1-2-多对多" class="headerlink" title="4.1.2 多对多"></a>4.1.2 多对多</h4><p>案例：学生与课程</p>
<p>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修。</p>
<p>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键。</p>
<h4 id="4-1-3-一对一"><a href="#4-1-3-一对一" class="headerlink" title="4.1.3 一对一"></a>4.1.3 一对一</h4><p>案例：用户与用户详情</p>
<p>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率。</p>
<p>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）。</p>
<h3 id="4-2-查询"><a href="#4-2-查询" class="headerlink" title="4.2 查询"></a>4.2 查询</h3><h4 id="4-2-1-内连接"><a href="#4-2-1-内连接" class="headerlink" title="4.2.1 内连接"></a>4.2.1 内连接</h4><h5 id="4-2-1-1-隐式内连接"><a href="#4-2-1-1-隐式内连接" class="headerlink" title="4.2.1.1 隐式内连接"></a>4.2.1.1 隐式内连接</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>, 表<span class="number">2</span> <span class="keyword">WHERE</span> 条件 ...;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-1-2-显式内连接"><a href="#4-2-1-2-显式内连接" class="headerlink" title="4.2.1.2 显式内连接"></a>4.2.1.2 显式内连接</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [ <span class="keyword">INNER</span> ] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件 ...;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-外连接"><a href="#4-2-2-外连接" class="headerlink" title="4.2.2 外连接"></a>4.2.2 外连接</h4><h5 id="4-2-2-1-左外连接"><a href="#4-2-2-1-左外连接" class="headerlink" title="4.2.2.1 左外连接"></a>4.2.2.1 左外连接</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> [ <span class="keyword">OUTER</span> ] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件 ...;</span><br></pre></td></tr></table></figure>

<p>查询左表所有数据，以及两张表交集部分数据。</p>
<h5 id="4-2-2-2-右外连接"><a href="#4-2-2-2-右外连接" class="headerlink" title="4.2.2.2 右外连接"></a>4.2.2.2 右外连接</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> [ <span class="keyword">OUTER</span> ] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件 ...;</span><br></pre></td></tr></table></figure>

<p>查询右表所有数据，以及两张表交集部分数据。</p>
<h4 id="4-2-3-自连接"><a href="#4-2-3-自连接" class="headerlink" title="4.2.3 自连接"></a>4.2.3 自连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A 别名A <span class="keyword">JOIN</span> 表A 别名B <span class="keyword">ON</span> 条件 ...;</span><br></pre></td></tr></table></figure>

<p>当前表与自身的连接查询，自连接必须使用表别名。</p>
<h4 id="4-2-4-联合查询"><a href="#4-2-4-联合查询" class="headerlink" title="4.2.4 联合查询"></a>4.2.4 联合查询</h4><p>把多次查询的结果合并，形成一个新的查询集。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A ...</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B ...</span><br></pre></td></tr></table></figure>

<h5 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>UNION ALL 会有重复结果，UNION 不会。</li>
<li>联合查询比使用 or 效率高，不会使索引失效。</li>
<li>字段列表必须保持一致。</li>
</ul>
<h4 id="4-2-5-子查询"><a href="#4-2-5-子查询" class="headerlink" title="4.2.5 子查询"></a>4.2.5 子查询</h4><p>SQL 语句中嵌套 SELECT 语句，称谓嵌套查询，又称子查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> column1 <span class="operator">=</span> ( <span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure>

<p>子查询外部的语句可以是 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个。</p>
<p>根据子查询结果可以分为：</p>
<ul>
<li>标量子查询（子查询结果为单个值）</li>
<li>列子查询（子查询结果为一列）</li>
<li>行子查询（子查询结果为一行）</li>
<li>表子查询（子查询结果为多行多列）</li>
</ul>
<p>根据子查询位置可分为：</p>
<ul>
<li>WHERE 之后</li>
<li>FROM 之后</li>
<li>SELECT 之后</li>
</ul>
<h5 id="4-2-5-1-标量子查询"><a href="#4-2-5-1-标量子查询" class="headerlink" title="4.2.5.1 标量子查询"></a>4.2.5.1 标量子查询</h5><p>常用操作符：- &lt; &gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询销售部所有员工</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>;</span><br><span class="line"><span class="comment">-- 根据销售部部门ID，查询员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> dept <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 合并（子查询）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> dept <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="4-2-5-1-列子查询"><a href="#4-2-5-1-列子查询" class="headerlink" title="4.2.5.1 列子查询"></a>4.2.5.1 列子查询</h5><p>常用操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>在指定的集合范围内，多选一</td>
</tr>
<tr>
<td>NOT IN</td>
<td>不在指定的集合范围内</td>
</tr>
<tr>
<td>ANY</td>
<td>子查询返回列表中，有任意一个满足即可</td>
</tr>
<tr>
<td>SOME</td>
<td>与 ANY 等同，使用 SOME 的地方都可以使用 ANY</td>
</tr>
<tr>
<td>ALL</td>
<td>子查询返回列表的所有值都必须满足</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询销售部和市场部的所有员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> dept <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查询比财务部所有人工资都高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> salary <span class="keyword">from</span> employee <span class="keyword">where</span> dept <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>));</span><br><span class="line"><span class="comment">-- 查询比研发部任意一人工资高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">any</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> employee <span class="keyword">where</span> dept <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="4-2-5-3-行子查询"><a href="#4-2-5-3-行子查询" class="headerlink" title="4.2.5.3 行子查询"></a>4.2.5.3 行子查询</h5><p>常用操作符：&#x3D;, &lt;, &gt;, IN, NOT IN</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询与xxx的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> (salary, manager) <span class="operator">=</span> (<span class="keyword">select</span> salary, manager <span class="keyword">from</span> employee <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="4-2-5-4-表子查询"><a href="#4-2-5-4-表子查询" class="headerlink" title="4.2.5.4 表子查询"></a>4.2.5.4 表子查询</h5><p>常用操作符：IN</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询与xxx1，xxx2的职位和薪资相同的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> (job, salary) <span class="keyword">in</span> (<span class="keyword">select</span> job, salary <span class="keyword">from</span> employee <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;xxx1&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;xxx2&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查询入职日期是2006-01-01之后的员工，及其部门信息</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>, d.<span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> <span class="string">&#x27;2006-01-01&#x27;</span>) <span class="keyword">as</span> e <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">as</span> d <span class="keyword">on</span> e.dept <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure>

<h2 id="5、事务"><a href="#5、事务" class="headerlink" title="5、事务"></a>5、事务</h2><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<h3 id="5-1-事务操作"><a href="#5-1-事务操作" class="headerlink" title="5.1 事务操作"></a>5.1 事务操作</h3><h4 id="5-1-1-方式一"><a href="#5-1-1-方式一" class="headerlink" title="5.1.1 方式一"></a>5.1.1 方式一</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看/设置事务提交方式</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@AUTOCOMMIT</span>;</span><br><span class="line"><span class="comment">-- 0 代表手动提交，1 代表自动提交</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@AUTOCOMMIT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-2-方式二"><a href="#5-1-2-方式二" class="headerlink" title="5.1.2 方式二"></a>5.1.2 方式二</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION 或 <span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-事务特性（ACID）"><a href="#5-2-事务特性（ACID）" class="headerlink" title="5.2 事务特性（ACID）"></a>5.2 事务特性（ACID）</h3><ul>
<li>原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态。</li>
<li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li>
<li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<h3 id="5-3-事务问题"><a href="#5-3-事务问题" class="headerlink" title="5.3 事务问题"></a>5.3 事务问题</h3><table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>脏读</td>
<td>一个事务读到另一个事务还没提交的数据</td>
</tr>
<tr>
<td>不可重复读</td>
<td>一个事务先后读取同一条记录，但两次读取的数据不同</td>
</tr>
<tr>
<td>幻读</td>
<td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td>
</tr>
</tbody></table>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable Read(默认)</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<ul>
<li>√ 表示在当前隔离级别下该问题会出现。</li>
<li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看事务隔离级别：</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@TRANSACTION_ISOLATION</span>;</span><br><span class="line"><span class="comment">-- 设置事务隔离级别：</span></span><br><span class="line"><span class="keyword">SET</span> [SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED <span class="operator">|</span> READ COMMITTED <span class="operator">|</span> REPEATABLE READ <span class="operator">|</span> SERIALIZABLE&#125;;</span><br><span class="line"><span class="comment">-- SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</span></span><br></pre></td></tr></table></figure>

<h2 id="6、性能分析"><a href="#6、性能分析" class="headerlink" title="6、性能分析"></a>6、性能分析</h2><h3 id="6-1-查看-SQL-执行频率"><a href="#6-1-查看-SQL-执行频率" class="headerlink" title="6.1 查看 SQL 执行频率"></a>6.1 查看 SQL 执行频率</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Com_______&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-慢查询日志"><a href="#6-2-慢查询日志" class="headerlink" title="6.2 慢查询日志"></a>6.2 慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p>
<p>MySQL 的慢查询日志默认没有开启，需要在 MySQL 的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启慢查询日志开关</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log</span></span><br></pre></td></tr></table></figure>

<p>查看慢查询日志开关状态：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-PROFILE"><a href="#6-3-PROFILE" class="headerlink" title="6.3 PROFILE"></a>6.3 PROFILE</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@have_profiling</span>;</span><br></pre></td></tr></table></figure>

<p>profiling 默认关闭，可以通过set语句在session&#x2F;global级别开启 profiling：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>查看所有语句的耗时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> profiles;</span><br></pre></td></tr></table></figure>

<p>查看指定query_id的SQL语句各个阶段的耗时：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure>

<p>查看指定query_id的SQL语句CPU的使用情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-EXPLAIN"><a href="#6-3-EXPLAIN" class="headerlink" title="6.3 EXPLAIN"></a>6.3 EXPLAIN</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 直接在<span class="keyword">select</span>语句之前加上关键字 explain <span class="operator">/</span> <span class="keyword">desc</span></span><br><span class="line">[EXPLAIN<span class="operator">|</span><span class="keyword">DESC</span>] <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 HWERE 条件;</span><br></pre></td></tr></table></figure>

<p>EXPLAIN 各字段含义：</p>
<ul>
<li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li>
<li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</li>
<li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li>
<li>possible_key：可能应用在这张表上的索引，一个或多个</li>
<li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li>
<li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li>
<li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li>
<li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li>
</ul>
<h1 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h1><p>优点：</p>
<ul>
<li>提高数据检索效率，降低数据库的 IO 成本。</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 的消耗。</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引列也是要占用空间的。</li>
<li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE。</li>
</ul>
<h2 id="1、索引结构"><a href="#1、索引结构" class="headerlink" title="1、索引结构"></a>1、索引结构</h2><p>MySQL 的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：</p>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>B+Tree</td>
<td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td>
</tr>
<tr>
<td>Hash</td>
<td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td>
</tr>
<tr>
<td>R-Tree(空间索引)</td>
<td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>
</tr>
<tr>
<td>Full-Text(全文索引)</td>
<td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene，Solr，ES</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B+Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-Tree索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6 版本后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</p>
<ul>
<li>相对于二叉树，层级更少，搜索效率高。</li>
<li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低。</li>
<li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作。</li>
</ul>
<h2 id="2、索引分类"><a href="#2、索引分类" class="headerlink" title="2、索引分类"></a>2、索引分类</h2><table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建，只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引（Clustered Index）</td>
<td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td>
<td>必须有，而且只有一个</td>
</tr>
<tr>
<td>二级索引（Secondary Index）</td>
<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody></table>
<p>聚集索引选取规则：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引。</li>
<li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li>
<li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引。</li>
</ul>
<p><img src="/2025/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/suoyin.png" alt="索引分类"></p>
<h2 id="3、索引语法"><a href="#3、索引语法" class="headerlink" title="3、索引语法"></a>3、索引语法</h2><h3 id="3-1-创建索引"><a href="#3-1-创建索引" class="headerlink" title="3.1 创建索引"></a>3.1 创建索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT ] INDEX index_name <span class="keyword">ON</span> table_name (index_col_name, ...);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-查看索引"><a href="#3-2-查看索引" class="headerlink" title="3.2 查看索引"></a>3.2 查看索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-删除索引"><a href="#3-3-删除索引" class="headerlink" title="3.3 删除索引"></a>3.3 删除索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure>

<h2 id="4、使用规则"><a href="#4、使用规则" class="headerlink" title="4、使用规则"></a>4、使用规则</h2><h3 id="4-1-最左前缀法则"><a href="#4-1-最左前缀法则" class="headerlink" title="4.1 最左前缀法则"></a>4.1 最左前缀法则</h3><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。</p>
<p>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p>
<p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。</p>
<h3 id="4-2-索引失效情况"><a href="#4-2-索引失效情况" class="headerlink" title="4.2 索引失效情况"></a>4.2 索引失效情况</h3><ol>
<li>在索引列上进行运算操作，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;;</code></li>
<li>字符串类型字段使用时，不加引号，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处 phone 的值没有加引号</li>
<li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like &#39;%工程&#39;;</code>，前后都有 % 也会失效。</li>
<li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li>
<li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</li>
</ol>
<h3 id="4-3-SQL-提示"><a href="#4-3-SQL-提示" class="headerlink" title="4.3 SQL 提示"></a>4.3 SQL 提示</h3><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p>
<p>例如，使用索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index(idx_user_pro) <span class="keyword">where</span> profession<span class="operator">=</span>&quot;软件工程&quot;;</span><br></pre></td></tr></table></figure>

<p>不使用哪个索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index(idx_user_pro) <span class="keyword">where</span> profession<span class="operator">=</span>&quot;软件工程&quot;;</span><br></pre></td></tr></table></figure>

<p>必须使用哪个索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index(idx_user_pro) <span class="keyword">where</span> profession<span class="operator">=</span>&quot;软件工程&quot;;</span><br></pre></td></tr></table></figure>

<p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force 就是无论如何都强制使用该索引。</p>
<h3 id="4-4-覆盖索引"><a href="#4-4-覆盖索引" class="headerlink" title="4.4 覆盖索引"></a>4.4 覆盖索引</h3><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p>
<p>explain 中 extra 字段含义：</p>
<p><strong>using index condition</strong>：查找使用了索引，但是需要回表查询数据。</p>
<p>**using where; using index;**：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询。</p>
<h3 id="4-5-前缀索引"><a href="#4-5-前缀索引" class="headerlink" title="4.5 前缀索引"></a>4.5 前缀索引</h3><p>当字段类型为字符串（varchar，text 等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘 IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- n 指截取前缀长度</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_xxxx <span class="keyword">ON</span> table_name(<span class="keyword">column</span>(n))</span><br></pre></td></tr></table></figure>

<p>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。</p>
<h3 id="4-6-单列索引-联合索引"><a href="#4-6-单列索引-联合索引" class="headerlink" title="4.6 单列索引&amp;联合索引"></a>4.6 单列索引&amp;联合索引</h3><p>单列索引：即一个索引只包含单个列。</p>
<p>联合索引：即一个索引包含了多个列。</p>
<p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>
<h3 id="4-7-设计原则"><a href="#4-7-设计原则" class="headerlink" title="4.7 设计原则"></a>4.7 设计原则</h3><ol>
<li>针对于数据量较大，且查询比较频繁的表建立索引。</li>
<li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li>
<li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引。</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率。</li>
<li>如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ol>
<h1 id="三、SQL-优化"><a href="#三、SQL-优化" class="headerlink" title="三、SQL 优化"></a>三、SQL 优化</h1><h2 id="1、插入数据"><a href="#1、插入数据" class="headerlink" title="1、插入数据"></a>1、插入数据</h2><ul>
<li><p>采用批量插入（一次插入的数据不建议超过 1000 条）</p>
</li>
<li><p>手动提交事务</p>
</li>
<li><p>主键顺序插入</p>
</li>
</ul>
<p>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数 <span class="comment">--local-infile（这一行在bash/cmd界面输入）</span></span><br><span class="line">mysql <span class="comment">--local-infile -u root -p</span></span><br><span class="line"># 设置全局参数local_infile为<span class="number">1</span>，开启从本地加载文件导入数据的开关</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@local_infile</span>;</span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;xxxx&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">&#x27;xxxx&#x27;</span> fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2、主键优化"><a href="#2、主键优化" class="headerlink" title="2、主键优化"></a>2、主键优化</h2><p>数据组织方式：在 InnoDB 存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为<strong>索引组织表</strong>（Index organized table, IOT）。</p>
<p>主键设计原则：</p>
<ul>
<li>满足业务需求的情况下，尽量降低主键的长度。</li>
<li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键。</li>
<li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号。</li>
<li>业务操作时，避免对主键的修改。</li>
</ul>
<h2 id="3、ORDER-BY-优化"><a href="#3、ORDER-BY-优化" class="headerlink" title="3、ORDER BY 优化"></a>3、ORDER BY 优化</h2><ol>
<li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</li>
<li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</li>
</ol>
<p>如果 order by 字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain 的 extra 信息显示的是<code>Using index, Using filesort</code>，如果要优化掉 <code>Using filesort</code>，则需要另外再创建一个索引，</p>
<ul>
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li>
<li>尽量使用覆盖索引。</li>
<li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）。</li>
<li>如果不可避免出现 filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）。</li>
</ul>
<h2 id="4、GROUP-BY-优化"><a href="#4、GROUP-BY-优化" class="headerlink" title="4、GROUP BY 优化"></a>4、GROUP BY 优化</h2><ul>
<li>在分组操作时，可以通过索引来提高效率。</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的。</li>
</ul>
<h2 id="5、LIMMIT-优化"><a href="#5、LIMMIT-优化" class="headerlink" title="5、LIMMIT 优化"></a>5、LIMMIT 优化</h2><p>常见的问题如 <code>limit 2000000, 10</code>，此时需要 MySQL 排序前 2000000 条记录，但仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大。</p>
<p>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 此语句耗时很长</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku limit <span class="number">9000000</span>, <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">9000000</span>, <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit</span></span><br><span class="line"><span class="comment">-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</span></span><br><span class="line"><span class="comment">-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku <span class="keyword">as</span> s, (<span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">9000000</span>, <span class="number">10</span>) <span class="keyword">as</span> a <span class="keyword">where</span> s.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure>

<h2 id="6、COUNT-优化"><a href="#6、COUNT-优化" class="headerlink" title="6、COUNT 优化"></a>6、COUNT 优化</h2><p>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。</p>
<p>优化方案：自己计数，如创建 key-value 表存储在内存或硬盘，或者是用 redis。</p>
<p>count 的几种用法：</p>
<ul>
<li>如果 count 函数的参数（count里面写的那个字段）不是 NULL（字段值不为 NULL），累计值就加一，最后返回累计值。</li>
<li>用法：count(*)、count(主键)、count(字段)、count(1)。</li>
<li>count(主键)  跟 count( * ) 一样，因为主键不能为空；count(字段) 只计算字段值不为 NULL 的行；count(1) 引擎会为每行添加一个 1，然后就 count 这个 1，返回结果也跟 count( * ) 一样；count(null) 返回 0。</li>
</ul>
<p>各种用法的性能：</p>
<ul>
<li>count(主键)：InnoDB 引擎会遍历整张表，把每行的主键 id 值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li>
<li>count(字段)：没有 not null 约束的话，InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为 null，不为 null，计数累加；有 not null 约束的话，InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li>
<li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li>
<li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li>
</ul>
<p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &#x3D; count( * )，所以尽量使用 count( * )。</p>
<h2 id="7、UPDATE-优化"><a href="#7、UPDATE-优化" class="headerlink" title="7、UPDATE 优化"></a>7、UPDATE 优化</h2><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p>
<p>如以下两条语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这句由于id有主键索引，所以只会锁这一行；</span></span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> <span class="keyword">no</span> <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这句由于 name 没有索引，所以会把整张表都锁住进行数据更新，解决方法是给 name 字段添加索引。</span></span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> <span class="keyword">no</span> <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;test&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="四、锁"><a href="#四、锁" class="headerlink" title="四、锁"></a>四、锁</h1><p>MySQL 中的锁，按照锁的粒度分，分为一下三类：</p>
<ol>
<li>全局锁：锁定数据库中的所有表。</li>
<li>表级锁：每次操作锁住整张表。</li>
<li>行级锁：每次操作锁住对应的行数据。</li>
</ol>
<h2 id="1、全局锁"><a href="#1、全局锁" class="headerlink" title="1、全局锁"></a>1、全局锁</h2><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p>
<p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<p>基本操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用全局锁：</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"><span class="comment">-- 释放全局锁：</span></span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>

<p>数据库中加全局锁，是一个比较重的操作，存在以下问题:</p>
<ol>
<li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li>
<li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li>
</ol>
<h2 id="2、表级锁"><a href="#2、表级锁" class="headerlink" title="2、表级锁"></a>2、表级锁</h2><p>每次操作锁住整张表。锁定粒度大，发生锁的冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p>
<p>对于表级锁，主要分为一下三类：</p>
<ol>
<li>表锁</li>
<li>元数据锁（meta data lock，MDL）</li>
<li>意向锁</li>
</ol>
<h3 id="2-1-表锁"><a href="#2-1-表锁" class="headerlink" title="2.1 表锁"></a>2.1 表锁</h3><p>对于表锁，分为两类：</p>
<ol>
<li>表共享读锁（read lock）</li>
<li>表独占写锁（write lock）</li>
</ol>
<p>读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 表级别的共享锁，也就是读锁；</span></span><br><span class="line"><span class="comment">-- 允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作。</span></span><br><span class="line">lock tebles t_student read;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表级锁的独占锁，也是写锁；</span></span><br><span class="line"><span class="comment">-- 允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。</span></span><br><span class="line">lock tables t_stuent write;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 释放锁</span></span><br><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<h3 id="2-2-元数据锁"><a href="#2-2-元数据锁" class="headerlink" title="2.2 元数据锁"></a>2.2 元数据锁</h3><p>MDL 加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL 锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免 DML 与 DDL 冲突，保证读写的正确性。</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<table>
<thead>
<tr>
<th>对应SQL</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock tables xxx read &#x2F;write</td>
<td>SHARED_READ_ONLY&#x2F;SHARED_NO_READ_WRITE</td>
<td></td>
</tr>
<tr>
<td>select 、 select … lock in share mode</td>
<td>SHARED_READ</td>
<td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td>
</tr>
<tr>
<td>insert 、update、delete、select …for update</td>
<td>SHARED_WRITE</td>
<td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td>
</tr>
<tr>
<td>alter table …</td>
<td>EXCLYSIVE</td>
<td>与其他的MDL都互斥</td>
</tr>
</tbody></table>
<p>查看元数据锁：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> object_type,object_schema,object_name,lock_type,lock_duration <span class="keyword">from</span> performance_schema.metadata_locks;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-意向锁"><a href="#2-3-意向锁" class="headerlink" title="2.3 意向锁"></a>2.3 意向锁</h3><p>为了避免 DML 在执行时，加的行锁与表锁的冲突，在 InnoDB 中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p>
<p>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read)和独占表锁（lock tables … write）发生冲突。</p>
<p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p>
<p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p>
<p>意向锁的目的是为了快速判断表里是否有记录被加锁。</p>
<p>加锁方式：</p>
<ul>
<li><p>意向共享锁：（先在表上加上意向共享锁，然后对读取的记录加共享锁）</p>
<p>由 <code>select ... lock in share mode</code> 添加</p>
</li>
<li><p>意向独占锁：（先表上加上意向独占锁，然后对读取的记录加独占锁）</p>
<p>由 <code>insert、update、delete、select ... for update </code>添加</p>
</li>
</ul>
<h2 id="3、行级锁"><a href="#3、行级锁" class="headerlink" title="3、行级锁"></a>3、行级锁</h2><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB 存储引擎中。</p>
<ol>
<li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行 update 和 delete 。在 RC、RR 隔离级别下都支持。</li>
<li>间隙锁（GapLock）：锁定索引记录间隙(不含该记录)，确保索引记录间隙不变，防止其他事务在这个间隙进行 insert，产生幻读。在 RR 隔离级别下都支持。</li>
<li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙 Gap。在 RR 隔离级别下支持。</li>
</ol>
<h3 id="3-1-行锁"><a href="#3-1-行锁" class="headerlink" title="3.1 行锁"></a>3.1 行锁</h3><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分。</p>
<p>InnoDB实现了以下两种类型的行锁：</p>
<ol>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li>
<li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>S（共享锁）</th>
<th>X（排他锁）</th>
</tr>
</thead>
<tbody><tr>
<td>S（共享锁）</td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td>X（排他锁）</td>
<td>冲突</td>
<td>冲突</td>
</tr>
</tbody></table>
<p>行锁类型：</p>
<table>
<thead>
<tr>
<th>SQL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>insert，update，delete …</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>select</td>
<td>不加任何锁</td>
<td></td>
</tr>
<tr>
<td>select … lock in share mode</td>
<td>共享锁</td>
<td>需要手动 select 之后加上 lock in share mode</td>
</tr>
<tr>
<td>select … for update</td>
<td>排他锁</td>
<td>需要手动在 select 之后 for update</td>
</tr>
</tbody></table>
<p>默认情况下，InnoDB 在 REPEATABLE READ 事务隔离级别运行，InnoDB 使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p>
<ol>
<li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li>
<li>InnoDB 的行锁是针对于索引加的锁，不通过索引条件检索数据，那么 InnoDB 将对表中的所有记录加锁，此时就会升级为表锁。</li>
</ol>
<p>查看意向锁及行锁的加锁情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> peformance_schema.data_locks;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-间隙锁"><a href="#3-2-间隙锁" class="headerlink" title="3.2 间隙锁"></a>3.2 间隙锁</h3><p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p>
<p>假设，表中有一个范围 id 为 (3, 5) 间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发送。</p>
<p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。</p>
<h3 id="3-3-临键锁"><a href="#3-3-临键锁" class="headerlink" title="3.3 临键锁"></a>3.3 临键锁</h3><p>Next-Key Lock 称为临键锁，是行锁和间隙锁的组合，锁定一个范围，并且锁定记录本身。</p>
<p>默认情况下，InnoDB 在 REPEATABLE READ 事务隔离级别运行，InnoDB 使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p>
<ol>
<li>索引上的等值查询（唯一索引），给不存在的记录加锁时,优化为间隙锁 。</li>
<li>索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。</li>
<li>索引上的范围查询（唯一索引）–会访问到不满足条件的第一个值为止。</li>
</ol>
<h1 id="五、InnoDB-引擎"><a href="#五、InnoDB-引擎" class="headerlink" title="五、InnoDB 引擎"></a>五、InnoDB 引擎</h1><h2 id="1、逻辑存储结构"><a href="#1、逻辑存储结构" class="headerlink" title="1、逻辑存储结构"></a>1、逻辑存储结构</h2><p><img src="/2025/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/luojicunchu.png" alt="逻辑存储结构"></p>
<h2 id="2、架构"><a href="#2、架构" class="headerlink" title="2、架构"></a>2、架构</h2><h3 id="2-1-内存结构"><a href="#2-1-内存结构" class="headerlink" title="2.1 内存结构"></a>2.1 内存结构</h3><p><img src="/2025/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/bufferpool.png" alt="缓冲池"></p>
<p><img src="/2025/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/changebuffer.png" alt="更改缓冲区"></p>
<p><img src="/2025/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/hashindex.png" alt="自适应 hash 索引"></p>
<p><img src="/2025/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/logbuffer.png" alt="日志缓冲区"></p>
<h3 id="2-2-磁盘结构"><a href="#2-2-磁盘结构" class="headerlink" title="2.2 磁盘结构"></a>2.2 磁盘结构</h3><p><img src="/2025/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/disk1.png" alt="磁盘结构"></p>
<p><img src="/2025/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/disk2.png" alt="磁盘结构"></p>
<h3 id="2-3-后台线程"><a href="#2-3-后台线程" class="headerlink" title="2.3 后台线程"></a>2.3 后台线程</h3><p><img src="/2025/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/thread.png" alt="后台线程"></p>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript高级程序设计</title>
    <url>/2024/08/06/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h1><h2 id="1、var"><a href="#1、var" class="headerlink" title="1、var"></a>1、var</h2><h3 id="1-1-变量提升"><a href="#1-1-变量提升" class="headerlink" title="1.1 变量提升"></a>1.1 变量提升</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码不会报错，因为使用 <font color="skyblue">var</font> 关键字声明的变量会自动提升到函数作用域顶部。</p>
<h3 id="1-2-函数作用域"><a href="#1-2-函数作用域" class="headerlink" title="1.2 函数作用域"></a>1.2 函数作用域</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// Matt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">//Matt</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-全局声明"><a href="#1-3-全局声明" class="headerlink" title="1.3 全局声明"></a>1.3 全局声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>) <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure>

<p>使用 <font color="skyblue">var</font> 在全局作用域中声明的变量会成为 <font color="red">window</font> 对象的属性。</p>
<h2 id="2、let"><a href="#2、let" class="headerlink" title="2、let"></a>2、let</h2><h3 id="2-1-块级作用域"><a href="#2-1-块级作用域" class="headerlink" title="2.1 块级作用域"></a>2.1 块级作用域</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">26</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// ReferenceError: age没有定义</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-暂时性死区"><a href="#2-2-暂时性死区" class="headerlink" title="2.2 暂时性死区"></a>2.2 暂时性死区</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// ReferenceError: age没有定义</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span></span><br></pre></td></tr></table></figure>

<p>在 <font color="skyblue">let</font> 声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出<font color="red">ReferenceError</font>。</p>
<h3 id="2-3-全局声明"><a href="#2-3-全局声明" class="headerlink" title="2.3 全局声明"></a>2.3 全局声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">26</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">age</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>使用 <font color="skyblue">let</font> 在全局作用域中声明的变量不会成为 <font color="red">window </font> 对象的属性。不过， <font color="skyblue">let</font> 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免 <font color="red">SyntaxError</font> ，必须确保页面不会重复声明同一个变量。</p>
<h2 id="3、const"><a href="#3、const" class="headerlink" title="3、const"></a>3、const</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">26</span></span><br><span class="line">age = <span class="number">36</span> <span class="comment">// TypeError：给常量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 也不允许重复声明</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span> <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 声明的作用域也是块</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure>

<h2 id="4、声明风格"><a href="#4、声明风格" class="headerlink" title="4、声明风格"></a>4、声明风格</h2><h3 id="4-1、不使用-var"><a href="#4-1、不使用-var" class="headerlink" title="4.1、不使用 var"></a>4.1、不使用 <font color="red">var</font></h3><p>只使用 <font color="skyblue">let</font> 和 <font color="skyblue">const</font> 有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p>
<h3 id="4-2、-const-优先，-let-次之"><a href="#4-2、-const-优先，-let-次之" class="headerlink" title="4.2、 const 优先， let 次之"></a>4.2、 <font color="skyblue">const</font> 优先， <font color="skyblue">let</font> 次之</h3><p>使用 <font color="skyblue">const</font> 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作，只在提前知道未来会有修改时，再使用 <font color="skyblue">let</font> 。</p>
<hr>
<h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><h2 id="1、typeof-操作符"><a href="#1、typeof-操作符" class="headerlink" title="1、typeof  操作符"></a>1、typeof  操作符</h2><p>对一个值使用typeof操作符会返回下列字符串之一：</p>
<ul>
<li>“undefined” 表示值<font color="orange"><em>未定义</em></font></li>
<li>“boolean” 表示值为<font color="orange"><em>布尔值</em></font></li>
<li>“string” 表示值为<font color="orange"><em>字符串</em></font></li>
<li>“number” 表示值为<font color="orange"><em>数值</em></font></li>
<li>“object” 表示值为<font color="orange"><em>对象</em></font>或<font color="orange"><em>null</em></font></li>
<li>“function” 表示值为<font color="orange"><em>函数</em></font></li>
<li>“symbol” 表示值为<font color="orange"><em>符号</em></font></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;some string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> message) <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(message)) <span class="comment">// &quot;string&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="2、Undefined-类型"><a href="#2、Undefined-类型" class="headerlink" title="2、Undefined 类型"></a>2、Undefined 类型</h2><p>使用 <font color="red">var</font> 和 <font color="red">let</font> 声明了变量但没有初始化时，就相当于给变量赋予了 <font color="blue">undefined</font> 值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message == <span class="literal">undefined</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="literal">undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message == <span class="literal">undefined</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>包含 <font color="blue">undefined</font> 值的变量跟未定义变量是有区别的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>但调用 <font color="blue">typeof</font> 时，返回的结果都是 <font color="blue">undefined</font> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> message) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> age) <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="3、Null-类型"><a href="#3、Null-类型" class="headerlink" title="3、Null 类型"></a>3、Null 类型</h2><p>Null 类型只有一个值，即特殊值 <font color="blue">null</font> 。逻辑上讲， <font color="blue">null</font> 值表示一个空对象指针，因此调用 typeof 会返回 <font color="red">“object”</font> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> car) <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p> <font color="blue">undefined</font> 值是由 <font color="blue">null</font> 值派生而来的，因此 ECMA-262 将它们定义为表面上相等：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="4、Boolean-类型"><a href="#4、Boolean-类型" class="headerlink" title="4、Boolean 类型"></a>4、Boolean 类型</h2><p>Boolean 类型有两个字面值： <font color="green">true</font> 和 <font color="red">false</font> 。这两个布尔值不同于数值，因此 <font color="green">true</font> 不等于1， <font color="red">false</font> 不等于0。注意布尔值是区分大小写的，因此 <font color="green">True</font> 和 <font color="red">False</font> 是有效的标识符，但不是布尔值。</p>
<p>Boolean() 转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为  <font color="green">true</font> 或 <font color="red">false</font> 的规则取决于数据类型和实际的值。下表总结了不同类型与布尔值之间的转换规则：</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">转换为 <font color="green">true</font> 的值</th>
<th align="center">转换为 <font color="red">false</font> 的值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Boolean</td>
<td align="center"><font color="green">true</font></td>
<td align="center"><font color="red">false</font></td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">非空字符串</td>
<td align="center">“”（空字符串）</td>
</tr>
<tr>
<td align="center">Number</td>
<td align="center">非零数值（包括无穷值）</td>
<td align="center">0、NaN</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="center">任意对象</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">Undefined</td>
<td align="center">N&#x2F;A（不存在）</td>
<td align="center">undefined</td>
</tr>
</tbody></table>
<h2 id="5、Number-类型"><a href="#5、Number-类型" class="headerlink" title="5、Number 类型"></a>5、Number 类型</h2><p>Number 类型使用 <font color="blue">IEEE 754</font> 格式表示整数和浮点数（在某些语言中也叫双精度值）。不同的数值类型相应地也有不用的数值字面量格式。</p>
<p>最基本的数值字面量格式是十进制整数，直接写出来即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intNum = <span class="number">55</span> <span class="comment">// 整数</span></span><br></pre></td></tr></table></figure>

<p>整数也可以用八进制（以 8 位基数）或十六进制（以 16 为基数）字面量表示。对于八进制字面量，第一个数字必须是零（0），然后是相应的八进制数字（数值 0 ~ 7）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> octalNum1 = <span class="number">070</span> <span class="comment">// 八进制的 56</span></span><br><span class="line"><span class="keyword">let</span> octalNum2 = <span class="number">079</span> <span class="comment">// 无效的八进制值，当成 79 处理</span></span><br><span class="line"><span class="keyword">let</span> octalNum3 = <span class="number">08</span> <span class="comment">// 无效的八进制值，当成 8 处理</span></span><br></pre></td></tr></table></figure>

<p>八进制字面量在严格模式下是无效的，会导致 JavaScript引擎抛出语法错误。（严格模式下，如果要表示八进制值，应该使用0o。）</p>
<h3 id="5-1-浮点值"><a href="#5-1-浮点值" class="headerlink" title="5.1 浮点值"></a>5.1 浮点值</h3><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span></span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">0.1</span></span><br><span class="line"><span class="keyword">let</span> floatNum3 = <span class="number">.1</span></span><br></pre></td></tr></table></figure>

<p>存储浮点值使用的内存空间是存储整数值的两倍。所以，在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换成整数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.</span> <span class="comment">// 小数点后面没有数字，当成整数 1 处理</span></span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">10.0</span> <span class="comment">// 小数点后面是零，当成整数 10 处理</span></span><br></pre></td></tr></table></figure>

<p>对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以 10 的给定次幂的数值。ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后面跟一个大写或小写的e，再加上一个要乘的10的多少次幂：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span> <span class="comment">// 等于31250000</span></span><br></pre></td></tr></table></figure>

<p>默认情况下 ECMAscript 会将小数点后至少包含 6 个零的浮点值转换为科学记数法（例如 0.000 000 3 会被转换为 3e - 7 ）。</p>
<p>浮点值的精确度最高可达到 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不是 0.3 ，而是 0.30000000000000004。由于这种微小的摄入错误，导致很难测试特定的浮点值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a + b == <span class="number">0.3</span>) &#123;              <span class="comment">// 别这样做</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;You get 0.3.&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里检测两个数值之和是否等于 0.3。如果两个数值分别是 0.05 和 0.25，或者 0.15 和 0.15，那没问题。但如果是 0.1 和 0.2，测试将失败。</p>
<h3 id="5-2-值的范围"><a href="#5-2-值的范围" class="headerlink" title="5.2 值的范围"></a>5.2 值的范围</h3><p>由于内存限制，ECMAScript 并不支持所有数值。ECMAScript 可以表示的最小数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是5e-324；可以表示的最大数值保存在 Number.MAX_VALUE 中，这个值在多数浏览器中是 1.7976931348623157e+308。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity 值。正数用 Infinity 表示，负数用 -Infinity 表示。如果计算返回 Infinity ，将不能再进一步用于任何计算，这是因为 Infinity 没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以用 <font color="blue">isFinite()</font> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span> + <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isFinite</span>(result)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>使用 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以获取 Infinity。这两个属性包含的值分别就是 -Infinity 和 Infinity。</p>
<h3 id="5-3-NaN"><a href="#5-3-NaN" class="headerlink" title="5.3 NaN"></a>5.3 NaN</h3><p>有一个特殊的数值叫<font color="red"> NaN（Not a Number）</font>，用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任何数值在其他语言中通常都会导致错误，从而种植代码执行。但在 ECMAScript 中，0、+0 或 -0 相除都会返回<font color="red"> NaN</font>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>/<span class="number">0</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span>/+<span class="number">0</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>如果<font color="blue">分子</font>是非 0 值，<font color="green">分母</font>是有符号 0 或无符号 0，则会返回 Infinity 或 -Infinity：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>/<span class="number">0</span>) <span class="comment">// Infinity</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>/-<span class="number">0</span>) <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>

<p><font color="red">NaN</font> 有几个独特的属性。首先，任何涉及 <font color="red">NaN</font> 的操作始终返回 <font color="red">NaN</font>（如 <font color="red">NaN</font>&#x2F;10），在连续多步计算时这可能是个问题。其次，<font color="red">NaN</font> 不包括 <font color="red">NaN</font> 在内的任何值。例如：下面的比较操作会返回 <font color="red">false</font>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> == <span class="title class_">NaN</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>为此，ECMAScript 提供了 <font color="blue">isNaN()</font> 函数。该函数接收一个参数判断是否“不是数值”，会尝试把参数转换为数值。某些非数值的值可以直接转换成数值，如字符串 “10” 或布尔值。不能转换为数值的值都会导致这个函数返回 <font color="green">true</font>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="number">10</span>)) <span class="comment">// false，10是数值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>)) <span class="comment">// false，可以转换为数值10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>)) <span class="comment">// true，不可以转换为数值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="literal">true</span>)) <span class="comment">// false，可以转换为数值1</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4-数值转换"><a href="#5-4-数值转换" class="headerlink" title="5.4 数值转换"></a>5.4 数值转换</h3><p>有 3 个函数可以将非数值转换为数值：<font color="skyblue">Number()</font>、<font color="skyblue">parseInt()</font>、<font color="skyblue">parseFloat()</font>。<font color="skyblue">Number()</font> 是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这 3 个函数执行的操作也不同。</p>
<p><font color="skyblue">Number()</font> 函数基于如下规则执行转换：</p>
<ul>
<li><p>布尔值，<font color="green">true</font> 转换为 1，<font color="red">false</font> 转换为 0。</p>
</li>
<li><p>数值，直接返回。</p>
</li>
<li><p><font color="red">null</font>，返回 0。</p>
</li>
<li><p><font color="red">undefined</font>，返回 <font color="red">NaN</font>。</p>
</li>
<li><p>字符串，应用以下规则：</p>
<ul>
<li>如果字符串包括数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此<font color="skyblue">Number(“1”)</font> 返回 1，<font color="skyblue">Number(“123”)</font> 返回 123，<font color="skyblue">Number(“011”)</font> 返回 11（忽略前面的零）。</li>
<li>如果字符串包含有效的浮点值格式如 “1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。</li>
<li>如果字符串包含有效的十六进制格式如 “0xf”，则会转换为与该十六进制值对应的十进制整数值。</li>
<li>如果是空字符串（不包含字符），则返回 0。</li>
<li>如果字符串包含除上述情况之外的其他字符，则返回 <font color="red">NaN</font>。</li>
</ul>
</li>
<li><p>对象，调用 <font color="blue">valueOf()</font> 方法，并按照上述规则转换返回的值。如果转换结果是 <font color="red">NaN</font>，则调用 <font color="blue">toString()</font> 方法，再按照转换字符串的规则转换。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="title class_">Number</span>(<span class="string">&quot;000011&quot;</span>) <span class="comment">// 11</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC学习笔记</title>
    <url>/2025/03/18/RPC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、RPC简介"><a href="#一、RPC简介" class="headerlink" title="一、RPC简介"></a>一、RPC简介</h1><p>RPC：<em><strong>Remote Procedure Call Protocol</strong></em>（远程过程调用）底层是TCP协议。</p>
<h1 id="二、RPC的使用"><a href="#二、RPC的使用" class="headerlink" title="二、RPC的使用"></a>二、RPC的使用</h1><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ol>
<li><p>注册RPC服务对象，给对象绑定方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rpc.RegisterName(<span class="string">&quot;服务名&quot;</span>, 回调对象)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建监听器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">listener, err := net.Listen()</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立连接。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn, err := listener.Accept()</span><br></pre></td></tr></table></figure>
</li>
<li><p>将连接绑定RPC服务。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rpc.ServeConn(conn)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> World <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *World)</span></span> HelloWorld(args <span class="type">string</span>, reply *<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	*reply = <span class="string">&quot;Hello &quot;</span> + args</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1、注册rpc服务，绑定对象方法</span></span><br><span class="line">	err := rpc.RegisterName(<span class="string">&quot;hello&quot;</span>, <span class="built_in">new</span>(World))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;服务注册失败！&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2、设置监听</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;连接建立失败！&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listener.Close()</span><br><span class="line">	<span class="comment">// 3、建立连接</span></span><br><span class="line">	conn, err := listener.Accept()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;建立连接失败！&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4、绑定服务</span></span><br><span class="line">	rpc.ServeConn(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol>
<li><p>用RPC连接服务器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn, err := rpc.Dial()</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用远程函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">conn.Call(<span class="string">&quot;服务名.方法名&quot;</span>, 传入参数, 传出参数)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1、rpc连接服务器</span></span><br><span class="line">	client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8888&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;连接rpc服务器失败！&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> client.Close()</span><br><span class="line">	<span class="comment">// 2、调用远程函数</span></span><br><span class="line">	<span class="keyword">var</span> reply <span class="type">string</span></span><br><span class="line">	err = client.Call(<span class="string">&quot;hello.HelloWorld&quot;</span>, <span class="string">&quot;rpc&quot;</span>, &amp;reply)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;调用函数失败&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RPC相关函数"><a href="#RPC相关函数" class="headerlink" title="RPC相关函数"></a>RPC相关函数</h2><h3 id="1、注册RPC服务"><a href="#1、注册RPC服务" class="headerlink" title="1、注册RPC服务"></a>1、注册RPC服务</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> RegisterName(name <span class="type">string</span>, rcvr <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	name: 服务名</span></span><br><span class="line"><span class="comment">	rcvr: 对应rpc对象</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2、绑定RPC服务"><a href="#2、绑定RPC服务" class="headerlink" title="2、绑定RPC服务"></a>2、绑定RPC服务</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> ServeConn(conn io.ReadWriteCloser)</span><br></pre></td></tr></table></figure>

<h3 id="3、调用远程函数"><a href="#3、调用远程函数" class="headerlink" title="3、调用远程函数"></a>3、调用远程函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Call(serviceMethod <span class="type">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	serviceMethod: 服务名.方法名</span></span><br><span class="line"><span class="comment">	args: 传入参数</span></span><br><span class="line"><span class="comment">	reply: 传出参数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记</title>
    <url>/2024/09/19/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h1><ul>
<li><p><strong>常用数据类型</strong>：String（字符串）、List（列表）、Hash（哈希）、Set（无序集合）、Sorted Set（有序集合）。</p>
</li>
<li><p><strong>不常用数据类型</strong>：HyperLogLog（一种基数统计算法）、Stream（消息队列）、Geospatial（地理空间）、Bitmap（位图）、Bitfield（位域）、Bloom Filter（布隆过滤器）、Module（模块）</p>
</li>
</ul>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SET key value</td>
<td align="center">设置<code>key-value</code>缓存到<code>redis</code>中，<code>key</code>区分大小写，<code>key</code>已经存在会覆盖原来的<code>value</code></td>
<td align="center">SET name wongzeonwai</td>
</tr>
<tr>
<td align="center">GET key</td>
<td align="center">根据<code>key</code>获取<code>value</code></td>
<td align="center">GET name</td>
</tr>
<tr>
<td align="center">INCR key</td>
<td align="center">将<code>key</code>对应的<code>value</code>的值<code>+1</code>，只能对数字使用</td>
<td align="center">INCR age</td>
</tr>
<tr>
<td align="center">DECR key</td>
<td align="center">将<code>key</code>对应的<code>value</code>的值<code>-1</code>，只能对数字使用</td>
<td align="center">DECR age</td>
</tr>
<tr>
<td align="center">SETEX key seconds value</td>
<td align="center">设置<code>key-value</code>缓存到<code>redis</code>中，并设置缓存时间（秒）</td>
<td align="center">SETEX name 10 wongzeonwai</td>
</tr>
<tr>
<td align="center">TTL key</td>
<td align="center">查看<code>key</code>剩余时间（秒），<code>-1</code>代表时效永久，<code>-2</code>代表已经失效</td>
<td align="center">TTL name</td>
</tr>
<tr>
<td align="center">DEL key</td>
<td align="center">从<code>redis</code>中删除<code>key</code></td>
<td align="center">DEL name</td>
</tr>
<tr>
<td align="center">SETNX key value</td>
<td align="center">如果<code>key</code>已经存在，不做任何操作，如果不存在，执行操作</td>
<td align="center">SETNX name wongzeonwai</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a>不常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">INCRBY key increment</td>
<td align="center">给对应的<code>key</code>添加<code>increment</code>的大小</td>
<td align="center">INCRBY age 10</td>
</tr>
<tr>
<td align="center">MSET key1 value1 key2 value2…</td>
<td align="center">批量添加<code>key-value</code></td>
<td align="center">MSET name wongzeonwai age 26</td>
</tr>
<tr>
<td align="center">MGET key1 key2</td>
<td align="center">批量获取<code>key</code>对应的<code>value</code></td>
<td align="center">MGET name age</td>
</tr>
<tr>
<td align="center">APPEND key value</td>
<td align="center">在<code>key</code>对应的<code>value</code>后拼接<code>value</code></td>
<td align="center">APPEND name ok</td>
</tr>
<tr>
<td align="center">SETRANGE key offset value</td>
<td align="center">从<code>offset</code>对应的索引位置修改<code>key</code>的<code>value</code></td>
<td align="center">SETRANGE age 1 5</td>
</tr>
</tbody></table>
<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HSET key field value</td>
<td align="center">将<code>field</code>存入名为<code>key</code>的<code>hash</code>结构中</td>
<td align="center">HSET user name wongzeonwai</td>
</tr>
<tr>
<td align="center">HGET key field</td>
<td align="center">获取<code>key</code>中<code>field</code>的<code>value</code></td>
<td align="center">HGET user name</td>
</tr>
<tr>
<td align="center">HEXISTS key field</td>
<td align="center">判断<code>key</code>中是否存在<code>field</code>这个哈希键</td>
<td align="center">HEXISTS user name</td>
</tr>
<tr>
<td align="center">HDEL key field</td>
<td align="center">删除<code>key</code>中的<code>field</code>对应的键值对，所有键值对被删除后<code>key</code>也被删除</td>
<td align="center">HDEL user name</td>
</tr>
<tr>
<td align="center">HINCRBY key field increment</td>
<td align="center">给<code>key</code>中<code>field</code>对应的<code>value</code>值加上<code>increment</code>的大小</td>
<td align="center">HINCRBY user age 10</td>
</tr>
<tr>
<td align="center">HLEN key</td>
<td align="center">获取<code>key</code>中键值对的数量</td>
<td align="center">HLEN user</td>
</tr>
<tr>
<td align="center">HKEYS key</td>
<td align="center">获取<code>key</code>中所有的<code>field</code></td>
<td align="center">HKEYS user</td>
</tr>
<tr>
<td align="center">HVALS key</td>
<td align="center">获取<code>key</code>中所有的<code>value</code></td>
<td align="center">HVALS user</td>
</tr>
<tr>
<td align="center">HGETALL key</td>
<td align="center">获取<code>key</code>中所有的键值对</td>
<td align="center">HGETALL user</td>
</tr>
</tbody></table>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LPUSH（RPUSH） key value1 value2…</td>
<td align="center">从左边（右边）添加<code>value</code>，从左边添加按照<code>value</code>的先后顺序，<code>value2</code>会在<code>List</code>的开头</td>
<td align="center">LPUSH（RPUSH）hobby go mysql…</td>
</tr>
<tr>
<td align="center">LRANGE key start stop</td>
<td align="center">从左边开始获取<code>key</code>的数据，<code>start</code>为开始索引，<code>stop</code>为结束索引，负数代表从右边开始计算，<code>-1</code>为最后一个数据</td>
<td align="center">LRANGE key 2 -1</td>
</tr>
<tr>
<td align="center">LPOP（RPOP） key</td>
<td align="center">弹出左边（右边）的第一个数据</td>
<td align="center">LPOP（RPOP） hobby</td>
</tr>
<tr>
<td align="center">LLEN key</td>
<td align="center">获取列表长度</td>
<td align="center">LLEN hobby</td>
</tr>
</tbody></table>
<h2 id="非常用命令"><a href="#非常用命令" class="headerlink" title="非常用命令"></a>非常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LINSERT key before（after） pivot value</td>
<td align="center">在<code>pivot</code>的前面（后面）插入<code>value</code></td>
<td align="center">LINSERT hobby before（after） go redis</td>
</tr>
<tr>
<td align="center">LSET key index value</td>
<td align="center">更新索引为<code>index</code>的值为<code>value</code></td>
<td align="center">LSET hobby 0 html</td>
</tr>
<tr>
<td align="center">LREM key count value</td>
<td align="center">从左边开始删除<code>count</code>个为<code>value</code>的值</td>
<td align="center">LREM hobby 1 html</td>
</tr>
<tr>
<td align="center">LTRIM key start stop</td>
<td align="center">从左边开始截取从索引为<code>start</code>到索引为<code>stop</code>的列表</td>
<td align="center">LTRIM hobby 1 3</td>
</tr>
<tr>
<td align="center">LINDEX key index</td>
<td align="center">从左边开始获取索引为<code>index</code>的值</td>
<td align="center">LINDEX hobby redis</td>
</tr>
</tbody></table>
<h1 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h1><h2 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th>功能</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SADD key member1 member2…</td>
<td>往<code>key</code>集合中添加<code>members</code>元素，不能重复</td>
<td>SADD myset a b c</td>
</tr>
<tr>
<td align="center">SMEMBERS key</td>
<td>遍历<code>key</code>中所有的元素，返回的元素顺序是无序的</td>
<td>SMEMBERS myset</td>
</tr>
<tr>
<td align="center">SREM key member1 member2…</td>
<td>删除<code>key</code>中的<code>member</code>元素</td>
<td>SREM myset a b</td>
</tr>
<tr>
<td align="center">SPOP key count</td>
<td>从<code>key</code>集合随机弹出<code>count</code>个元素</td>
<td>SPOP myset 2</td>
</tr>
</tbody></table>
<h2 id="非常用命令-1"><a href="#非常用命令-1" class="headerlink" title="非常用命令"></a>非常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SDIFF key1 key2</td>
<td align="center">返回<code>key1</code>中特有的元素（差集）</td>
<td align="center">SDIFF set1 set2</td>
</tr>
<tr>
<td align="center">SIDIFFSTORE dest key1 key2</td>
<td align="center">返回<code>key1</code>中特有的元素，并存储到<code>dest</code>集合中</td>
<td align="center">SIDIFFSTORE dest set1 set2</td>
</tr>
<tr>
<td align="center">SINTER key1 key2</td>
<td align="center">返回<code>key1</code>与<code>key2</code>的交集</td>
<td align="center">SINTER set1 set2</td>
</tr>
<tr>
<td align="center">SINTERSTORE dest key1 key2</td>
<td align="center">返回<code>key1</code>与<code>key2</code>的交集，并存储到<code>dest</code>集合中</td>
<td align="center">SINTERSTORE dest set1 set2</td>
</tr>
<tr>
<td align="center">SUNION</td>
<td align="center">返回<code>key1</code>与<code>key2</code>的并集</td>
<td align="center">SUNION set1 set2</td>
</tr>
<tr>
<td align="center">SUNIONSTORE dest key1 key2</td>
<td align="center">返回<code>key1</code>与<code>key2</code>的并集，并存储到<code>dest</code>集合中</td>
<td align="center">SUNIONSTORE dest set1 set2</td>
</tr>
<tr>
<td align="center">SMOVE source dest member</td>
<td align="center">将<code>source</code>中的<code>member</code>元素移动到<code>dest</code>集合中</td>
<td align="center">SMOVE key1 key2 a</td>
</tr>
<tr>
<td align="center">SISMEMBER key member</td>
<td align="center">判断<code>member</code>元素是否存在<code>key</code>集合中</td>
<td align="center">SISMEMBER myset a</td>
</tr>
<tr>
<td align="center">SRANDMEMBER key count</td>
<td align="center">随机获取<code>key</code>集合中的<code>count</code>个元素</td>
<td align="center">SRANDMEMBER myset 2</td>
</tr>
</tbody></table>
<h1 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h1><p>每个元素都需要绑定一个<code>double</code>类型的分数。</p>
<h2 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ZADD key score1 member1 score2 member2…</td>
<td align="center">往<code>key</code>集合中添加<code>member</code>元素，分数为<code>score</code></td>
<td align="center">ZADD results 100 a 200 b</td>
</tr>
<tr>
<td align="center">ZINCRBY key increment member</td>
<td align="center">将<code>member</code>元素的分数<code>+</code>increment</td>
<td align="center">ZADD results 100 a</td>
</tr>
<tr>
<td align="center">ZRANGE key start stop [WITHSCORES]</td>
<td align="center">将元素按分数升序排列【显示分数】</td>
<td align="center">ZRANGE results 0 -1 WITHSCORES</td>
</tr>
<tr>
<td align="center">ZREVRANGE key start stop [WITHSCORES]</td>
<td align="center">将元素按分数降序排列【显示分数】</td>
<td align="center">ZREVRANGE results 0 -1 WITHSCORES</td>
</tr>
<tr>
<td align="center">ZRANK key member</td>
<td align="center">返回<code>member</code>元素在<code>key</code>集合中的正序排名</td>
<td align="center">ZRANK results a</td>
</tr>
<tr>
<td align="center">ZREVRANK key member</td>
<td align="center">返回<code>member</code>元素在<code>key</code>集合中的降序排名</td>
<td align="center">ZREVRANK results a</td>
</tr>
<tr>
<td align="center">ZCARD key</td>
<td align="center">返回元素的个数</td>
<td align="center">ZCARD results</td>
</tr>
<tr>
<td align="center">ZSCORE key member</td>
<td align="center">获取<code>member</code>元素的分数</td>
<td align="center">ZSCORE results a</td>
</tr>
</tbody></table>
<h2 id="非常用命令-2"><a href="#非常用命令-2" class="headerlink" title="非常用命令"></a>非常用命令</h2><table>
<thead>
<tr>
<th align="center">命令格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ZRANGEBYSCORE key min max [WITHSCORES]</td>
<td align="center">按<code>[min,max]</code>分数范围返回<code>key</code>集合中的元素（正序）</td>
<td align="center">ZRANGEBYSCORE results 100 200 WITHSCORES</td>
</tr>
<tr>
<td align="center">ZREVRANGEBYSCORE key max min [WITHSCORES]</td>
<td align="center">按<code>[min,max]</code>分数范围返回<code>key</code>集合中的元素（降序）</td>
<td align="center">ZREVRANGEBYSCORE results 200 100 WITHSCORES</td>
</tr>
<tr>
<td align="center">ZREM key member</td>
<td align="center">删除<code>member</code>元素</td>
<td align="center">ZREM results a</td>
</tr>
<tr>
<td align="center">ZREMRANGEBYSCORE key min max [WITHSCORES]</td>
<td align="center">按<code>[min,max]</code>分数范围删除<code>key</code>集合中的元素（正序）</td>
<td align="center">ZREMRANGEBYSCORE results 100 200 WITHSCORES</td>
</tr>
<tr>
<td align="center">ZREMRANGEBYRANK key start stop</td>
<td align="center">删除<code>key</code>集合正序排名在<code>[start,stop)</code>中的元素</td>
<td align="center">ZREMRANGEBYRANK results 0 2</td>
</tr>
<tr>
<td align="center">ZCOUNT key min max</td>
<td align="center">返回<code>key</code>集合中分数在<code>[min,max]</code>中的元素个数</td>
<td align="center">ZCOUNT results 100 200</td>
</tr>
</tbody></table>
<h1 id="Redis全局命令"><a href="#Redis全局命令" class="headerlink" title="Redis全局命令"></a>Redis全局命令</h1><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">keys pattern</td>
<td align="center">根据<code>pattern</code>条件查询<code>keys</code></td>
</tr>
<tr>
<td align="center">EXISTS key</td>
<td align="center">判断<code>key</code>是否存在</td>
</tr>
<tr>
<td align="center">EXPIRE key seconds</td>
<td align="center">给<code>key</code>设置过期时间（秒）</td>
</tr>
<tr>
<td align="center">PERSIST key</td>
<td align="center">取消<code>key</code>过期时间</td>
</tr>
<tr>
<td align="center">SELECT index</td>
<td align="center">切换数据库（0-15）</td>
</tr>
<tr>
<td align="center">MOVE key index</td>
<td align="center">从当前数据库将<code>key</code>移动到指定<code>index</code>库</td>
</tr>
<tr>
<td align="center">RANDOMKEY</td>
<td align="center">随机返回一个<code>key</code></td>
</tr>
<tr>
<td align="center">RENAME key newkey</td>
<td align="center">将<code>key</code>重命名为<code>newkey</code></td>
</tr>
<tr>
<td align="center">ECHO message</td>
<td align="center">打印<code>message</code>信息</td>
</tr>
<tr>
<td align="center">DBSIZE</td>
<td align="center">返回当前库中<code>key</code>的个数</td>
</tr>
<tr>
<td align="center">INFO</td>
<td align="center">查看数据库信息</td>
</tr>
<tr>
<td align="center">CONFIG GET pattern</td>
<td align="center">根据<code>pattern</code>匹配条件查看数据库配置信息</td>
</tr>
<tr>
<td align="center">FLUSHDB</td>
<td align="center">清空当前数据库</td>
</tr>
<tr>
<td align="center">FLUSHALL</td>
<td align="center">清空所有数据库</td>
</tr>
</tbody></table>
<h1 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h1><ol>
<li><code>Linux</code>系统<ol>
<li>找到<code>redis.config</code>文件，在<code>requirepass</code>后面添加密码</li>
<li>重启<code>redis</code>服务，使用带密码的命令<code>redis-cli -a ******</code></li>
</ol>
</li>
<li><code>Windows</code>系统<ol>
<li>步骤与<code>Linux</code>系统相同，但是在<code>redis.windows-service.config</code></li>
</ol>
</li>
</ol>
<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>使用<code>MULTI</code>开启事务，使用<code>EXEC</code>执行事务，但是事务的执行并非<code>原子性的</code>，就算中间的命令出错，也不会影响到上下文的执行。</p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p><code>Redis</code>会将内存中的数据保存到硬盘中，实现数据的持久化。</p>
<h2 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h2><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><ol>
<li>使用<code>save</code>命令，会阻塞当前<code>Redis</code>进程直到持久化完成。</li>
<li>使用<code>bgsave</code>，创建一个子进程，由子进程实现持久化。</li>
</ol>
<h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><p>使用<code>save</code>相关配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save m n</span><br><span class="line">#m秒内有n个key被修改时，则发起持久化保持数据。</span><br></pre></td></tr></table></figure>

<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><code>RDB</code>文件是一个可以压缩的二进制文件，适合用于数据备份，全量复制等场景，可以按照每<code>6</code>小时执行一次备份，用于容灾备份。</li>
<li>恢复速度快于<code>ADF</code>方式。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>无法实时、秒级持久化。</li>
<li>不同版本快照文件不一样，容易引起兼容问题。</li>
</ul>
<h2 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h2><p>通过独立日志记录每次执行操作的命令，重启服务器的时候执行文件恢复数据，需要在配置文件中配置<code>appendonly yes</code>。</p>
<p><code>AOF</code>有三种同步策略：</p>
<table>
<thead>
<tr>
<th align="center">策略</th>
<th align="center">功能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">appendfsync always</td>
<td align="center">执行命令时立即写入到磁盘，效率最慢，但是能保证数据完全持久化</td>
<td></td>
</tr>
<tr>
<td align="center">appendfsync everysec</td>
<td align="center">每秒写入一次</td>
<td></td>
</tr>
<tr>
<td align="center">appendfsync no</td>
<td align="center">完全依赖<code>os</code>，一般周期为30秒</td>
<td></td>
</tr>
</tbody></table>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>安全性高，最多损失一秒的数据量。</li>
<li>执行<code>flushall</code>命令后，可以通过<code>AOF</code>方式恢复（删除<code>flushall</code>命令即可）。</li>
<li><code>AOF</code>文件是一个增量日志文件，难以损坏。</li>
<li><code>AOF</code>文件太大时，<code>Redis</code>会在后台自动重写文件。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>文件体积大。</li>
<li>性能较慢。</li>
</ul>
<h2 id="RDB-AOF混合使用"><a href="#RDB-AOF混合使用" class="headerlink" title="RDB-AOF混合使用"></a>RDB-AOF混合使用</h2><p>在<code>Redis 4.0</code>提出的新的解决方法。在写入的时候，先把当前数据写入到<code>RDB</code>文件中，再将后续命令写入到<code>AOF</code>文件中，实现全量备份和增量备份，提升备份效率。</p>
<p>如果不是混合模式，而是两种模式同时启动，<code>Redis</code>加载数据的流程：</p>
<p><img src="/2024/09/19/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis.png" alt="redis"></p>
<h1 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制"></a>Redis内存淘汰机制</h1><ol>
<li><strong>LRU（least recently used）</strong>：最近少使用的数据，仅和时间相关关。</li>
<li><strong>LFU（least frequently used）</strong>：最不经常使用的数据，和时间、频率相关。</li>
<li><strong>TTL</strong>：最接近过期时间的数据。</li>
<li><strong>随机淘汰</strong>。</li>
</ol>
<p><code>Redis</code>通过配置：<code>maxmemory-policy</code>来配置具体的淘汰机制：</p>
<ul>
<li><code>volatile-lru</code>：查询已设置过期时间的数据集，将最近最少使用的数据淘汰。</li>
<li><code>volatile-ttl</code>：查询已设置过期时间的数据集，将即将过期的数据淘汰。</li>
<li><code>volatile-random</code>：已设置过期时间的数据集，随机淘汰数据。</li>
<li><code>volatile-lfu</code>：已设置过期时间的数据集，将一段时间内，使用次数最少的数据淘汰。</li>
<li><code>allkeys-lru</code>：查询所有数据，将最近最少使用的数据淘汰。</li>
<li><code>allkeys-lfu</code>：查询所有数据，将一段时间内，使用次数最少的数据淘汰。</li>
<li><code>allkeys-random</code>：查询所有数据，随机淘汰数据。</li>
<li><code>noeviction</code>：默认配置，内存不足时报错，保证数据不丢失。</li>
</ul>
<h1 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期<code>key</code>处理</h1><ul>
<li><strong>惰性删除</strong>：当访问<code>key</code>时，才去判断是否过期，如果过期直接删除，长期不访问会占内存。</li>
<li><strong>定时删除</strong>：设置键的过期时间的同时，创建一个定时器，当到达过期时间点时立刻删除，对CPU不友好。</li>
<li><strong>定期删除</strong>：隔一段时间对数据检查，删除过期的<code>key</code>。</li>
</ul>
<p><code>Redis</code>服务器采用惰性和定期两种策略，<code>CPU</code>和内存浪费中取得平衡。</p>
<h1 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h1><p>单节点<code>Redis</code>的<strong>并发能力</strong>是有上限的，要进一步提高<code>Redis</code>的并发能力，就需要搭建主从集群，实现读写分离，由<code>主Redis</code>执行<strong>写</strong>操作，<code>从Redis</code>执行<strong>读</strong>操作。</p>
<p>在从节点<code>redis.conf</code>文件中新增配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>

<p>原理：通过<code>RDB-AOF</code>混合方式将数据文件发送给从节点。</p>
<p>每个主节点都有一个<code>Replication id</code>，简称<code>replid</code>标记，从节点会继承主节点的<code>replid</code>，通过判断知道是否第一次复制数据。</p>
<h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><p><code>Redis</code>提供了哨兵（Sentinel）来实现主从集群的自动故障恢复，哨兵的结构和作用如下：</p>
<ul>
<li><strong>监控</strong>：<code>Sentinel</code>会不断检测主从集群是否按预期工作。</li>
<li><strong>自动故障恢复</strong>：如果主节点故障，<code>Sentinel</code>会将一个从节点提升为主节点。</li>
</ul>
<p><code>Sentinel</code>基于心跳机制监测服务状态，每隔一秒向集群的每个实例发送ping命令：</p>
<ul>
<li><strong>主观下线</strong>：如果某<code>Sentinel</code>节点发现某实例未在规定时间内响应，则会认为该实例<strong>主观下线</strong>。</li>
<li><strong>客观下线</strong>：若超过指定数量（最好超过<code>Sentinel</code>数量的一半）的<code>Sentinel</code>都认为该实例<strong>主观下线</strong>，则该实例<strong>客观下线</strong>。</li>
</ul>
<h1 id="Go-redis"><a href="#Go-redis" class="headerlink" title="Go-redis"></a>Go-redis</h1><p><code>Redis</code>推出了<code>Go</code>语言使用<code>Redis</code>数据库的官方库<code>go-redis</code>，文档地址：[Go Redis <a href="https://redis.uptrace.dev/zh/guide/go-redis.html">快速入门] (uptrace.dev)</a>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化模块</span></span><br><span class="line">go mod init my_go_redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装go-redis库</span></span><br><span class="line">go get github.com/redis/go-redis/v9</span><br></pre></td></tr></table></figure>

<p>在<code>Go</code>中使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/redis/go-redis/v9&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 连接redis数据库</span></span><br><span class="line">	client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr: <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">		Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">		DB: <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">	&#125;)</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  另一种连接方式</span></span><br><span class="line"><span class="comment">  opt, err := redis.ParseURL(&quot;redis://&lt;user&gt;:&lt;pass&gt;@localhost:6379/&lt;db&gt;&quot;)</span></span><br><span class="line"><span class="comment">  if err != nil &#123;</span></span><br><span class="line"><span class="comment">    panic(err)</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	client := redis.NewClient(opt)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">  </span><br><span class="line">  ctx := context.Background()</span><br><span class="line">	<span class="comment">// 使用String数据类型创建一个key-value：foo-bar</span></span><br><span class="line">	err := client.Set(ctx, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="number">0</span>).Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取key为foo的value值</span></span><br><span class="line">	val, err := client.Get(ctx, <span class="string">&quot;foo&quot;</span>).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;foo&quot;</span>, val)</span><br><span class="line">  <span class="comment">// 创建一个Hash类型的数据</span></span><br><span class="line">  session := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>, <span class="string">&quot;surname&quot;</span>: <span class="string">&quot;Smith&quot;</span>, <span class="string">&quot;company&quot;</span>: <span class="string">&quot;Redis&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="string">&quot;29&quot;</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> session &#123;</span><br><span class="line">      err := client.HSet(ctx, <span class="string">&quot;user-session:123&quot;</span>, k, v).Err()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="built_in">panic</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  userSession := client.HGetAll(ctx, <span class="string">&quot;user-session:123&quot;</span>).Val()</span><br><span class="line">  fmt.Println(userSession)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>缓存穿透</strong>是指客户端请求的数据在缓存和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>解决方案：</p>
<ul>
<li><p>缓存空对象</p>
<p>优点：实现简单，维护方便。</p>
<p>缺点：额外的消耗。可能造成短期的不一致。</p>
</li>
<li><p>布隆过滤</p>
<p>优点：内存占用少，没有多余 key。</p>
<p>缺点：实现复杂。存在误判可能。</p>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>缓存雪崩</strong>是指在同一时段大量的缓存 key 同时失效或者 Redis 服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ul>
<li>给不同的 key 添加随机的 TTL。</li>
<li>利用 Redis 集群提高服务可用性。</li>
<li>给缓存业务添加降级限流策略。</li>
<li>给业务添加多级缓存。</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>缓存击穿</strong>是指一个被高并发访问并且缓存重建业务较复杂的 key 突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>解决方案：</p>
<ul>
<li><p>添加互斥锁。</p>
<p>优点：没有额外内存消耗。保证一致性。实现简单。</p>
<p>缺点：线程需要等待，性能受影响。可能有死锁风险。</p>
<p><img src="/2024/09/19/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/huchisuo.png" alt="互斥锁"></p>
</li>
<li><p>逻辑过期：不设置 TTL，将过期时间放在 value 中。</p>
<p>优点：线程无需等待，性能较好。</p>
<p>缺点：不保证一致性。有额外内存消耗。实现复杂。</p>
<p><img src="/2024/09/19/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/luoji.png" alt="逻辑过期"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>gPRC学习笔记</title>
    <url>/2024/09/25/gPRC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、Protobuf使用"><a href="#一、Protobuf使用" class="headerlink" title="一、Protobuf使用"></a>一、Protobuf使用</h1><h2 id="1、定义-proto文件"><a href="#1、定义-proto文件" class="headerlink" title="1、定义.proto文件"></a>1、定义<code>.proto</code>文件</h2><p>在项目中创建**.proto**后缀的文件</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定proto版本</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// 指定默认包名</span></span><br><span class="line"><span class="keyword">package</span> user;</span><br><span class="line"><span class="comment">// 指定go包名</span></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./proto&quot;</span>;</span><br><span class="line"><span class="comment">// 定义rpc服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetUser (GetUserRequest) <span class="keyword">returns</span> (GetUserResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义服务端流式传输rpc服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetUser (GetUserRequest) <span class="keyword">returns</span> (stream GetUserResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义客户端流式传输rpc服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetUser (stream GetUserRequest) <span class="keyword">returns</span> (GetUserResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义双向流式传输rpc服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetUser (stream GetUserRequest) <span class="keyword">returns</span> (stream GetUserResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请求结构体</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetUserRequest</span> &#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 响应结构体</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetUserResponse</span> &#123;</span><br><span class="line">    User user = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// user结构体</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、安装-Protobuf-编译器和插件"><a href="#2、安装-Protobuf-编译器和插件" class="headerlink" title="2、安装 Protobuf 编译器和插件"></a>2、安装 Protobuf 编译器和插件</h2><p>从<a href="https://github.com/protocolbuffers/protobuf/releases">Releases · protocolbuffers&#x2F;protobuf (github.com)</a>中获取<strong>protoc</strong>编译器，然后安装<code>protoc-gen-go</code> 和 <code>protoc-gen-go-grpc</code> 插件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br><span class="line">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest</span><br></pre></td></tr></table></figure>

<h2 id="3、编译-proto文件"><a href="#3、编译-proto文件" class="headerlink" title="3、编译.proto文件"></a>3、编译<code>.proto</code>文件</h2><p><strong>powershell</strong>运行以下命令将**.proto<strong>文件转换成</strong>go**文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">protoc --go_out=. --go-grpc_out=. proto/user.proto</span><br></pre></td></tr></table></figure>

<p>运行后会生成<code>user.pb.go</code> 和 <code>user_grpc.pb.go</code> 两个文件。</p>
<h1 id="二、实现客户端、服务端"><a href="#二、实现客户端、服务端" class="headerlink" title="二、实现客户端、服务端"></a>二、实现客户端、服务端</h1><h2 id="1、服务端实现"><a href="#1、服务端实现" class="headerlink" title="1、服务端实现"></a>1、服务端实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">  pb <span class="string">&quot;go_grpc/proto&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">  pb.UnimplementedUserServiceServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, <span class="type">error</span>) &#123;</span><br><span class="line">  user := &amp;pb.User&#123;</span><br><span class="line">      Id:    req.Id,</span><br><span class="line">      Name:  <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">      Email: <span class="string">&quot;johndoe@example.com&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pb.GetUserResponse&#123;User: user&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:50051&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  grpcServer := grpc.NewServer()</span><br><span class="line">  pb.RegisterUserServiceServer(grpcServer, &amp;server&#123;&#125;)</span><br><span class="line">  log.Println(<span class="string">&quot;Server is running on port 50051&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err := grpcServer.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、客户端实现"><a href="#2、客户端实现" class="headerlink" title="2、客户端实现"></a>2、客户端实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">&quot;go_grpc/proto&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;localhost:50051&quot;</span>, grpc.WithInsecure(), grpc.WithBlock())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	client := pb.NewUserServiceClient(conn)</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	req := &amp;pb.GetUserRequest&#123;Id: <span class="number">1</span>&#125;</span><br><span class="line">	res, err := client.GetUser(ctx, req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;could not get user: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;User: %v&quot;</span>, res.User)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3、启动服务"><a href="#3、启动服务" class="headerlink" title="3、启动服务"></a>3、启动服务</h2><p>同时通过<code>go run</code>启动服务端和客户端。</p>
<p>服务端启动成功：<code>2024/09/26 15:36:17 Server is running on port 50051</code></p>
<p>客户端启动成功：<code>2024/09/26 15:36:28 User: id:1 name:&quot;John Doe&quot; email:&quot;johndoe@example.com&quot;</code></p>
<h1 id="三、proto数据类型"><a href="#三、proto数据类型" class="headerlink" title="三、proto数据类型"></a>三、proto数据类型</h1><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;type/proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="type">double</span> a1 = <span class="number">1</span>;</span><br><span class="line">  <span class="type">float</span> a2 = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> a3 = <span class="number">3</span>;</span><br><span class="line">  <span class="type">uint32</span> a4 = <span class="number">4</span>;</span><br><span class="line">  <span class="type">uint64</span> a5 = <span class="number">5</span>;</span><br><span class="line">  <span class="type">sint32</span> a6 = <span class="number">6</span>;</span><br><span class="line">  <span class="type">sint64</span> a7 = <span class="number">7</span>;</span><br><span class="line">  <span class="type">fixed32</span> a8 = <span class="number">8</span>;</span><br><span class="line">  <span class="type">fixed64</span> a9 = <span class="number">9</span>;</span><br><span class="line">  <span class="type">sfixed32</span> a10 = <span class="number">10</span>;</span><br><span class="line">  <span class="type">sfixed64</span> a11 = <span class="number">11</span>;</span><br><span class="line">  <span class="type">bool</span> a12 = <span class="number">12</span>;</span><br><span class="line">  <span class="type">string</span> a13 = <span class="number">13</span>;</span><br><span class="line">  <span class="type">bytes</span> a14 = <span class="number">14</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Item</span> &#123;</span><br><span class="line">  <span class="type">string</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">List</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">int32</span> list = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">repeated</span> Item item_list = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Map</span> &#123;</span><br><span class="line">  map&lt;<span class="type">int32</span>, <span class="type">string</span>&gt; k_v1 = <span class="number">1</span>;</span><br><span class="line">  map&lt;<span class="type">int32</span>, Item&gt; k_v2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应Go数据类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型</span></span><br><span class="line"><span class="keyword">type</span> Type <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	A1  <span class="type">float64</span> <span class="string">`protobuf:&quot;fixed64,1,opt,name=a1,proto3&quot; json:&quot;a1,omitempty&quot;`</span></span><br><span class="line">	A2  <span class="type">float32</span> <span class="string">`protobuf:&quot;fixed32,2,opt,name=a2,proto3&quot; json:&quot;a2,omitempty&quot;`</span></span><br><span class="line">	A3  <span class="type">int32</span>   <span class="string">`protobuf:&quot;varint,3,opt,name=a3,proto3&quot; json:&quot;a3,omitempty&quot;`</span></span><br><span class="line">	A4  <span class="type">uint32</span>  <span class="string">`protobuf:&quot;varint,4,opt,name=a4,proto3&quot; json:&quot;a4,omitempty&quot;`</span></span><br><span class="line">	A5  <span class="type">uint64</span>  <span class="string">`protobuf:&quot;varint,5,opt,name=a5,proto3&quot; json:&quot;a5,omitempty&quot;`</span></span><br><span class="line">	A6  <span class="type">int32</span>   <span class="string">`protobuf:&quot;zigzag32,6,opt,name=a6,proto3&quot; json:&quot;a6,omitempty&quot;`</span></span><br><span class="line">	A7  <span class="type">int64</span>   <span class="string">`protobuf:&quot;zigzag64,7,opt,name=a7,proto3&quot; json:&quot;a7,omitempty&quot;`</span></span><br><span class="line">	A8  <span class="type">uint32</span>  <span class="string">`protobuf:&quot;fixed32,8,opt,name=a8,proto3&quot; json:&quot;a8,omitempty&quot;`</span></span><br><span class="line">	A9  <span class="type">uint64</span>  <span class="string">`protobuf:&quot;fixed64,9,opt,name=a9,proto3&quot; json:&quot;a9,omitempty&quot;`</span></span><br><span class="line">	A10 <span class="type">int32</span>   <span class="string">`protobuf:&quot;fixed32,10,opt,name=a10,proto3&quot; json:&quot;a10,omitempty&quot;`</span></span><br><span class="line">	A11 <span class="type">int64</span>   <span class="string">`protobuf:&quot;fixed64,11,opt,name=a11,proto3&quot; json:&quot;a11,omitempty&quot;`</span></span><br><span class="line">	A12 <span class="type">bool</span>    <span class="string">`protobuf:&quot;varint,12,opt,name=a12,proto3&quot; json:&quot;a12,omitempty&quot;`</span></span><br><span class="line">	A13 <span class="type">string</span>  <span class="string">`protobuf:&quot;bytes,13,opt,name=a13,proto3&quot; json:&quot;a13,omitempty&quot;`</span></span><br><span class="line">	A14 []<span class="type">byte</span>  <span class="string">`protobuf:&quot;bytes,14,opt,name=a14,proto3&quot; json:&quot;a14,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	A <span class="type">string</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=a,proto3&quot; json:&quot;a,omitempty&quot;`</span></span><br><span class="line">	B <span class="type">int32</span>  <span class="string">`protobuf:&quot;varint,2,opt,name=b,proto3&quot; json:&quot;b,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 切片</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	List     []<span class="type">int32</span> <span class="string">`protobuf:&quot;varint,1,rep,packed,name=list,proto3&quot; json:&quot;list,omitempty&quot;`</span></span><br><span class="line">	ItemList []*Item <span class="string">`protobuf:&quot;bytes,2,rep,name=item_list,json=itemList,proto3&quot; json:&quot;item_list,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	KV1 <span class="keyword">map</span>[<span class="type">int32</span>]<span class="type">string</span> <span class="string">`protobuf:&quot;bytes,1,rep,name=k_v1,json=kV1,proto3&quot; json:&quot;k_v1,omitempty&quot; protobuf_key:&quot;varint,1,opt,name=key,proto3&quot; protobuf_val:&quot;bytes,2,opt,name=value,proto3&quot;`</span></span><br><span class="line">	KV2 <span class="keyword">map</span>[<span class="type">int32</span>]*Item  <span class="string">`protobuf:&quot;bytes,2,rep,name=k_v2,json=kV2,proto3&quot; json:&quot;k_v2,omitempty&quot; protobuf_key:&quot;varint,1,opt,name=key,proto3&quot; protobuf_val:&quot;bytes,2,opt,name=value,proto3&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣 hot100 解题思路</title>
    <url>/2025/08/02/%E5%8A%9B%E6%89%A3-hot100-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="1、两数之和"><a href="#1、两数之和" class="headerlink" title="1、两数之和"></a>1、两数之和</h2><p>哈希表存储键值对为 { num: index }，如果目标值 - 当前数已存在，返回两个数的 index。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">  numMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">    <span class="keyword">if</span> num1, ok := numMap[target - v]; ok &#123;</span><br><span class="line">      <span class="keyword">return</span> []<span class="type">int</span>&#123;num1, k&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    numMap[v] = k</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="49、字母异分位"><a href="#49、字母异分位" class="headerlink" title="49、字母异分位"></a>49、字母异分位</h2><p>哈希表存储一个键为长度 26 的数组，值为字符串数组，遍历每个字符串中的每个字符，判断出现的字母并存放到键中，键相同的在值后插入，最后遍历哈希表返回一个二维数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">groupAnagrams</span><span class="params">(strs []<span class="type">string</span>)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">  mp := <span class="keyword">map</span>[[<span class="number">26</span>]<span class="type">int</span>][]<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        <span class="keyword">var</span> n [<span class="number">26</span>]<span class="type">int</span></span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> str &#123;</span><br><span class="line">            n[v - <span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">        &#125;</span><br><span class="line">        mp[n] = <span class="built_in">append</span>(mp[n], str)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ans [][]<span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> mp &#123;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, v)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="128、最长连续序列"><a href="#128、最长连续序列" class="headerlink" title="128、最长连续序列"></a>128、最长连续序列</h2><p>哈希表存储数组的每一个值作为键，<strong>true</strong> 作为值。设置最长序列初始值为 0。遍历哈希表，判断是否有比当前数小 1 的值，如果不存在，设置当前最小 边界和长度为 1，开始获取递增序列长度。最后返回最大的序列长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestConsecutive</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    numSet := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        numSet[num] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    longestStreak := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num := <span class="keyword">range</span> numSet &#123;</span><br><span class="line">        <span class="keyword">if</span> !numSet[num<span class="number">-1</span>] &#123;</span><br><span class="line">            currentNum := num</span><br><span class="line">            currentStreak := <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> numSet[currentNum+<span class="number">1</span>] &#123;</span><br><span class="line">                currentNum++</span><br><span class="line">                currentStreak++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> longestStreak &lt; currentStreak &#123;</span><br><span class="line">                longestStreak = currentStreak</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longestStreak</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="283、移动零"><a href="#283、移动零" class="headerlink" title="283、移动零"></a>283、移动零</h2><p>设置左右指针初始位置在数组开头，如果右指针不为 0，左右两个数交换位置，指针位置 +1。如果右指针为 0，右指针位置 +1，直到右指针到最后一位。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    left, right, n := <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> right &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[right] != <span class="number">0</span> &#123;</span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        right++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11、盛最多水的容器"><a href="#11、盛最多水的容器" class="headerlink" title="11、盛最多水的容器"></a>11、盛最多水的容器</h2><p>双指针指向数组开始和末尾，短边移动。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="type">int</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        area := (right - left) * min(height[left], height[right])</span><br><span class="line">        ans = max(ans, area)</span><br><span class="line">        <span class="keyword">if</span> height[left] &lt; height[right] &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15、三数之和"><a href="#15、三数之和" class="headerlink" title="15、三数之和"></a>15、三数之和</h2><ol>
<li>先排序，如果第一个数大于 0，那么必定不存在解。</li>
<li>判断是否和上一次枚举的数是否相同，去除重复解。</li>
<li>设置两个指针为第一个数的下一个数和数组末尾的数，两个数相加是第一个数的相反数。</li>
<li>判断第二个数和上一次枚举的数是否相同，去除重复解。</li>
<li>保证左指针小于右指针，右指针向左移动，判断两个数的和，符合题解的数组加入解数组中。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 枚举 a</span></span><br><span class="line">    <span class="keyword">for</span> first := <span class="number">0</span>; first &lt; n; first++ &#123;</span><br><span class="line">        <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">        <span class="keyword">if</span> first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// c 对应的指针初始指向数组的最右端</span></span><br><span class="line">        third := n - <span class="number">1</span></span><br><span class="line">        target := <span class="number">-1</span> * nums[first]</span><br><span class="line">        <span class="comment">// 枚举 b</span></span><br><span class="line">        <span class="keyword">for</span> second := first + <span class="number">1</span>; second &lt; n; second++ &#123;</span><br><span class="line">            <span class="comment">// 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 需要保证 b 的指针在 c 的指针的左侧</span></span><br><span class="line">            <span class="keyword">for</span> second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target &#123;</span><br><span class="line">                third--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果指针重合，随着 b 后续的增加</span></span><br><span class="line">            <span class="comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span></span><br><span class="line">            <span class="keyword">if</span> second == third &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nums[second] + nums[third] == target &#123;</span><br><span class="line">                ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;nums[first], nums[second], nums[third]&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42、接雨水"><a href="#42、接雨水" class="headerlink" title="42、接雨水"></a>42、接雨水</h2><p>指针指向数组开始和结尾，两个指针开始汇合。每次遍历，取左边最高位和左指针的最大值，取右边最高位和右指针的最大值。对于每一个柱子接的水，它能接的水 &#x3D; min(左右两边最高柱子) - 当前柱子高度。比较左指针和右指针，如果左指针比右指针小，可以计算左指针能装的水，由于 leftMax 从左到右是递增的，那么最小边界就是 leftMax ，能装的水就是 leftMax - height[left]。反之可以计算右指针能装的水。</p>
<p><img src="/2025/08/02/%E5%8A%9B%E6%89%A3-hot100-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/42.png" alt="接雨水"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">    leftMax, rightMax := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">        leftMax = max(leftMax, height[left])</span><br><span class="line">        rightMax = max(rightMax, height[right])</span><br><span class="line">        <span class="keyword">if</span> height[left] &lt; height[right] &#123;</span><br><span class="line">            ans += leftMax - height[left]</span><br><span class="line">            left++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += rightMax - height[right]</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="2、无重复字符的最长字符串"><a href="#2、无重复字符的最长字符串" class="headerlink" title="2、无重复字符的最长字符串"></a>2、无重复字符的最长字符串</h2><p>每次记录当前字符位置是为了更改左边界。出现了重复字符需要更改边界到字符位置计算无重复字符长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 使用数组模拟哈希表，记录每个字符最后一次出现的位置+1</span></span><br><span class="line">    index := [<span class="number">128</span>]<span class="type">int</span>&#123;&#125; <span class="comment">// ASCII字符集</span></span><br><span class="line">    maxLen := <span class="number">0</span></span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> right, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="comment">// 更新左边界：如果字符已存在，则跳到上次出现位置的下一位</span></span><br><span class="line">        <span class="keyword">if</span> index[ch] &gt; left &#123;</span><br><span class="line">            left = index[ch]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算当前窗口长度并更新最大值</span></span><br><span class="line">        <span class="keyword">if</span> right - left + <span class="number">1</span> &gt; maxLen &#123;</span><br><span class="line">            maxLen = right - left + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录当前字符的位置（+1是为了方便计算）</span></span><br><span class="line">        index[ch] = right + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="438、找到字符串中所有字母异位词"><a href="#438、找到字符串中所有字母异位词" class="headerlink" title="438、找到字符串中所有字母异位词"></a>438、找到字符串中所有字母异位词</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findAnagrams</span><span class="params">(s <span class="type">string</span>, p <span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    ans := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    cntP := [<span class="number">26</span>]<span class="type">int</span>&#123;&#125; <span class="comment">// 统计 p 的每种字母的出现次数</span></span><br><span class="line">    cntS := [<span class="number">26</span>]<span class="type">int</span>&#123;&#125; <span class="comment">// 统计 s 的长为 len(p) 的子串 s&#x27; 的每种字母的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> p &#123;</span><br><span class="line">        cntP[c-<span class="string">&#x27;a&#x27;</span>]++ <span class="comment">// 统计 p 的字母</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> right, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        cntS[c-<span class="string">&#x27;a&#x27;</span>]++ <span class="comment">// 右端点字母进入窗口</span></span><br><span class="line">        left := right - <span class="built_in">len</span>(p) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; <span class="number">0</span> &#123; <span class="comment">// 窗口长度不足 len(p)</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cntS == cntP &#123; <span class="comment">// s&#x27; 和 p 的每种字母的出现次数都相同</span></span><br><span class="line">            ans = <span class="built_in">append</span>(ans, left) <span class="comment">// s&#x27; 左端点下标加入答案</span></span><br><span class="line">        &#125;</span><br><span class="line">        cntS[s[left]-<span class="string">&#x27;a&#x27;</span>]-- <span class="comment">// 左端点字母离开窗口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h1><h1 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h1><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h1 id="多维动态规划"><a href="#多维动态规划" class="headerlink" title="多维动态规划"></a>多维动态规划</h1><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1>]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解GMP模型</title>
    <url>/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一、单进程到多进程的改变"><a href="#一、单进程到多进程的改变" class="headerlink" title="一、单进程到多进程的改变"></a>一、单进程到多进程的改变</h1><h2 id="1、单进程"><a href="#1、单进程" class="headerlink" title="1、单进程"></a>1、单进程</h2><p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/danjincheng.png" alt="danjincheng"></p>
<p>同一时刻只能执行单个进程，进程阻塞浪费了 CPU 资源。</p>
<h2 id="2、多进程"><a href="#2、多进程" class="headerlink" title="2、多进程"></a>2、多进程</h2><p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/duojincheng.png" alt="duojincheng"></p>
<p>使用时间片轮询方式切换进程，进程切换时也会浪费 CPU 资源。进程占用空间约为虚拟内存的 <em>4GB</em>，线程占用空间约为 <em>4MB</em>。 </p>
<h1 id="二、协程（co-routine）"><a href="#二、协程（co-routine）" class="headerlink" title="二、协程（co-routine）"></a>二、协程（co-routine）</h1><p>线程分为由 CPU 调度的内核态线程，由用户进程自行调度的用户态线程，以及 CPU 和用户都能调度的混合态线程。协程就是在用户态线程基础上实现的轻量级线程。</p>
<h1 id="三、GM模型"><a href="#三、GM模型" class="headerlink" title="三、GM模型"></a>三、GM模型</h1><p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/gmmodel.png" alt="gmmodel"></p>
<p>早期调度器由<strong>线程</strong>和<strong>协程全局队列</strong>组成。<span style="color: blue">M</span> 想要执行、放回 <span style="color: green">G</span> 都必须访问全局 <span style="color: green">G</span> 队列，并且 <span style="color: blue">M</span> 有多个，即多线程访问同一资源需要加锁进行保证互斥&#x2F;同步，所以全局 <span style="color: green">G</span> 队列是有互斥锁进行保护的。</p>
<ol>
<li>创建、销毁、调度G都需要每个M获取锁，这就形成了<strong>激烈的锁竞争</strong>。</li>
<li><span style="color: blue">M</span> 转移 <span style="color: green">G</span> 会造成<strong>延迟和额外的系统负载</strong>。比如当 <span style="color: green">G</span> 中包含创建新协程的时候，M 创建了 <span style="color: green">G’</span>，为了继续执行G，需要把 <span style="color: green">G’</span> 交给 M’ 执行，也造成了<strong>很差的局部性</strong>，因为 <span style="color: green">G’</span> 和 <span style="color: green">G</span> 是相关的，最好放在 <span style="color: blue">M</span> 上执行，而不是其他 <span style="color: blue">M</span>‘ 。</li>
<li>系统调用（CPU 在 <span style="color: blue">M</span> 之间的切换）导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ol>
<h1 id="四、GMP模型"><a href="#四、GMP模型" class="headerlink" title="四、GMP模型"></a>四、GMP模型</h1><p>GMP 是 Go 语言实现的对<strong>线程（M：machine）</strong>、<strong>goroutine（G）</strong>的<strong>调度器（P：processer 处理器）</strong>优化，将 <strong>goroutine</strong> 内存占用限制在 <em>4KB</em>。</p>
<p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/gmpmodel.jpeg" alt="model"></p>
<ol>
<li><strong>全局队列</strong>（Global Queue）：存放等待运行的 <span style="color: green">G</span>。</li>
<li><strong>P的本地队列</strong>：同全局队列类似，存放的也是等待运行的 <span style="color: green">G</span>，存的数量有限，不超过256个。新建 <span style="color: green">G’</span> 时，<span style="color: green">G’</span> 优先加入到 <span style="color: yellow">P</span> 的本地队列，如果队列满了，则会把本地队列中一半的 <span style="color: green">G</span> 移动到全局队列。</li>
<li><strong>P列表</strong>：所有的 <span style="color: yellow">P</span> 都在程序启动时创建，并保存在数组中，最多有<code>GOMAXPROCS</code>(可配置)个。</li>
<li><strong><span style="color: blue">M</span><strong>：当前操作系统分配的操作 Go 程序的内核线程数。线程想运行任务就得获取 <span style="color: yellow">P</span>，从 <span style="color: yellow">P</span> 的本地队列获取 <span style="color: green">G</span>，<span style="color: yellow">P</span> 队列为空时，<span style="color: blue">M</span> 也会尝试从全局队列</strong>拿</strong>一批 <span style="color: green">G</span> 放到P的本地队列，或从其他 <span style="color: yellow">P</span> 的本地队列<strong>偷</strong>一半放到自己P的本地队列。<span style="color: blue">M</span> 运行 <span style="color: green">G</span>，<span style="color: green">G</span> 执行之后，<span style="color: blue">M</span> 会从 <span style="color: yellow">P</span> 获取下一个 <span style="color: green">G</span>，不断重复下去。</li>
</ol>
<h2 id="调度器的设计策略"><a href="#调度器的设计策略" class="headerlink" title="调度器的设计策略"></a>调度器的设计策略</h2><h3 id="1、复用线程"><a href="#1、复用线程" class="headerlink" title="1、复用线程"></a>1、复用线程</h3><p>复用线程策略主要分为两种机制：<strong>work stealing 机制</strong>和<strong>hand off 机制</strong>：</p>
<p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/workstealing.png" alt="work stealing 机制"></p>
<p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/handoff.png" alt="hand off 机制"></p>
<ul>
<li>work stealing 机制：在线程空闲时会从其他线程的本地队列中偷取 <span style="color: green">G</span> 执行。</li>
<li>hand off 机制：在一个线程出现 <span style="color: green">G</span> 阻塞的状况下，会将当前线程和 <span style="color: yellow">P</span> 分离，创建或者唤醒新的线程并将 <span style="color: yellow">P</span> 和新的线程绑定，而原来的线程在 <span style="color: green">G</span> 执行完毕后进入睡眠状态或被销毁。</li>
</ul>
<h3 id="2、利用并行"><a href="#2、利用并行" class="headerlink" title="2、利用并行"></a>2、利用并行</h3><p>使用<code>GOMAXPROCS</code>限定 <span style="color: yellow">P</span> 的个数为 CPU 个数 &#x2F; 2</p>
<h3 id="3、-抢占"><a href="#3、-抢占" class="headerlink" title="3、 抢占"></a>3、 抢占</h3><p>通过时间轮询，每 10ms CPU 会被其他 <span style="color: green">G</span> 抢占执行。</p>
<h3 id="4、全局-G-队列"><a href="#4、全局-G-队列" class="headerlink" title="4、全局 G 队列"></a>4、全局 <span style="color: green">G</span> 队列</h3><p>在 <strong>work stealing 机制</strong>基础上，如果在其他 <span style="color: yellow">P</span> 中无法偷取 G，就会从全局队列中获取。在新的调度器中依然有全局 <span style="color: green">G</span> 队列，当 <span style="color: yellow">P</span> 的本地队列为空时，优先从全局队列获取，如果全局队列为空时则通过 <strong>work stealing 机制</strong>从其他 <span style="color: yellow">P</span> 的本地队列偷取 <span style="color: green">G</span>。</p>
<h2 id="go-func-流程"><a href="#go-func-流程" class="headerlink" title="go func 流程"></a>go func 流程</h2><p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/gofunc.jpeg" alt="go func 流程"></p>
<ol>
<li><p>我们通过 go func() 来创建一个 goroutine；</p>
</li>
<li><p>有两个存储 <span style="color: green">G</span> 的队列，一个是局部调度器 <span style="color: yellow">P</span> 的本地队列、一个是全局 <span style="color: green">G</span> 队列。新创建的 <span style="color: green">G</span> 会先保存在 <span style="color: yellow">P</span> 的本地队列中，如果 <span style="color: yellow">P</span> 的本地队列已经满了就会保存在全局的队列中；</p>
</li>
<li><p><span style="color: green">G</span> 只能运行在 <span style="color: blue">M</span> 中，一个 <span style="color: blue">M</span> 必须持有一个 P，M 与 <span style="color: yellow">P</span> 是 1：1 的关系。M 会从 <span style="color: yellow">P</span> 的本地队列弹出一个可执行状态的 <span style="color: green">G</span> 来执行，如果 <span style="color: yellow">P</span> 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 <span style="color: green">G</span> 来执行；</p>
</li>
<li><p>一个 <span style="color: blue">M</span> 调度 <span style="color: green">G</span> 执行的过程是一个循环机制；</p>
</li>
<li><p>当 <span style="color: blue">M</span> 执行某一个 <span style="color: green">G</span> 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 <span style="color: green">G</span> 在执行，runtime 会把这个线程 <span style="color: blue">M</span> 从 <span style="color: yellow">P</span> 中摘除（detach），然后再创建一个新的操作系统的线程（如果有空闲的线程可用就复用空闲线程）来服务于这个 P；</p>
</li>
<li><p>当 <span style="color: blue">M</span> 系统调用结束时候，这个 <span style="color: green">G</span> 会尝试获取一个空闲的 <span style="color: yellow">P</span> 执行，并放入到这个 c的本地队列。如果获取不到 P，那么这个线程 <span style="color: blue">M</span> 变成休眠状态， 加入到空闲线程中，然后这个 <span style="color: green">G</span> 会被放入全局队列中。</p>
</li>
</ol>
<h2 id="调度器的生命周期"><a href="#调度器的生命周期" class="headerlink" title="调度器的生命周期"></a>调度器的生命周期</h2><p><img src="/2025/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B/life.png" alt="生命周期"></p>
<ul>
<li><p>**<span style="color: blue">M0</span>**：<span style="color: blue">M0</span> 是启动程序后的编号为 0 的主线程，这个 <span style="color: blue">M</span> 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，<span style="color: blue">M0</span> 负责执行初始化操作和启动第一个 G， 在之后 <span style="color: blue">M0</span> 就和其他的 <span style="color: blue">M</span> 一样了。</p>
</li>
<li><p>**<span style="color: green">G0</span>**：<span style="color: green">G0</span> 是每次启动一个 <span style="color: blue">M</span> 都会第一个创建的 gourtine，<span style="color: green">G0</span> 仅用于负责调度的 G，<span style="color: green">G0</span> 不指向任何可执行的函数，每个 <span style="color: blue">M</span> 都会有一个自己的 G0。在调度或系统调用时会使用 <span style="color: green">G0</span> 的栈空间，全局变量的 <span style="color: green">G0</span> 是 <span style="color: blue">M0</span> 的 <span style="color: green">G0</span>。</p>
</li>
</ul>
<h1 id="五、一些问题"><a href="#五、一些问题" class="headerlink" title="五、一些问题"></a>五、一些问题</h1><ol>
<li><p><span style="color: blue">M</span> 从阻塞状态中恢复为什么不能直接执行 <span style="color: yellow">P</span>？</p>
<p>因为 gorountine 分配内存的第一路径是通过 <span style="color: yellow">P</span> 的本地内存申请的，没有 <span style="color: yellow">P</span> 就无法申请内存去执行 <span style="color: green">G</span>。</p>
</li>
<li><p>恢复后的 <span style="color: blue">M</span> 为什么优先获取原来的 <span style="color: yellow">P</span>？</p>
<p>因为 <span style="color: blue">M</span> 在线程上会缓存 <span style="color: yellow">P</span> 的上下文等资源，如果恢复时间短，缓存就有可能还存在于 CPU 中没有被销毁。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
      <tags>
        <tag>GO</tag>
        <tag>后端</tag>
      </tags>
  </entry>
</search>
